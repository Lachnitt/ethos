/** ================ AUTO GENERATED ============ */
#include "state.h"
#include "type_checker.h"

namespace alfc {

AttrMap _amap;
std::map<ExprValue*, size_t> _runId;
Ctx _ctxTmp;
Expr _etmp;
  Expr _e1;
  Expr _e2;
  Expr _e3;
  Expr _e4;
  Expr _e5;
  Expr _e6;
  Expr _e7;
  Expr _e8;
  Expr _e9;
  Expr _e10;
  Expr _e11;
  Expr _e12;
  Expr _e13;
  Expr _e14;
  Expr _e15;
  Expr _e16;
  Expr _e17;
  Expr _e18;
  Expr _e19;
  Expr _e20;
  Expr _e21;
  Expr _e22;
  Expr _e23;
  Expr _e24;
  Expr _e25;
  Expr _e26;
  Expr _e27;
  Expr _e28;
  Expr _e29;
  Expr _e30;
  Expr _e31;
  Expr _e32;
  Expr _e33;
  Expr _e34;
  Expr _e35;
  Expr _e36;
  Expr _e37;
  Expr _e38;
  Expr _e39;
  Expr _e40;
  Expr _e41;
  Expr _e42;
  Expr _e43;
  Expr _e44;
  Expr _e45;
  Expr _e46;
  Expr _e47;
  Expr _e48;
  Expr _e49;
  Expr _e50;
  Expr _e51;
  Expr _e52;
  Expr _e53;
  Expr _e54;
  Expr _e55;
  Expr _e56;
  Expr _e57;
  Expr _e58;
  Expr _e59;
  Expr _e60;
  Expr _e61;
  Expr _e62;
  Expr _e63;
  Expr _e64;
  Expr _e65;
  Expr _e66;
  Expr _e67;
  Expr _e68;
  Expr _e69;
  Expr _e70;
  Expr _e71;
  Expr _e72;
  Expr _e73;
  Expr _e74;
  Expr _e75;
  Expr _e76;
  Expr _e77;
  Expr _e78;
  Expr _e79;
  Expr _e80;
  Expr _e81;
  Expr _e82;
  Expr _e83;
  Expr _e84;
  Expr _e85;
  Expr _e86;
  Expr _e87;
  Expr _e88;
  Expr _e89;
  Expr _e90;
  Expr _e91;
  Expr _e92;
  Expr _e93;
  Expr _e94;
  Expr _e95;
  Expr _e96;
  Expr _e97;
  Expr _e98;
  Expr _e99;
  Expr _e100;
  Expr _e101;
  Expr _e102;
  Expr _e103;
  Expr _e104;
  Expr _e105;
  Expr _e106;
  Expr _e107;
  Expr _e108;
  Expr _e109;
  Expr _e110;
  Expr _e111;
  Expr _e112;
  Expr _e113;
  Expr _e114;
  Expr _e115;
  Expr _e116;
  Expr _e117;
  Expr _e118;
  Expr _e119;
  Expr _e120;
  Expr _e121;
  Expr _e122;
  Expr _e123;
  Expr _e124;
  Expr _e125;
  Expr _e126;
  Expr _e127;
  Expr _e128;
  Expr _e129;
  Expr _e130;
  Expr _e131;
  Expr _e132;
  Expr _e133;
  Expr _e134;
  Expr _e135;
  Expr _e136;
  Expr _e137;
  Expr _e138;
  Expr _e139;
  Expr _e140;
  Expr _e141;
  Expr _e142;
  Expr _e143;
  Expr _e144;
  Expr _e145;
  Expr _e146;
  Expr _e147;
  Expr _e148;
  Expr _e149;
  Expr _e150;
  Expr _e151;
  Expr _e152;
  Expr _e153;
  Expr _e154;
  Expr _e155;
  Expr _e156;
  Expr _e157;
  Expr _e158;
  Expr _e159;
  Expr _e160;
  Expr _e161;
  Expr _e162;
  Expr _e163;
  Expr _e164;
  Expr _e165;
  Expr _e166;
  Expr _e167;
  Expr _e168;
  Expr _e169;
  Expr _e170;
  Expr _e171;
  Expr _e172;
  Expr _e173;
  Expr _e174;
  Expr _e175;
  Expr _e176;
  Expr _e177;
  Expr _e178;
  Expr _e179;
  Expr _e180;
  Expr _e181;
  Expr _e182;
  Expr _e183;
  Expr _e184;
  Expr _e185;
  Expr _e186;
  Expr _e187;
  Expr _e188;
  Expr _e189;
  Expr _e190;
  Expr _e191;
  Expr _e192;
  Expr _e193;
  Expr _e194;
  Expr _e195;
  Expr _e196;
  Expr _e197;
  Expr _e198;
  Expr _e199;
  Expr _e200;
  Expr _e201;
  Expr _e202;
  Expr _e203;
  Expr _e204;
  Expr _e205;
  Expr _e206;
  Expr _e207;
  Expr _e208;
  Expr _e209;
  Expr _e210;
  Expr _e211;
  Expr _e212;
  Expr _e213;
  Expr _e214;
  Expr _e215;
  Expr _e216;
  Expr _e217;
  Expr _e218;
  Expr _e219;
  Expr _e220;
  Expr _e221;
  Expr _e222;
  Expr _e223;
  Expr _e224;
  Expr _e225;
  Expr _e226;
  Expr _e227;
  Expr _e228;
  Expr _e229;
  Expr _e230;
  Expr _e231;
  Expr _e232;
  Expr _e233;
  Expr _e234;
  Expr _e235;
  Expr _e236;
  Expr _e237;
  Expr _e238;
  Expr _e239;
  Expr _e240;
  Expr _e241;
  Expr _e242;
  Expr _e243;
  Expr _e244;
  Expr _e245;
  Expr _e246;
  Expr _e247;
  Expr _e248;
  Expr _e249;
  Expr _e250;
  Expr _e251;
  Expr _e252;
  Expr _e253;
  Expr _e254;
  Expr _e255;
  Expr _e256;
  Expr _e257;
  Expr _e258;
  Expr _e259;
  Expr _e260;
  Expr _e261;
  Expr _e262;
  Expr _e263;
  Expr _e264;
  Expr _e265;
  Expr _e266;
  Expr _e267;
  Expr _e268;
  Expr _e269;
  Expr _e270;
  Expr _e271;
  Expr _e272;
  Expr _e273;
  Expr _e274;
  Expr _e275;
  Expr _e276;
  Expr _e277;
  Expr _e278;
  Expr _e279;
  Expr _e280;
  Expr _e281;
  Expr _e282;
  Expr _e283;
  Expr _e284;
  Expr _e285;
  Expr _e286;
  Expr _e287;
  Expr _e288;
  Expr _e289;
  Expr _e290;
  Expr _e291;
  Expr _e292;
  Expr _e293;
  Expr _e294;
  Expr _e295;
  Expr _e296;
  Expr _e297;
  Expr _e298;
  Expr _e299;
  Expr _e300;
  Expr _e301;
  Expr _e302;
  Expr _e303;
  Expr _e304;
  Expr _e305;
  Expr _e306;
  Expr _e307;
  Expr _e308;
  Expr _e309;
  Expr _e310;
  Expr _e311;
  Expr _e312;
  Expr _e313;
  Expr _e314;
  Expr _e315;
  Expr _e316;
  Expr _e317;
  Expr _e318;
  Expr _e319;
  Expr _e320;
  Expr _e321;
  Expr _e322;
  Expr _e323;
  Expr _e324;
  Expr _e325;
  Expr _e326;
  Expr _e327;
  Expr _e328;
  Expr _e329;
  Expr _e330;
  Expr _e331;
  Expr _e332;
  Expr _e333;
  Expr _e334;
  Expr _e335;
  Expr _e336;
  Expr _e337;
  Expr _e338;
  Expr _e339;
  Expr _e340;
  Expr _e341;
  Expr _e342;
  Expr _e343;
  Expr _e344;
  Expr _e345;
  Expr _e346;
  Expr _e347;
  Expr _e348;
  Expr _e349;
  Expr _e350;
  Expr _e351;
  Expr _e352;
  Expr _e353;
  Expr _e354;
  Expr _e355;
  Expr _e356;
  Expr _e357;
  Expr _e358;
  Expr _e359;
  Expr _e360;
  Expr _e361;
  Expr _e362;
  Expr _e363;
  Expr _e364;
  Expr _e365;
  Expr _e366;
  Expr _e367;
  Expr _e368;
  Expr _e369;
  Expr _e370;
  Expr _e371;
  Expr _e372;
  Expr _e373;
  Expr _e374;
  Expr _e375;
  Expr _e376;
  Expr _e377;
  Expr _e378;
  Expr _e379;
  Expr _e380;
  Expr _e381;
  Expr _e382;
  Expr _e383;
  Expr _e384;
  Expr _e385;
  Expr _e386;
  Expr _e387;
  Expr _e388;
  Expr _e389;
  Expr _e390;
  Expr _e391;
  Expr _e392;
  Expr _e393;
  Expr _e394;
  Expr _e395;
  Expr _e396;
  Expr _e397;
  Expr _e398;
  Expr _e399;
  Expr _e400;
  Expr _e401;
  Expr _e402;
  Expr _e403;
  Expr _e404;
  Expr _e405;
  Expr _e406;
  Expr _e407;
  Expr _e408;
  Expr _e409;
  Expr _e410;
  Expr _e411;
  Expr _e412;
  Expr _e413;
  Expr _e414;
  Expr _e415;
  Expr _e416;
  Expr _e417;
  Expr _e418;
  Expr _e419;
  Expr _e420;
  Expr _e421;
  Expr _e422;
  Expr _e423;
  Expr _e424;
  Expr _e425;
  Expr _e426;
  Expr _e427;
  Expr _e428;
  Expr _e429;
  Expr _e430;
  Expr _e431;
  Expr _e432;
  Expr _e433;
  Expr _e434;
  Expr _e435;
  Expr _e436;
  Expr _e437;
  Expr _e438;
  Expr _e439;
  Expr _e440;
  Expr _e441;
  Expr _e442;
  Expr _e443;
  Expr _e444;
  Expr _e445;
  Expr _e446;
  Expr _e447;
  Expr _e448;
  Expr _e449;
  Expr _e450;
  Expr _e451;
  Expr _e452;
  Expr _e453;
  Expr _e454;
  Expr _e455;
  Expr _e456;
  Expr _e457;
  Expr _e458;
  Expr _e459;
  Expr _e460;
  Expr _e461;
  Expr _e462;
  Expr _e463;
  Expr _e464;
  Expr _e465;
  Expr _e466;
  Expr _e467;
  Expr _e468;
  Expr _e469;
  Expr _e470;
  Expr _e471;
  Expr _e472;
  Expr _e473;
  Expr _e474;
  Expr _e475;
  Expr _e476;
  Expr _e477;
  Expr _e478;
  Expr _e479;
  Expr _e480;
  Expr _e481;
  Expr _e482;
  Expr _e483;
  Expr _e484;
  Expr _e485;
  Expr _e486;
  Expr _e487;
  Expr _e488;
  Expr _e489;
  Expr _e490;
  Expr _e491;
  Expr _e492;
  Expr _e493;
  Expr _e494;
  Expr _e495;
  Expr _e496;
  Expr _e497;
  Expr _e498;
  Expr _e499;
  Expr _e500;
  Expr _e501;
  Expr _e502;
  Expr _e503;
  Expr _e504;
  Expr _e505;
  Expr _e506;
  Expr _e507;
  Expr _e508;
  Expr _e509;
  Expr _e510;
  Expr _e511;
  Expr _e512;
  Expr _e513;
  Expr _e514;
  Expr _e515;
  Expr _e516;
  Expr _e517;
  Expr _e518;
  Expr _e519;
  Expr _e520;
  Expr _e521;
  Expr _e522;
  Expr _e523;
  Expr _e524;
  Expr _e525;
  Expr _e526;
  Expr _e527;
  Expr _e528;
  Expr _e529;
  Expr _e530;
  Expr _e531;
  Expr _e532;
  Expr _e533;
  Expr _e534;
  Expr _e535;
  Expr _e536;
  Expr _e537;
  Expr _e538;
  Expr _e539;
  Expr _e540;
  Expr _e541;
  Expr _e542;
  Expr _e543;
  Expr _e544;
  Expr _e545;
  Expr _e546;
  Expr _e547;
  Expr _e548;
  Expr _e549;
  Expr _e550;
  Expr _e551;
  Expr _e552;
  Expr _e553;
  Expr _e554;
  Expr _e555;
  Expr _e556;
  Expr _e557;
  Expr _e558;
  Expr _e559;
  Expr _e560;
  Expr _e561;
  Expr _e562;
  Expr _e563;
  Expr _e564;
  Expr _e565;
  Expr _e566;
  Expr _e567;
  Expr _e568;
  Expr _e569;
  Expr _e570;
  Expr _e571;
  Expr _e572;
  Expr _e573;
  Expr _e574;
  Expr _e575;
  Expr _e576;
  Expr _e577;
  Expr _e578;
  Expr _e579;
  Expr _e580;
  Expr _e581;
  Expr _e582;
  Expr _e583;
  Expr _e584;
  Expr _e585;
  Expr _e586;
  Expr _e587;
  Expr _e588;
  Expr _e589;
  Expr _e590;
  Expr _e591;
  Expr _e592;
  Expr _e593;
  Expr _e594;
  Expr _e595;
  Expr _e596;
  Expr _e597;
  Expr _e598;
  Expr _e599;
  Expr _e600;
  Expr _e601;
  Expr _e602;
  Expr _e603;
  Expr _e604;
  Expr _e605;
  Expr _e606;
  Expr _e607;
  Expr _e608;
  Expr _e609;
  Expr _e610;
  Expr _e611;
  Expr _e612;
  Expr _e613;
  Expr _e614;
  Expr _e615;
  Expr _e616;
  Expr _e617;
  Expr _e618;
  Expr _e619;
  Expr _e620;
  Expr _e621;
  Expr _e622;
  Expr _e623;
  Expr _e624;
  Expr _e625;
  Expr _e626;
  Expr _e627;
  Expr _e628;
  Expr _e629;
  Expr _e630;
  Expr _e631;
  Expr _e632;
  Expr _e633;
  Expr _e634;
  Expr _e635;
  Expr _e636;
  Expr _e637;
  Expr _e638;
  Expr _e639;
  Expr _e640;
  Expr _e641;
  Expr _e642;
  Expr _e643;
  Expr _e644;
  Expr _e645;
  Expr _e646;
  Expr _e647;
  Expr _e648;
  Expr _e649;
  Expr _e650;
  Expr _e651;
  Expr _e652;
  Expr _e653;
  Expr _e654;
  Expr _e655;
  Expr _e656;
  Expr _e657;
  Expr _e658;
  Expr _e659;
  Expr _e660;
  Expr _e661;
  Expr _e662;
  Expr _e663;
  Expr _e664;
  Expr _e665;
  Expr _e666;
  Expr _e667;
  Expr _e668;
  Expr _e669;
  Expr _e670;
  Expr _e671;
  Expr _e672;
  Expr _e673;
  Expr _e674;
  Expr _e675;
  Expr _e676;
  Expr _e677;
  Expr _e678;
  Expr _e679;
  Expr _e680;
  Expr _e681;
  Expr _e682;
  Expr _e683;
  Expr _e684;
  Expr _e685;
  Expr _e686;
  Expr _e687;
  Expr _e688;
  Expr _e689;
  Expr _e690;
  Expr _e691;
  Expr _e692;
  Expr _e693;
  Expr _e694;
  Expr _e695;
  Expr _e696;
  Expr _e697;
  Expr _e698;
  Expr _e699;
  Expr _e700;
  Expr _e701;
  Expr _e702;
  Expr _e703;
  Expr _e704;
  Expr _e705;
  Expr _e706;
  Expr _e707;
  Expr _e708;
  Expr _e709;
  Expr _e710;
  Expr _e711;
  Expr _e712;
  Expr _e713;
  Expr _e714;
  Expr _e715;
  Expr _e716;
  Expr _e717;
  Expr _e718;
  Expr _e719;
  Expr _e720;
  Expr _e721;
  Expr _e722;
  Expr _e723;
  Expr _e724;
  Expr _e725;
  Expr _e726;
  Expr _e727;
  Expr _e728;
  Expr _e729;
  Expr _e730;
  Expr _e731;
  Expr _e732;
  Expr _e733;
  Expr _e734;
  Expr _e735;
  Expr _e736;
  Expr _e737;
  Expr _e738;
  Expr _e739;
  Expr _e740;
  Expr _e741;
  Expr _e742;
  Expr _e743;
  Expr _e744;
  Expr _e745;
  Expr _e746;
  Expr _e747;
  Expr _e748;
  Expr _e749;
  Expr _e750;
  Expr _e751;
  Expr _e752;
  Expr _e753;
  Expr _e754;
  Expr _e755;
  Expr _e756;
  Expr _e757;
  Expr _e758;
  Expr _e759;
  Expr _e760;
  Expr _e761;
  Expr _e762;
  Expr _e763;
  Expr _e764;
  Expr _e765;
  Expr _e766;
  Expr _e767;
  Expr _e768;
  Expr _e769;
  Expr _e770;
  Expr _e771;
  Expr _e772;
  Expr _e773;
  Expr _e774;
  Expr _e775;
  Expr _e776;
  Expr _e777;
  Expr _e778;
  Expr _e779;
  Expr _e780;
  Expr _e781;
  Expr _e782;
  Expr _e783;
  Expr _e784;
  Expr _e785;
  Expr _e786;
  Expr _e787;
  Expr _e788;
  Expr _e789;
  Expr _e790;
  Expr _e791;
  Expr _e792;
  Expr _e793;
  Expr _e794;
  Expr _e795;
  Expr _e796;
  Expr _e797;
  Expr _e798;
  Expr _e799;
  Expr _e800;
  Expr _e801;
  Expr _e802;
  Expr _e803;
  Expr _e804;
  Expr _e805;
  Expr _e806;
  Expr _e807;
  Expr _e808;
  Expr _e809;
  Expr _e810;
  Expr _e811;
  Expr _e812;
  Expr _e813;
  Expr _e814;
  Expr _e815;
  Expr _e816;
  Expr _e817;
  Expr _e818;
  Expr _e819;
  Expr _e820;
  Expr _e821;
  Expr _e822;
  Expr _e823;
  Expr _e824;
  Expr _e825;
  Expr _e826;
  Expr _e827;
  Expr _e828;
  Expr _e829;
  Expr _e830;
  Expr _e831;
  Expr _e832;
  Expr _e833;
  Expr _e834;
  Expr _e835;
  Expr _e836;
  Expr _e837;
  Expr _e838;
  Expr _e839;
  Expr _e840;
  Expr _e841;
  Expr _e842;
  Expr _e843;
  Expr _e844;
  Expr _e845;
  Expr _e846;
  Expr _e847;
  Expr _e848;
  Expr _e849;
  Expr _e850;
  Expr _e851;
  Expr _e852;
  Expr _e853;
  Expr _e854;
  Expr _e855;
  Expr _e856;
  Expr _e857;
  Expr _e858;
  Expr _e859;
  Expr _e860;
  Expr _e861;
  Expr _e862;
  Expr _e863;
  Expr _e864;
  Expr _e865;
  Expr _e866;
  Expr _e867;
  Expr _e868;
  Expr _e869;
  Expr _e870;
  Expr _e871;
  Expr _e872;
  Expr _e873;
  Expr _e874;
  Expr _e875;
  Expr _e876;
  Expr _e877;
  Expr _e878;
  Expr _e879;
  Expr _e880;
  Expr _e881;
  Expr _e882;
  Expr _e883;
  Expr _e884;
  Expr _e885;
  Expr _e886;
  Expr _e887;
  Expr _e888;
  Expr _e889;
  Expr _e890;
  Expr _e891;
  Expr _e892;
  Expr _e893;
  Expr _e894;
  Expr _e895;
  Expr _e896;
  Expr _e897;
  Expr _e898;
  Expr _e899;
  Expr _e900;
  Expr _e901;
  Expr _e902;
  Expr _e903;
  Expr _e904;
  Expr _e905;
  Expr _e906;
  Expr _e907;
  Expr _e908;
  Expr _e909;
  Expr _e910;
  Expr _e911;
  Expr _e912;
  Expr _e913;
  Expr _e914;
  Expr _e915;
  Expr _e916;
  Expr _e917;
  Expr _e918;
  Expr _e919;
  Expr _e920;
  Expr _e921;
  Expr _e922;
  Expr _e923;
  Expr _e924;
  Expr _e925;
  Expr _e926;
  Expr _e927;
  Expr _e928;
  Expr _e929;
  Expr _e930;
  Expr _e931;
  Expr _e932;
  Expr _e933;
  Expr _e934;
  Expr _e935;
  Expr _e936;
  Expr _e937;
  Expr _e938;
  Expr _e939;
  Expr _e940;
  Expr _e941;
  Expr _e942;
  Expr _e943;
  Expr _e944;
  Expr _e945;
  Expr _e946;
  Expr _e947;
  Expr _e948;
  Expr _e949;
  Expr _e950;
  Expr _e951;
  Expr _e952;
  Expr _e953;
  Expr _e954;
  Expr _e955;
  Expr _e956;
  Expr _e957;
  Expr _e958;
  Expr _e959;
  Expr _e960;
  Expr _e961;
  Expr _e962;
  Expr _e963;
  Expr _e964;
  Expr _e965;
  Expr _e966;
  Expr _e967;
  Expr _e968;
  Expr _e969;
  Expr _e970;
  Expr _e971;
  Expr _e972;
  Expr _e973;
  Expr _e974;
  Expr _e975;
  Expr _e976;
  Expr _e977;
  Expr _e978;
  Expr _e979;
  Expr _e980;
  Expr _e981;
  Expr _e982;
  Expr _e983;
  Expr _e984;
  Expr _e985;
  Expr _e986;
  Expr _e987;
  Expr _e988;
  Expr _e989;
  Expr _e990;
  Expr _e991;
  Expr _e992;
  Expr _e993;
  Expr _e994;
  Expr _e995;
  Expr _e996;
  Expr _e997;
  Expr _e998;
  Expr _e999;
  Expr _e1000;
  Expr _e1001;
  Expr _e1002;
  Expr _e1003;
  Expr _e1004;
  Expr _e1005;
  Expr _e1006;
  Expr _e1007;
  Expr _e1008;
  Expr _e1009;
  Expr _e1010;
  Expr _e1011;
  Expr _e1012;
  Expr _e1013;
  Expr _e1014;
  Expr _e1015;
  Expr _e1016;
  Expr _e1017;
  Expr _e1018;
  Expr _e1019;
  Expr _e1020;
  Expr _e1021;
  Expr _e1022;
  Expr _e1023;
  Expr _e1024;
  Expr _e1025;
  Expr _e1026;
  Expr _e1027;
  Expr _e1028;
  Expr _e1029;
  Expr _e1030;
  Expr _e1031;
  Expr _e1032;
  Expr _e1033;
  Expr _e1034;
  Expr _e1035;
  Expr _e1036;
  Expr _e1037;
  Expr _e1038;
  Expr _e1039;
  Expr _e1040;
  Expr _e1041;
  Expr _e1042;
  Expr _e1043;
  Expr _e1044;
  Expr _e1045;
  Expr _e1046;
  Expr _e1047;
  Expr _e1048;
  Expr _e1049;
  Expr _e1050;
  Expr _e1051;
  Expr _e1052;
  Expr _e1053;
  Expr _e1054;
  Expr _e1055;
  Expr _e1056;
  Expr _e1057;
  Expr _e1058;
  Expr _e1059;
  Expr _e1060;
  Expr _e1061;
  Expr _e1062;
  Expr _e1063;
  Expr _e1064;
  Expr _e1065;
  Expr _e1066;
  Expr _e1067;
  Expr _e1068;
  Expr _e1069;
  Expr _e1070;
  Expr _e1071;
  Expr _e1072;
  Expr _e1073;
  Expr _e1074;
  Expr _e1075;
  Expr _e1076;
  Expr _e1077;
  Expr _e1078;
  Expr _e1079;
  Expr _e1080;
  Expr _e1081;
  Expr _e1082;
  Expr _e1083;
  Expr _e1084;
  Expr _e1085;
  Expr _e1086;
  Expr _e1087;
  Expr _e1088;
  Expr _e1089;
  Expr _e1090;
  Expr _e1091;
  Expr _e1092;
  Expr _e1093;
  Expr _e1094;
  Expr _e1095;
  Expr _e1096;
  Expr _e1097;
  Expr _e1098;
  Expr _e1099;
  Expr _e1100;
  Expr _e1101;
  Expr _e1102;
  Expr _e1103;
  Expr _e1104;
  Expr _e1105;
  Expr _e1106;
  Expr _e1107;
  Expr _e1108;
  Expr _e1109;
  Expr _e1110;
  Expr _e1111;
  Expr _e1112;
  Expr _e1113;
  Expr _e1114;
  Expr _e1115;
  Expr _e1116;
  Expr _e1117;
  Expr _e1118;
  Expr _e1119;
  Expr _e1120;
  Expr _e1121;
  Expr _e1122;
  Expr _e1123;
  Expr _e1124;
  Expr _e1125;
  Expr _e1126;
  Expr _e1127;
  Expr _e1128;
  Expr _e1129;
  Expr _e1130;
  Expr _e1131;
  Expr _e1132;
  Expr _e1133;
  Expr _e1134;
  Expr _e1135;
  Expr _e1136;
  Expr _e1137;
  Expr _e1138;
  Expr _e1139;
  Expr _e1140;
  Expr _e1141;
  Expr _e1142;
  Expr _e1143;
  Expr _e1144;
  Expr _e1145;
  Expr _e1146;
  Expr _e1147;
  Expr _e1148;
  Expr _e1149;
  Expr _e1150;
  Expr _e1151;
  Expr _e1152;
  Expr _e1153;
  Expr _e1154;
  Expr _e1155;
  Expr _e1156;
  Expr _e1157;
  Expr _e1158;
  Expr _e1159;
  Expr _e1160;
  Expr _e1161;
  Expr _e1162;
  Expr _e1163;
  Expr _e1164;
  Expr _e1165;
  Expr _e1166;
  Expr _e1167;
  Expr _e1168;
  Expr _e1169;
  Expr _e1170;
  Expr _e1171;
  Expr _e1172;
  Expr _e1173;
  Expr _e1174;
  Expr _e1175;
  Expr _e1176;
  Expr _e1177;
  Expr _e1178;
  Expr _e1179;
  Expr _e1180;
  Expr _e1181;
  Expr _e1182;
  Expr _e1183;
  Expr _e1184;
  Expr _e1185;
  Expr _e1186;
  Expr _e1187;
  Expr _e1188;
  Expr _e1189;
  Expr _e1190;
  Expr _e1191;
  Expr _e1192;
  Expr _e1193;
  Expr _e1194;
  Expr _e1195;
  Expr _e1196;
  Expr _e1197;
  Expr _e1198;
  Expr _e1199;
  Expr _e1200;
  Expr _e1201;
  Expr _e1202;
  Expr _e1203;
  Expr _e1204;
  Expr _e1205;
  Expr _e1206;
  Expr _e1207;
  Expr _e1208;
  Expr _e1209;
  Expr _e1210;
  Expr _e1211;
  Expr _e1212;
  Expr _e1213;
  Expr _e1214;
  Expr _e1215;
  Expr _e1216;
  Expr _e1217;
  Expr _e1218;
  Expr _e1219;
  Expr _e1220;
  Expr _e1221;
  Expr _e1222;
  Expr _e1223;
  Expr _e1224;
  Expr _e1225;
  Expr _e1226;
  Expr _e1227;
  Expr _e1228;
  Expr _e1229;
  Expr _e1230;
  Expr _e1231;
  Expr _e1232;
  Expr _e1233;
  Expr _e1234;
  Expr _e1235;
  Expr _e1236;
  Expr _e1237;
  Expr _e1238;
  Expr _e1239;
  Expr _e1240;
  Expr _e1241;
  Expr _e1242;
  Expr _e1243;
  Expr _e1244;
  Expr _e1245;
  Expr _e1246;
  Expr _e1247;
  Expr _e1248;
  Expr _e1249;
  Expr _e1250;
  Expr _e1251;
  Expr _e1252;
  Expr _e1253;
  Expr _e1254;
  Expr _e1255;
  Expr _e1256;
  Expr _e1257;
  Expr _e1258;
  Expr _e1259;
  Expr _e1260;
  Expr _e1261;
  Expr _e1262;
  Expr _e1263;
  Expr _e1264;
  Expr _e1265;
  Expr _e1266;
  Expr _e1267;
  Expr _e1268;
  Expr _e1269;
  Expr _e1270;
  Expr _e1271;
  Expr _e1272;
  Expr _e1273;
  Expr _e1274;
  Expr _e1275;
  Expr _e1276;
  Expr _e1277;
  Expr _e1278;
  Expr _e1279;
  Expr _e1280;
  Expr _e1281;
  Expr _e1282;
  Expr _e1283;
  Expr _e1284;
  Expr _e1285;
  Expr _e1286;
  Expr _e1287;
  Expr _e1288;
  Expr _e1289;
  Expr _e1290;
  Expr _e1291;
  Expr _e1292;
  Expr _e1293;
  Expr _e1294;
  Expr _e1295;
  Expr _e1296;
  Expr _e1297;
  Expr _e1298;
  Expr _e1299;
  Expr _e1300;
  Expr _e1301;
  Expr _e1302;
  Expr _e1303;
  Expr _e1304;
  Expr _e1305;
  Expr _e1306;
  Expr _e1307;
  Expr _e1308;
  Expr _e1309;
  Expr _e1310;
  Expr _e1311;
  Expr _e1312;
  Expr _e1313;
  Expr _e1314;
  Expr _e1315;
  Expr _e1316;
  Expr _e1317;
  Expr _e1318;
  Expr _e1319;
  Expr _e1320;
  Expr _e1321;
  Expr _e1322;
  Expr _e1323;
  Expr _e1324;
  Expr _e1325;
  Expr _e1326;
  Expr _e1327;
  Expr _e1328;
  Expr _e1329;
  Expr _e1330;
  Expr _e1331;
  Expr _e1332;
  Expr _e1333;
  Expr _e1334;
  Expr _e1335;
  Expr _e1336;
  Expr _e1337;
  Expr _e1338;
  Expr _e1339;
  Expr _e1340;
  Expr _e1341;
  Expr _e1342;
  Expr _e1343;
  Expr _e1344;
  Expr _e1345;
  Expr _e1346;
  Expr _e1347;
  Expr _e1348;
  Expr _e1349;
  Expr _e1350;
  Expr _e1351;
  Expr _e1352;
  Expr _e1353;
  Expr _e1354;
  Expr _e1355;
  Expr _e1356;
  Expr _e1357;
  Expr _e1358;
  Expr _e1359;
  Expr _e1360;
  Expr _e1361;
  Expr _e1362;
  Expr _e1363;
  Expr _e1364;
  Expr _e1365;
  Expr _e1366;
  Expr _e1367;
  Expr _e1368;
  Expr _e1369;
  Expr _e1370;
  Expr _e1371;
  Expr _e1372;
  Expr _e1373;
  Expr _e1374;
  Expr _e1375;
  Expr _e1376;
  Expr _e1377;
  Expr _e1378;
  Expr _e1379;
  Expr _e1380;
  Expr _e1381;
  Expr _e1382;
  Expr _e1383;
  Expr _e1384;
  Expr _e1385;
  Expr _e1386;
  Expr _e1387;
  Expr _e1388;
  Expr _e1389;
  Expr _e1390;
  Expr _e1391;
  Expr _e1392;
  Expr _e1393;
  Expr _e1394;
  Expr _e1395;
  Expr _e1396;
  Expr _e1397;
  Expr _e1398;
  Expr _e1399;
  Expr _e1400;
  Expr _e1401;
  Expr _e1402;
  Expr _e1403;
  Expr _e1404;
  Expr _e1405;
  Expr _e1406;
  Expr _e1407;
  Expr _e1408;
  Expr _e1409;
  Expr _e1410;
  Expr _e1411;
  Expr _e1412;
  Expr _e1413;
  Expr _e1414;
  Expr _e1415;
  Expr _e1416;
  Expr _e1417;
  Expr _e1418;
  Expr _e1419;
  Expr _e1420;
  Expr _e1421;
  Expr _e1422;
  Expr _e1423;
  Expr _e1424;
  Expr _e1425;
  Expr _e1426;
  Expr _e1427;
  Expr _e1428;
  Expr _e1429;
  Expr _e1430;
  Expr _e1431;
  Expr _e1432;
  Expr _e1433;
  Expr _e1434;
  Expr _e1435;
  Expr _e1436;
  Expr _e1437;
  Expr _e1438;
  Expr _e1439;
  Expr _e1440;
  Expr _e1441;
  Expr _e1442;
  Expr _e1443;
  Expr _e1444;
  Expr _e1445;
  Expr _e1446;
  Expr _e1447;
  Expr _e1448;
  Expr _e1449;
  Expr _e1450;
  Expr _e1451;
  Expr _e1452;
  Expr _e1453;
  Expr _e1454;
  Expr _e1455;
  Expr _e1456;
  Expr _e1457;
  Expr _e1458;
  Expr _e1459;
  Expr _e1460;
  Expr _e1461;
  Expr _e1462;
  Expr _e1463;
  Expr _e1464;
  Expr _e1465;
  Expr _e1466;
  Expr _e1467;
  Expr _e1468;
  Expr _e1469;
  Expr _e1470;
  Expr _e1471;
  Expr _e1472;
  Expr _e1473;
  Expr _e1474;
  Expr _e1475;
  Expr _e1476;
  Expr _e1477;
  Expr _e1478;
  Expr _e1479;
  Expr _e1480;
  Expr _e1481;
  Expr _e1482;
  Expr _e1483;
  Expr _e1484;
  Expr _e1485;
  Expr _e1486;
  Expr _e1487;
  Expr _e1488;
  Expr _e1489;
  Expr _e1490;
  Expr _e1491;
  Expr _e1492;
  Expr _e1493;
  Expr _e1494;
  Expr _e1495;
  Expr _e1496;
  Expr _e1497;
  Expr _e1498;
  Expr _e1499;
  Expr _e1500;
  Expr _e1501;
  Expr _e1502;
  Expr _e1503;
  Expr _e1504;
  Expr _e1505;
  Expr _e1506;
  Expr _e1507;
  Expr _e1508;
  Expr _e1509;
  Expr _e1510;
  Expr _e1511;
  Expr _e1512;
  Expr _e1513;
  Expr _e1514;
  Expr _e1515;
  Expr _e1516;
  Expr _e1517;
  Expr _e1518;
  Expr _e1519;
  Expr _e1520;
  Expr _e1521;
  Expr _e1522;
  Expr _e1523;
  Expr _e1524;
  Expr _e1525;
  Expr _e1526;
  Expr _e1527;
  Expr _e1528;
  Expr _e1529;
  Expr _e1530;
  Expr _e1531;
  Expr _e1532;
  Expr _e1533;
  Expr _e1534;
  Expr _e1535;
  Expr _e1536;
  Expr _e1537;
  Expr _e1538;
  Expr _e1539;
  Expr _e1540;
  Expr _e1541;
  Expr _e1542;
  Expr _e1543;
  Expr _e1544;
  Expr _e1545;
  Expr _e1546;
  Expr _e1547;
  Expr _e1548;
  Expr _e1549;
  Expr _e1550;
  Expr _e1551;
  Expr _e1552;
  Expr _e1553;
  Expr _e1554;
  Expr _e1555;
  Expr _e1556;
  Expr _e1557;
  Expr _e1558;
  Expr _e1559;
  Expr _e1560;
  Expr _e1561;
  Expr _e1562;
  Expr _e1563;
  Expr _e1564;
  Expr _e1565;
  Expr _e1566;
  Expr _e1567;
  Expr _e1568;
  Expr _e1569;
  Expr _e1570;
  Expr _e1571;
  Expr _e1572;
  Expr _e1573;
  Expr _e1574;
  Expr _e1575;
  Expr _e1576;
  Expr _e1577;
  Expr _e1578;
  Expr _e1579;
  Expr _e1580;
  Expr _e1581;
  Expr _e1582;
  Expr _e1583;
  Expr _e1584;
  Expr _e1585;
  Expr _e1586;
  Expr _e1587;
  Expr _e1588;
  Expr _e1589;
  Expr _e1590;
  Expr _e1591;
  Expr _e1592;
  Expr _e1593;
  Expr _e1594;
  Expr _e1595;
  Expr _e1596;
  Expr _e1597;
  Expr _e1598;
  Expr _e1599;
  Expr _e1600;
  Expr _e1601;
  Expr _e1602;
  Expr _e1603;
  Expr _e1604;
  Expr _e1605;
  Expr _e1606;
  Expr _e1607;
  Expr _e1608;
  Expr _e1609;
  Expr _e1610;
  Expr _e1611;
  Expr _e1612;
  Expr _e1613;
  Expr _e1614;
  Expr _e1615;
  Expr _e1616;
  Expr _e1617;
  Expr _e1618;
  Expr _e1619;
  Expr _e1620;
  Expr _e1621;
  Expr _e1622;
  Expr _e1623;
  Expr _e1624;
  Expr _e1625;
  Expr _e1626;
  Expr _e1627;
  Expr _e1628;
  Expr _e1629;
  Expr _e1630;
  Expr _e1631;
  Expr _e1632;
  Expr _e1633;
  Expr _e1634;
  Expr _e1635;
  Expr _e1636;
  Expr _e1637;
  Expr _e1638;
  Expr _e1639;
  Expr _e1640;
  Expr _e1641;
  Expr _e1642;
  Expr _e1643;
  Expr _e1644;
  Expr _e1645;
  Expr _e1646;
  Expr _e1647;
  Expr _e1648;
  Expr _e1649;
  Expr _e1650;
  Expr _e1651;
  Expr _e1652;
  Expr _e1653;
  Expr _e1654;
  Expr _e1655;
  Expr _e1656;
  Expr _e1657;
  Expr _e1658;
  Expr _e1659;
  Expr _e1660;
  Expr _e1661;
  Expr _e1662;
  Expr _e1663;
  Expr _e1664;
  Expr _e1665;
  Expr _e1666;
  Expr _e1667;
  Expr _e1668;
  Expr _e1669;
  Expr _e1670;
  Expr _e1671;
  Expr _e1672;
  Expr _e1673;
  Expr _e1674;
  Expr _e1675;
  Expr _e1676;
  Expr _e1677;
  Expr _e1678;
  Expr _e1679;
  Expr _e1680;
  Expr _e1681;
  Expr _e1682;
  Expr _e1683;
  Expr _e1684;
  Expr _e1685;
  Expr _e1686;
  Expr _e1687;
  Expr _e1688;
  Expr _e1689;
  Expr _e1690;
  Expr _e1691;
  Expr _e1692;
  Expr _e1693;
  Expr _e1694;
  Expr _e1695;
  Expr _e1696;
  Expr _e1697;
  Expr _e1698;
  Expr _e1699;
  Expr _e1700;
  Expr _e1701;
  Expr _e1702;
  Expr _e1703;
  Expr _e1704;
  Expr _e1705;
  Expr _e1706;
  Expr _e1707;
  Expr _e1708;
  Expr _e1709;
  Expr _e1710;
  Expr _e1711;
  Expr _e1712;
  Expr _e1713;
  Expr _e1714;
  Expr _e1715;
  Expr _e1716;
  Expr _e1717;
  Expr _e1718;
  Expr _e1719;
  Expr _e1720;
  Expr _e1721;
  Expr _e1722;
  Expr _e1723;
  Expr _e1724;
  Expr _e1725;
  Expr _e1726;
  Expr _e1727;
  Expr _e1728;
  Expr _e1729;
  Expr _e1730;
  Expr _e1731;
  Expr _e1732;
  Expr _e1733;
  Expr _e1734;
  Expr _e1735;
  Expr _e1736;
  Expr _e1737;
  Expr _e1738;
  Expr _e1739;
  Expr _e1740;
  Expr _e1741;
  Expr _e1742;
  Expr _e1743;
  Expr _e1744;
  Expr _e1745;
  Expr _e1746;
  Expr _e1747;
  Expr _e1748;
  Expr _e1749;
  Expr _e1750;
  Expr _e1751;
  Expr _e1752;
  Expr _e1753;
  Expr _e1754;
  Expr _e1755;
  Expr _e1756;
  Expr _e1757;
  Expr _e1758;
  Expr _e1759;
  Expr _e1760;
  Expr _e1761;
  Expr _e1762;
  Expr _e1763;
  Expr _e1764;
  Expr _e1765;
  Expr _e1766;
  Expr _e1767;
  Expr _e1768;
  Expr _e1769;
  Expr _e1770;
  Expr _e1771;
  Expr _e1772;
  Expr _e1773;
  Expr _e1774;
  Expr _e1775;
  Expr _e1776;
  Expr _e1777;
  Expr _e1778;
  Expr _e1779;
  Expr _e1780;
  Expr _e1781;
  Expr _e1782;
  Expr _e1783;
  Expr _e1784;
  Expr _e1785;
  Expr _e1786;
  Expr _e1787;
  Expr _e1788;
  Expr _e1789;
  Expr _e1790;
  Expr _e1791;
  Expr _e1792;
  Expr _e1793;
  Expr _e1794;
  Expr _e1795;
  Expr _e1796;
  Expr _e1797;
  Expr _e1798;
  Expr _e1799;
  Expr _e1800;
  Expr _e1801;
  Expr _e1802;
  Expr _e1803;
  Expr _e1804;
  Expr _e1805;
  Expr _e1806;
  Expr _e1807;
  Expr _e1808;
  Expr _e1809;
  Expr _e1810;
  Expr _e1811;
  Expr _e1812;
  Expr _e1813;
  Expr _e1814;
  Expr _e1815;
  Expr _e1816;
  Expr _e1817;
  Expr _e1818;
  Expr _e1819;
  Expr _e1820;
  Expr _e1821;
  Expr _e1822;
  Expr _e1823;
  Expr _e1824;
  Expr _e1825;
  Expr _e1826;
  Expr _e1827;
  Expr _e1828;
  Expr _e1829;
  Expr _e1830;
  Expr _e1831;
  Expr _e1832;
  Expr _e1833;
  Expr _e1834;
  Expr _e1835;
  Expr _e1836;
  Expr _e1837;
  Expr _e1838;
  Expr _e1839;
  Expr _e1840;
  Expr _e1841;
  Expr _e1842;
  Expr _e1843;
  Expr _e1844;
  Expr _e1845;
  Expr _e1846;
  Expr _e1847;
  Expr _e1848;
  Expr _e1849;
  Expr _e1850;
  Expr _e1851;
  Expr _e1852;
  Expr _e1853;
  Expr _e1854;
  Expr _e1855;
  Expr _e1856;
  Expr _e1857;
  Expr _e1858;
  Expr _e1859;
  Expr _e1860;
  Expr _e1861;
  Expr _e1862;
  Expr _e1863;
  Expr _e1864;
  Expr _e1865;
  Expr _e1866;
  Expr _e1867;
  Expr _e1868;
  Expr _e1869;
  Expr _e1870;
  Expr _e1871;
  Expr _e1872;
  Expr _e1873;
  Expr _e1874;
  Expr _e1875;
  Expr _e1876;
  Expr _e1877;
  Expr _e1878;
  Expr _e1879;
  Expr _e1880;
  Expr _e1881;
  Expr _e1882;
  Expr _e1883;
  Expr _e1884;
  Expr _e1885;
  Expr _e1886;
  Expr _e1887;
  Expr _e1888;
  Expr _e1889;
  Expr _e1890;
  Expr _e1891;
  Expr _e1892;
  Expr _e1893;
  Expr _e1894;
  Expr _e1895;
  Expr _e1896;
  Expr _e1897;
  Expr _e1898;
  Expr _e1899;
  Expr _e1900;
  Expr _e1901;
  Expr _e1902;
  Expr _e1903;
  Expr _e1904;
  Expr _e1905;
  Expr _e1906;
  Expr _e1907;
  Expr _e1908;
  Expr _e1909;
  Expr _e1910;
  Expr _e1911;
  Expr _e1912;
  Expr _e1913;
  Expr _e1914;
  Expr _e1915;
  Expr _e1916;
  Expr _e1917;
  Expr _e1918;
  Expr _e1919;
  Expr _e1920;
  Expr _e1921;
  Expr _e1922;
  Expr _e1923;
  Expr _e1924;
  Expr _e1925;
  Expr _e1926;
  Expr _e1927;
  Expr _e1928;
  Expr _e1929;
  Expr _e1930;
  Expr _e1931;
  Expr _e1932;
  Expr _e1933;
  Expr _e1934;
  Expr _e1935;
  Expr _e1936;
  Expr _e1937;
  Expr _e1938;
  Expr _e1939;
  Expr _e1940;
  Expr _e1941;
  Expr _e1942;
  Expr _e1943;
  Expr _e1944;
  Expr _e1945;
  Expr _e1946;
  Expr _e1947;
  Expr _e1948;
  Expr _e1949;
  Expr _e1950;
  Expr _e1951;
  Expr _e1952;
  Expr _e1953;
  Expr _e1954;
  Expr _e1955;
  Expr _e1956;
  Expr _e1957;
  Expr _e1958;
  Expr _e1959;
  Expr _e1960;
  Expr _e1961;
  Expr _e1962;
  Expr _e1963;
  Expr _e1964;
  Expr _e1965;
  Expr _e1966;
  Expr _e1967;
  Expr _e1968;
  Expr _e1969;
  Expr _e1970;
  Expr _e1971;
  Expr _e1972;
  Expr _e1973;
  Expr _e1974;
  Expr _e1975;
  Expr _e1976;
  Expr _e1977;
  Expr _e1978;
  Expr _e1979;
  Expr _e1980;
  Expr _e1981;
  Expr _e1982;
  Expr _e1983;
  Expr _e1984;
  Expr _e1985;
  Expr _e1986;
  Expr _e1987;
  Expr _e1988;
  Expr _e1989;
  Expr _e1990;
  Expr _e1991;
  Expr _e1992;
  Expr _e1993;
  Expr _e1994;
  Expr _e1995;
  Expr _e1996;
  Expr _e1997;
  Expr _e1998;
  Expr _e1999;
  Expr _e2000;
  Expr _e2001;
  Expr _e2002;
  Expr _e2003;
  Expr _e2004;
  Expr _e2005;
  Expr _e2006;
  Expr _e2007;
  Expr _e2008;
  Expr _e2009;
  Expr _e2010;
  Expr _e2011;
  Expr _e2012;
  Expr _e2013;
  Expr _e2014;
  Expr _e2015;
  Expr _e2016;
  Expr _e2017;
  Expr _e2018;
  Expr _e2019;
  Expr _e2020;
  Expr _e2021;
  Expr _e2022;
  Expr _e2023;
  Expr _e2024;
  Expr _e2025;
  Expr _e2026;
  Expr _e2027;
  Expr _e2028;
  Expr _e2029;
  Expr _e2030;
  Expr _e2031;
  Expr _e2032;
  Expr _e2033;
  Expr _e2034;
  Expr _e2035;
  Expr _e2036;
  Expr _e2037;
  Expr _e2038;
  Expr _e2039;
  Expr _e2040;
  Expr _e2041;
  Expr _e2042;
  Expr _e2043;
  Expr _e2044;
  Expr _e2045;
  Expr _e2046;
  Expr _e2047;
  Expr _e2048;
  Expr _e2049;
  Expr _e2050;
  Expr _e2051;
  Expr _e2052;
  Expr _e2053;
  Expr _e2054;
  Expr _e2055;
  Expr _e2056;
  Expr _e2057;
  Expr _e2058;
  Expr _e2059;
  Expr _e2060;
  Expr _e2061;
  Expr _e2062;
  Expr _e2063;
  Expr _e2064;
  Expr _e2065;
  Expr _e2066;
  Expr _e2067;
  Expr _e2068;
  Expr _e2069;
  Expr _e2070;
  Expr _e2071;
  Expr _e2072;
  Expr _e2073;
  Expr _e2074;
  Expr _e2075;
  Expr _e2076;
  Expr _e2077;
  Expr _e2078;
  Expr _e2079;
  Expr _e2080;
  Expr _e2081;
  Expr _e2082;
  Expr _e2083;
  Expr _e2084;
  Expr _e2085;
  Expr _e2086;
  Expr _e2087;
  Expr _e2088;
  Expr _e2089;
  Expr _e2090;
  Expr _e2091;
  Expr _e2092;
  Expr _e2093;
  Expr _e2094;
  Expr _e2095;
  Expr _e2096;
  Expr _e2097;
  Expr _e2098;
  Expr _e2099;
  Expr _e2100;
  Expr _e2101;
  Expr _e2102;
  Expr _e2103;
  Expr _e2104;
  Expr _e2105;
  Expr _e2106;
  Expr _e2107;
  Expr _e2108;
  Expr _e2109;
  Expr _e2110;
  Expr _e2111;
  Expr _e2112;
  Expr _e2113;
  Expr _e2114;
  Expr _e2115;
  Expr _e2116;
  Expr _e2117;
  Expr _e2118;
  Expr _e2119;
  Expr _e2120;
  Expr _e2121;
  Expr _e2122;
  Expr _e2123;
  Expr _e2124;
  Expr _e2125;
  Expr _e2126;
  Expr _e2127;
  Expr _e2128;
  Expr _e2129;
  Expr _e2130;
  Expr _e2131;
  Expr _e2132;
  Expr _e2133;
  Expr _e2134;
  Expr _e2135;
  Expr _e2136;
  Expr _e2137;
  Expr _e2138;
  Expr _e2139;
  Expr _e2140;
  Expr _e2141;
  Expr _e2142;
  Expr _e2143;
  Expr _e2144;
  Expr _e2145;
  Expr _e2146;
  Expr _e2147;
  Expr _e2148;
  Expr _e2149;
  Expr _e2150;
  Expr _e2151;
  Expr _e2152;
  Expr _e2153;
  Expr _e2154;
  Expr _e2155;
  Expr _e2156;
  Expr _e2157;
  Expr _e2158;
  Expr _e2159;
  Expr _e2160;
  Expr _e2161;
  Expr _e2162;
  Expr _e2163;
  Expr _e2164;
  Expr _e2165;
  Expr _e2166;
  Expr _e2167;
  Expr _e2168;
  Expr _e2169;
  Expr _e2170;
  Expr _e2171;
  Expr _e2172;
  Expr _e2173;
  Expr _e2174;
  Expr _e2175;
  Expr _e2176;
  Expr _e2177;
  Expr _e2178;
  Expr _e2179;
  Expr _e2180;
  Expr _e2181;
  Expr _e2182;
  Expr _e2183;
  Expr _e2184;
  Expr _e2185;
  Expr _e2186;
  Expr _e2187;
  Expr _e2188;
  Expr _e2189;
  Expr _e2190;
  Expr _e2191;
  Expr _e2192;
  Expr _e2193;
  Expr _e2194;
  Expr _e2195;
  Expr _e2196;
  Expr _e2197;
  Expr _e2198;
  Expr _e2199;
  Expr _e2200;
  Expr _e2201;
  Expr _e2202;
  Expr _e2203;
  Expr _e2204;
  Expr _e2205;
  Expr _e2206;
  Expr _e2207;
  Expr _e2208;
  Expr _e2209;
  Expr _e2210;
  Expr _e2211;
  Expr _e2212;
  Expr _e2213;
  Expr _e2214;
  Expr _e2215;
  Expr _e2216;
  Expr _e2217;
  Expr _e2218;
  Expr _e2219;
  Expr _e2220;
  Expr _e2221;
  Expr _e2222;
  Expr _e2223;
  Expr _e2224;
  Expr _e2225;
  Expr _e2226;
  Expr _e2227;
  Expr _e2228;
  Expr _e2229;
  Expr _e2230;
  Expr _e2231;
  Expr _e2232;
  Expr _e2233;
  Expr _e2234;
  Expr _e2235;
  Expr _e2236;
  Expr _e2237;
  Expr _e2238;
  Expr _e2239;
  Expr _e2240;
  Expr _e2241;
  Expr _e2242;
  Expr _e2243;

void State::run_initialize()
{
  markIncluded("/home/andrew/alfc/proofs/rules/Cvc5.smt2");
  markIncluded("/home/andrew/alfc/proofs/rules/Builtin.smt2");
  markIncluded("/home/andrew/alfc/proofs/theories/Core.smt2");
  markIncluded("/home/andrew/alfc/proofs/programs/Utils.smt2");
  _e2 = d_type;
  _e3 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2, _e2});
  _e4 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2, _e3});
  _e1 = mkSymbolInternal(Kind::CONST, "Pair", _e4);
  bind("Pair", _e1);
  _runId[_e4.get()] = 4;
  _e4->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e3.get()] = 3;
  _e3->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e6 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e7 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e8 = mkExprInternal(Kind::APPLY, {_e1, _e7});
  _e8->d_type = _e3;
  _e9 = mkExprInternal(Kind::APPLY, {_e8, _e6});
  _e9->d_type = _e2;
  _e10 = mkExprInternal(Kind::FUNCTION_TYPE, {_e6, _e9});
  _e10->d_type = _e2;
  _e11 = mkExprInternal(Kind::FUNCTION_TYPE, {_e7, _e10});
  _e11->d_type = _e2;
  _e5 = mkSymbolInternal(Kind::CONST, "pair", _e11);
  bind("pair", _e5);
  _runId[_e11.get()] = 11;
  _e11->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e5, _amap);
  _e13 = d_boolType;
  _e14 = mkSymbolInternal(Kind::PARAM, "R", _e2);
  _e15 = mkExprInternal(Kind::FUNCTION_TYPE, {_e14, _e13});
  _e12 = mkSymbolInternal(Kind::PROGRAM_CONST, "between_zero_and_one", _e15);
  _runId[_e12.get()] = 12;
  _e12->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e16 = mkLiteral(Kind::DECIMAL, "-1");
  _e17 = mkSymbolInternal(Kind::PARAM, "c", _e14);
  _e18 = mkExprInternal(Kind::EVAL_ADD, {_e17, _e16});
  _e19 = mkExprInternal(Kind::EVAL_IS_NEG, {_e18});
  _e20 = mkExprInternal(Kind::EVAL_IS_NEG, {_e17});
  _e21 = mkExprInternal(Kind::EVAL_NOT, {_e20});
  _e22 = mkExprInternal(Kind::EVAL_AND, {_e21, _e19});
  _runId[_e22.get()] = 22;
  _e22->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("between_zero_and_one", _e12);
  _runId[_e15.get()] = 15;
  _e15->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e24 = mkExprInternal(Kind::FUNCTION_TYPE, {_e13, _e13});
  _e23 = mkSymbolInternal(Kind::PROGRAM_CONST, "check_true", _e24);
  _runId[_e23.get()] = 23;
  _e23->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e25 = mkLiteral(Kind::BOOLEAN, "true");
  _e26 = mkLiteral(Kind::BOOLEAN, "false");
  bind("check_true", _e23);
  _runId[_e24.get()] = 24;
  _e24->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e28 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e29 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e30 = mkExprInternal(Kind::FUNCTION_TYPE, {_e28, _e29, _e28});
  _e27 = mkSymbolInternal(Kind::PROGRAM_CONST, "maybe_nil", _e30);
  _runId[_e27.get()] = 27;
  _e27->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e31 = mkSymbolInternal(Kind::PARAM, "t", _e28);
  _e32 = mkNil();
  bind("maybe_nil", _e27);
  _runId[_e30.get()] = 30;
  _e30->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e34 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e35 = mkExprInternal(Kind::FUNCTION_TYPE, {_e34, _e34});
  _e35->d_type = _e2;
  _e36 = mkExprInternal(Kind::FUNCTION_TYPE, {_e34, _e35});
  _e36->d_type = _e2;
  _e37 = mkExprInternal(Kind::FUNCTION_TYPE, {_e13, _e36});
  _e37->d_type = _e2;
  _e33 = mkSymbolInternal(Kind::CONST, "ite", _e37);
  bind("ite", _e33);
  _runId[_e37.get()] = 37;
  _e37->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e36.get()] = 36;
  _e36->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e33, _amap);
  _e38 = mkSymbolInternal(Kind::CONST, "not", _e24);
  bind("not", _e38);
  _amap.clear();
  markAttributes(_e38, _amap);
  _e40 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e41 = mkExprInternal(Kind::APPLY, {_e27, _e13, _e40});
  _e41->d_type = _e2;
  _e42 = mkExprInternal(Kind::FUNCTION_TYPE, {_e40, _e41});
  _e42->d_type = _e2;
  _e43 = mkExprInternal(Kind::FUNCTION_TYPE, {_e13, _e42});
  _e43->d_type = _e2;
  _e39 = mkSymbolInternal(Kind::CONST, "or", _e43);
  bind("or", _e39);
  _runId[_e43.get()] = 43;
  _e43->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e42.get()] = 42;
  _e42->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC_NIL].push_back(nullptr);
  markAttributes(_e39, _amap);
  _e45 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e46 = mkExprInternal(Kind::APPLY, {_e27, _e13, _e45});
  _e46->d_type = _e2;
  _e47 = mkExprInternal(Kind::FUNCTION_TYPE, {_e45, _e46});
  _e47->d_type = _e2;
  _e48 = mkExprInternal(Kind::FUNCTION_TYPE, {_e13, _e47});
  _e48->d_type = _e2;
  _e44 = mkSymbolInternal(Kind::CONST, "and", _e48);
  bind("and", _e44);
  _runId[_e48.get()] = 48;
  _e48->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e47.get()] = 47;
  _e47->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC_NIL].push_back(nullptr);
  markAttributes(_e44, _amap);
  _e50 = mkExprInternal(Kind::FUNCTION_TYPE, {_e13, _e24});
  _e50->d_type = _e2;
  _e49 = mkSymbolInternal(Kind::CONST, "=>", _e50);
  bind("=>", _e49);
  _runId[_e50.get()] = 50;
  _e50->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC].push_back(nullptr);
  markAttributes(_e49, _amap);
  _e51 = mkSymbolInternal(Kind::CONST, "xor", _e50);
  bind("xor", _e51);
  _amap.clear();
  _amap[Attr::LEFT_ASSOC].push_back(nullptr);
  markAttributes(_e51, _amap);
  _e53 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e54 = mkExprInternal(Kind::FUNCTION_TYPE, {_e53, _e13});
  _e54->d_type = _e2;
  _e55 = mkExprInternal(Kind::FUNCTION_TYPE, {_e53, _e54});
  _e55->d_type = _e2;
  _e52 = mkSymbolInternal(Kind::CONST, "=", _e55);
  bind("=", _e52);
  _runId[_e55.get()] = 55;
  _e55->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::CHAINABLE].push_back(_e44);
  markAttributes(_e52, _amap);
  _e57 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e58 = mkExprInternal(Kind::FUNCTION_TYPE, {_e57, _e13});
  _e58->d_type = _e2;
  _e56 = mkSymbolInternal(Kind::CONST, "forall", _e58);
  bind("forall", _e56);
  _runId[_e58.get()] = 58;
  _e58->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e56, _amap);
  _e60 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e61 = mkExprInternal(Kind::FUNCTION_TYPE, {_e60, _e13});
  _e61->d_type = _e2;
  _e59 = mkSymbolInternal(Kind::CONST, "exists", _e61);
  bind("exists", _e59);
  _runId[_e61.get()] = 61;
  _e61->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e59, _amap);
  _e63 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e64 = mkExprInternal(Kind::FUNCTION_TYPE, {_e63, _e13});
  _e64->d_type = _e2;
  _e65 = mkExprInternal(Kind::FUNCTION_TYPE, {_e63, _e64});
  _e65->d_type = _e2;
  _e62 = mkSymbolInternal(Kind::CONST, "distinct", _e65);
  bind("distinct", _e62);
  _runId[_e65.get()] = 65;
  _e65->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::PAIRWISE].push_back(_e44);
  markAttributes(_e62, _amap);
  markIncluded("/home/andrew/alfc/proofs/theories/Builtin.smt2");
  _e67 = mkSymbolInternal(Kind::PARAM, "A", _e2);
  _e68 = mkExprInternal(Kind::FUNCTION_TYPE, {_e67, _e67});
  _e68->d_type = _e2;
  _e66 = mkSymbolInternal(Kind::CONST, "skolem", _e68);
  bind("skolem", _e66);
  _runId[_e68.get()] = 68;
  _e68->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e66, _amap);
  _e69 = mkSymbolInternal(Kind::CONST, "Theory", _e2);
  bind("Theory", _e69);
  _e70 = mkSymbolInternal(Kind::CONST, "THEORY_BUILTIN", _e69);
  bind("THEORY_BUILTIN", _e70);
  _amap.clear();
  markAttributes(_e70, _amap);
  _e71 = mkSymbolInternal(Kind::CONST, "THEORY_BOOL", _e69);
  bind("THEORY_BOOL", _e71);
  _amap.clear();
  markAttributes(_e71, _amap);
  _e72 = mkSymbolInternal(Kind::CONST, "THEORY_UF", _e69);
  bind("THEORY_UF", _e72);
  _amap.clear();
  markAttributes(_e72, _amap);
  _e73 = mkSymbolInternal(Kind::CONST, "THEORY_ARITH", _e69);
  bind("THEORY_ARITH", _e73);
  _amap.clear();
  markAttributes(_e73, _amap);
  _e74 = mkSymbolInternal(Kind::CONST, "THEORY_BV", _e69);
  bind("THEORY_BV", _e74);
  _amap.clear();
  markAttributes(_e74, _amap);
  _e75 = mkSymbolInternal(Kind::CONST, "THEORY_FF", _e69);
  bind("THEORY_FF", _e75);
  _amap.clear();
  markAttributes(_e75, _amap);
  _e76 = mkSymbolInternal(Kind::CONST, "THEORY_FP", _e69);
  bind("THEORY_FP", _e76);
  _amap.clear();
  markAttributes(_e76, _amap);
  _e77 = mkSymbolInternal(Kind::CONST, "THEORY_ARRAYS", _e69);
  bind("THEORY_ARRAYS", _e77);
  _amap.clear();
  markAttributes(_e77, _amap);
  _e78 = mkSymbolInternal(Kind::CONST, "THEORY_DATATYPES", _e69);
  bind("THEORY_DATATYPES", _e78);
  _amap.clear();
  markAttributes(_e78, _amap);
  _e79 = mkSymbolInternal(Kind::CONST, "THEORY_SEP", _e69);
  bind("THEORY_SEP", _e79);
  _amap.clear();
  markAttributes(_e79, _amap);
  _e80 = mkSymbolInternal(Kind::CONST, "THEORY_SETS", _e69);
  bind("THEORY_SETS", _e80);
  _amap.clear();
  markAttributes(_e80, _amap);
  _e81 = mkSymbolInternal(Kind::CONST, "THEORY_BAGS", _e69);
  bind("THEORY_BAGS", _e81);
  _amap.clear();
  markAttributes(_e81, _amap);
  _e82 = mkSymbolInternal(Kind::CONST, "THEORY_STRINGS", _e69);
  bind("THEORY_STRINGS", _e82);
  _amap.clear();
  markAttributes(_e82, _amap);
  _e83 = mkSymbolInternal(Kind::CONST, "THEORY_QUANTIFIERS", _e69);
  bind("THEORY_QUANTIFIERS", _e83);
  _amap.clear();
  markAttributes(_e83, _amap);
  _e84 = mkSymbolInternal(Kind::CONST, "Method", _e2);
  bind("Method", _e84);
  _e85 = mkSymbolInternal(Kind::CONST, "RW_REWRITE", _e84);
  bind("RW_REWRITE", _e85);
  _amap.clear();
  markAttributes(_e85, _amap);
  _e86 = mkSymbolInternal(Kind::CONST, "RW_EXT_REWRITE", _e84);
  bind("RW_EXT_REWRITE", _e86);
  _amap.clear();
  markAttributes(_e86, _amap);
  _e87 = mkSymbolInternal(Kind::CONST, "RW_REWRITE_EQ_EXT", _e84);
  bind("RW_REWRITE_EQ_EXT", _e87);
  _amap.clear();
  markAttributes(_e87, _amap);
  _e88 = mkSymbolInternal(Kind::CONST, "RW_EVALUATE", _e84);
  bind("RW_EVALUATE", _e88);
  _amap.clear();
  markAttributes(_e88, _amap);
  _e89 = mkSymbolInternal(Kind::CONST, "RW_REWRITE_THEORY_PRE", _e84);
  bind("RW_REWRITE_THEORY_PRE", _e89);
  _amap.clear();
  markAttributes(_e89, _amap);
  _e90 = mkSymbolInternal(Kind::CONST, "RW_REWRITE_THEORY_POST", _e84);
  bind("RW_REWRITE_THEORY_POST", _e90);
  _amap.clear();
  markAttributes(_e90, _amap);
  _e91 = mkSymbolInternal(Kind::CONST, "SB_DEFAULT", _e84);
  bind("SB_DEFAULT", _e91);
  _amap.clear();
  markAttributes(_e91, _amap);
  _e92 = mkSymbolInternal(Kind::CONST, "SB_LITERAL", _e84);
  bind("SB_LITERAL", _e92);
  _amap.clear();
  markAttributes(_e92, _amap);
  _e93 = mkSymbolInternal(Kind::CONST, "SB_FORMULA", _e84);
  bind("SB_FORMULA", _e93);
  _amap.clear();
  markAttributes(_e93, _amap);
  _e94 = mkSymbolInternal(Kind::CONST, "SBA_SEQUENTIAL", _e84);
  bind("SBA_SEQUENTIAL", _e94);
  _amap.clear();
  markAttributes(_e94, _amap);
  _e95 = mkSymbolInternal(Kind::CONST, "SBA_SIMUL", _e84);
  bind("SBA_SIMUL", _e95);
  _amap.clear();
  markAttributes(_e95, _amap);
  _e96 = mkSymbolInternal(Kind::CONST, "SBA_FIXPOINT", _e84);
  bind("SBA_FIXPOINT", _e96);
  _amap.clear();
  markAttributes(_e96, _amap);
  _e99 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e98 = mkSymbolInternal(Kind::PARAM, "F", _e99);
  _e100 = mkExprInternal(Kind::PROOF_TYPE, {_e98});
  _e101 = mkSymbolInternal(Kind::PARAM, "method", _e84);
  _e102 = mkExprInternal(Kind::QUOTE_TYPE, {_e101});
  _e103 = mkSymbolInternal(Kind::PARAM, "theory", _e69);
  _e104 = mkExprInternal(Kind::QUOTE_TYPE, {_e103});
  _e105 = mkExprInternal(Kind::QUOTE_TYPE, {_e98});
  _e106 = mkExprInternal(Kind::FUNCTION_TYPE, {_e105, _e104, _e102, _e100});
  _e97 = mkSymbolInternal(Kind::PROOF_RULE, "theory_rewrite", _e106);
  bind("theory_rewrite", _e97);
  _runId[_e106.get()] = 106;
  _e106->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e109 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e108 = mkSymbolInternal(Kind::PARAM, "t", _e109);
  _e110 = mkExprInternal(Kind::APPLY, {_e66, _e108});
  _e111 = mkExprInternal(Kind::APPLY, {_e52, _e110});
  _e112 = mkExprInternal(Kind::APPLY, {_e111, _e108});
  _e113 = mkExprInternal(Kind::PROOF_TYPE, {_e112});
  _e114 = mkExprInternal(Kind::QUOTE_TYPE, {_e110});
  _e115 = mkExprInternal(Kind::FUNCTION_TYPE, {_e114, _e113});
  _e107 = mkSymbolInternal(Kind::PROOF_RULE, "skolem_intro", _e115);
  bind("skolem_intro", _e107);
  _runId[_e115.get()] = 115;
  _e115->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e117 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e118 = mkExprInternal(Kind::PROOF_TYPE, {_e117});
  _e119 = mkExprInternal(Kind::QUOTE_TYPE, {_e117});
  _e120 = mkExprInternal(Kind::FUNCTION_TYPE, {_e119, _e118});
  _e116 = mkSymbolInternal(Kind::PROOF_RULE, "trust", _e120);
  bind("trust", _e116);
  _runId[_e120.get()] = 120;
  _e120->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e122 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e123 = mkExprInternal(Kind::PROOF_TYPE, {_e122});
  _e124 = mkExprInternal(Kind::FUNCTION_TYPE, {_e123, _e123});
  _e121 = mkSymbolInternal(Kind::PROOF_RULE, "identity", _e124);
  bind("identity", _e121);
  _runId[_e124.get()] = 124;
  _e124->setFlag(ExprValue::Flag::IS_COMPILED, true);
  markIncluded("/home/andrew/alfc/proofs/rules/Booleans.smt2");
  markIncluded("/home/andrew/alfc/proofs/theories/Ints.smt2");
  markIncluded("/home/andrew/alfc/proofs/theories/Arith.smt2");
  _e125 = mkSymbolInternal(Kind::CONST, "Int", _e2);
  bind("Int", _e125);
  _e126 = mkSymbolInternal(Kind::CONST, "Real", _e2);
  bind("Real", _e126);
  d_tc.setLiteralTypeRule(Kind::NUMERAL, _e125);
  d_tc.setLiteralTypeRule(Kind::DECIMAL, _e126);
  _e128 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2, _e2, _e2});
  _e127 = mkSymbolInternal(Kind::PROGRAM_CONST, "arith_typeunion_nary", _e128);
  _runId[_e127.get()] = 127;
  _e127->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("arith_typeunion_nary", _e127);
  _runId[_e128.get()] = 128;
  _e128->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e129 = mkSymbolInternal(Kind::PROGRAM_CONST, "arith_typeunion", _e128);
  _runId[_e129.get()] = 129;
  _e129->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("arith_typeunion", _e129);
  _e131 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2, _e13});
  _e130 = mkSymbolInternal(Kind::PROGRAM_CONST, "is_arith_type", _e131);
  _runId[_e130.get()] = 130;
  _e130->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("is_arith_type", _e130);
  _runId[_e131.get()] = 131;
  _e131->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e133 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e134 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e135 = mkExprInternal(Kind::APPLY, {_e127, _e134, _e133});
  _e135->d_type = _e2;
  _e136 = mkExprInternal(Kind::FUNCTION_TYPE, {_e133, _e135});
  _e136->d_type = _e2;
  _e137 = mkExprInternal(Kind::FUNCTION_TYPE, {_e134, _e136});
  _e137->d_type = _e2;
  _e132 = mkSymbolInternal(Kind::CONST, "+", _e137);
  bind("+", _e132);
  _runId[_e137.get()] = 137;
  _e137->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC_NIL].push_back(nullptr);
  markAttributes(_e132, _amap);
  _e139 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e140 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e141 = mkExprInternal(Kind::APPLY, {_e129, _e140, _e139});
  _e141->d_type = _e2;
  _e142 = mkExprInternal(Kind::FUNCTION_TYPE, {_e139, _e141});
  _e142->d_type = _e2;
  _e143 = mkExprInternal(Kind::FUNCTION_TYPE, {_e140, _e142});
  _e143->d_type = _e2;
  _e138 = mkSymbolInternal(Kind::CONST, "-", _e143);
  bind("-", _e138);
  _runId[_e143.get()] = 143;
  _e143->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::LEFT_ASSOC].push_back(nullptr);
  markAttributes(_e138, _amap);
  _e145 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e146 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e147 = mkExprInternal(Kind::APPLY, {_e127, _e146, _e145});
  _e147->d_type = _e2;
  _e148 = mkExprInternal(Kind::FUNCTION_TYPE, {_e145, _e147});
  _e148->d_type = _e2;
  _e149 = mkExprInternal(Kind::FUNCTION_TYPE, {_e146, _e148});
  _e149->d_type = _e2;
  _e144 = mkSymbolInternal(Kind::CONST, "*", _e149);
  bind("*", _e144);
  _runId[_e149.get()] = 149;
  _e149->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC_NIL].push_back(nullptr);
  markAttributes(_e144, _amap);
  _e151 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e152 = mkExprInternal(Kind::APPLY, {_e130, _e151});
  _e152->d_type = _e13;
  _e154 = mkExprInternal(Kind::ABSTRACT_TYPE, {});
  _e153 = mkExprInternal(Kind::PAIR, {_e152, _e25});
  _e153->d_type = _e154;
  _e155 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e156 = mkExprInternal(Kind::APPLY, {_e130, _e155});
  _e156->d_type = _e13;
  _e157 = mkExprInternal(Kind::PAIR, {_e156, _e25});
  _e157->d_type = _e154;
  _e158 = mkExprInternal(Kind::REQUIRES_TYPE, {_e157, _e153, _e13});
  _e158->d_type = _e2;
  _e159 = mkExprInternal(Kind::FUNCTION_TYPE, {_e151, _e158});
  _e159->d_type = _e2;
  _e160 = mkExprInternal(Kind::FUNCTION_TYPE, {_e155, _e159});
  _e160->d_type = _e2;
  _e150 = mkSymbolInternal(Kind::CONST, "<", _e160);
  bind("<", _e150);
  _runId[_e160.get()] = 160;
  _e160->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::CHAINABLE].push_back(_e44);
  markAttributes(_e150, _amap);
  _e162 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e163 = mkExprInternal(Kind::APPLY, {_e130, _e162});
  _e163->d_type = _e13;
  _e164 = mkExprInternal(Kind::PAIR, {_e163, _e25});
  _e164->d_type = _e154;
  _e165 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e166 = mkExprInternal(Kind::APPLY, {_e130, _e165});
  _e166->d_type = _e13;
  _e167 = mkExprInternal(Kind::PAIR, {_e166, _e25});
  _e167->d_type = _e154;
  _e168 = mkExprInternal(Kind::REQUIRES_TYPE, {_e167, _e164, _e13});
  _e168->d_type = _e2;
  _e169 = mkExprInternal(Kind::FUNCTION_TYPE, {_e162, _e168});
  _e169->d_type = _e2;
  _e170 = mkExprInternal(Kind::FUNCTION_TYPE, {_e165, _e169});
  _e170->d_type = _e2;
  _e161 = mkSymbolInternal(Kind::CONST, "<=", _e170);
  bind("<=", _e161);
  _runId[_e170.get()] = 170;
  _e170->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::CHAINABLE].push_back(_e44);
  markAttributes(_e161, _amap);
  _e172 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e173 = mkExprInternal(Kind::APPLY, {_e130, _e172});
  _e173->d_type = _e13;
  _e174 = mkExprInternal(Kind::PAIR, {_e173, _e25});
  _e174->d_type = _e154;
  _e175 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e176 = mkExprInternal(Kind::APPLY, {_e130, _e175});
  _e176->d_type = _e13;
  _e177 = mkExprInternal(Kind::PAIR, {_e176, _e25});
  _e177->d_type = _e154;
  _e178 = mkExprInternal(Kind::REQUIRES_TYPE, {_e177, _e174, _e13});
  _e178->d_type = _e2;
  _e179 = mkExprInternal(Kind::FUNCTION_TYPE, {_e172, _e178});
  _e179->d_type = _e2;
  _e180 = mkExprInternal(Kind::FUNCTION_TYPE, {_e175, _e179});
  _e180->d_type = _e2;
  _e171 = mkSymbolInternal(Kind::CONST, ">", _e180);
  bind(">", _e171);
  _runId[_e180.get()] = 180;
  _e180->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::CHAINABLE].push_back(_e44);
  markAttributes(_e171, _amap);
  _e182 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e183 = mkExprInternal(Kind::APPLY, {_e130, _e182});
  _e183->d_type = _e13;
  _e184 = mkExprInternal(Kind::PAIR, {_e183, _e25});
  _e184->d_type = _e154;
  _e185 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e186 = mkExprInternal(Kind::APPLY, {_e130, _e185});
  _e186->d_type = _e13;
  _e187 = mkExprInternal(Kind::PAIR, {_e186, _e25});
  _e187->d_type = _e154;
  _e188 = mkExprInternal(Kind::REQUIRES_TYPE, {_e187, _e184, _e13});
  _e188->d_type = _e2;
  _e189 = mkExprInternal(Kind::FUNCTION_TYPE, {_e182, _e188});
  _e189->d_type = _e2;
  _e190 = mkExprInternal(Kind::FUNCTION_TYPE, {_e185, _e189});
  _e190->d_type = _e2;
  _e181 = mkSymbolInternal(Kind::CONST, ">=", _e190);
  bind(">=", _e181);
  _runId[_e190.get()] = 190;
  _e190->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::CHAINABLE].push_back(_e44);
  markAttributes(_e181, _amap);
  _e192 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e193 = mkExprInternal(Kind::APPLY, {_e130, _e192});
  _e193->d_type = _e13;
  _e194 = mkExprInternal(Kind::PAIR, {_e193, _e25});
  _e194->d_type = _e154;
  _e195 = mkExprInternal(Kind::REQUIRES_TYPE, {_e194, _e126});
  _e195->d_type = _e2;
  _e196 = mkExprInternal(Kind::FUNCTION_TYPE, {_e192, _e195});
  _e196->d_type = _e2;
  _e191 = mkSymbolInternal(Kind::CONST, "to_real", _e196);
  bind("to_real", _e191);
  _runId[_e196.get()] = 196;
  _e196->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e191, _amap);
  _e198 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e199 = mkExprInternal(Kind::APPLY, {_e130, _e198});
  _e199->d_type = _e13;
  _e200 = mkExprInternal(Kind::PAIR, {_e199, _e25});
  _e200->d_type = _e154;
  _e201 = mkExprInternal(Kind::REQUIRES_TYPE, {_e200, _e125});
  _e201->d_type = _e2;
  _e202 = mkExprInternal(Kind::FUNCTION_TYPE, {_e198, _e201});
  _e202->d_type = _e2;
  _e197 = mkSymbolInternal(Kind::CONST, "to_int", _e202);
  bind("to_int", _e197);
  _runId[_e202.get()] = 202;
  _e202->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e197, _amap);
  _e204 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e205 = mkExprInternal(Kind::APPLY, {_e130, _e204});
  _e205->d_type = _e13;
  _e206 = mkExprInternal(Kind::PAIR, {_e205, _e25});
  _e206->d_type = _e154;
  _e207 = mkExprInternal(Kind::REQUIRES_TYPE, {_e206, _e13});
  _e207->d_type = _e2;
  _e208 = mkExprInternal(Kind::FUNCTION_TYPE, {_e204, _e207});
  _e208->d_type = _e2;
  _e203 = mkSymbolInternal(Kind::CONST, "is_int", _e208);
  bind("is_int", _e203);
  _runId[_e208.get()] = 208;
  _e208->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e203, _amap);
  _e210 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e211 = mkExprInternal(Kind::APPLY, {_e130, _e210});
  _e211->d_type = _e13;
  _e212 = mkExprInternal(Kind::PAIR, {_e211, _e25});
  _e212->d_type = _e154;
  _e213 = mkExprInternal(Kind::REQUIRES_TYPE, {_e212, _e210});
  _e213->d_type = _e2;
  _e214 = mkExprInternal(Kind::FUNCTION_TYPE, {_e210, _e213});
  _e214->d_type = _e2;
  _e209 = mkSymbolInternal(Kind::CONST, "abs", _e214);
  bind("abs", _e209);
  _runId[_e214.get()] = 214;
  _e214->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e209, _amap);
  _e216 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e217 = mkExprInternal(Kind::APPLY, {_e130, _e216});
  _e217->d_type = _e13;
  _e218 = mkExprInternal(Kind::PAIR, {_e217, _e25});
  _e218->d_type = _e154;
  _e219 = mkExprInternal(Kind::REQUIRES_TYPE, {_e218, _e216});
  _e219->d_type = _e2;
  _e220 = mkExprInternal(Kind::FUNCTION_TYPE, {_e216, _e219});
  _e220->d_type = _e2;
  _e215 = mkSymbolInternal(Kind::CONST, "u-", _e220);
  bind("u-", _e215);
  _runId[_e220.get()] = 220;
  _e220->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e215, _amap);
  _e222 = mkExprInternal(Kind::FUNCTION_TYPE, {_e125, _e125});
  _e222->d_type = _e2;
  _e223 = mkExprInternal(Kind::FUNCTION_TYPE, {_e125, _e222});
  _e223->d_type = _e2;
  _e221 = mkSymbolInternal(Kind::CONST, "div", _e223);
  bind("div", _e221);
  _runId[_e223.get()] = 223;
  _e223->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e222.get()] = 222;
  _e222->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::LEFT_ASSOC].push_back(nullptr);
  markAttributes(_e221, _amap);
  _e224 = mkSymbolInternal(Kind::CONST, "div_total", _e223);
  bind("div_total", _e224);
  _amap.clear();
  _amap[Attr::LEFT_ASSOC].push_back(nullptr);
  markAttributes(_e224, _amap);
  _e225 = mkSymbolInternal(Kind::CONST, "mod", _e223);
  bind("mod", _e225);
  _amap.clear();
  markAttributes(_e225, _amap);
  _e226 = mkSymbolInternal(Kind::CONST, "mod_total", _e223);
  bind("mod_total", _e226);
  _amap.clear();
  markAttributes(_e226, _amap);
  _e228 = mkExprInternal(Kind::FUNCTION_TYPE, {_e125, _e13});
  _e228->d_type = _e2;
  _e229 = mkExprInternal(Kind::FUNCTION_TYPE, {_e125, _e228});
  _e229->d_type = _e2;
  _e227 = mkSymbolInternal(Kind::CONST, "divisible", _e229);
  bind("divisible", _e227);
  _runId[_e229.get()] = 229;
  _e229->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e228.get()] = 228;
  _e228->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e227, _amap);
  markIncluded("/home/andrew/alfc/proofs/programs/Nary.smt2");
  _e231 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e232 = mkExprInternal(Kind::FUNCTION_TYPE, {_e231, _e231});
  _e232->d_type = _e2;
  _e233 = mkExprInternal(Kind::FUNCTION_TYPE, {_e231, _e232});
  _e233->d_type = _e2;
  _e234 = mkExprInternal(Kind::FUNCTION_TYPE, {_e233, _e231, _e231, _e231});
  _e230 = mkSymbolInternal(Kind::PROGRAM_CONST, "nary.append", _e234);
  _runId[_e230.get()] = 230;
  _e230->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e235 = mkSymbolInternal(Kind::PARAM, "xs", _e231);
  _e236 = mkSymbolInternal(Kind::PARAM, "c", _e231);
  _e237 = mkSymbolInternal(Kind::PARAM, "cons", _e233);
  _e238 = mkExprInternal(Kind::APPLY, {_e237, _e236});
  _e239 = mkExprInternal(Kind::APPLY, {_e238, _e235});
  _runId[_e239.get()] = 239;
  _e239->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("nary.append", _e230);
  _runId[_e234.get()] = 234;
  _e234->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e241 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e242 = mkExprInternal(Kind::FUNCTION_TYPE, {_e241, _e241});
  _e242->d_type = _e2;
  _e243 = mkExprInternal(Kind::FUNCTION_TYPE, {_e241, _e242});
  _e243->d_type = _e2;
  _e244 = mkExprInternal(Kind::FUNCTION_TYPE, {_e243, _e241, _e241, _e13});
  _e240 = mkSymbolInternal(Kind::PROGRAM_CONST, "nary.ctn", _e244);
  _runId[_e240.get()] = 240;
  _e240->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e245 = mkSymbolInternal(Kind::PARAM, "xs", _e241);
  _e246 = mkSymbolInternal(Kind::PARAM, "c", _e241);
  _e247 = mkSymbolInternal(Kind::PARAM, "cons", _e243);
  _e248 = mkExprInternal(Kind::APPLY, {_e240, _e247, _e246, _e245});
  bind("nary.ctn", _e240);
  _runId[_e244.get()] = 244;
  _e244->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e250 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e251 = mkExprInternal(Kind::FUNCTION_TYPE, {_e250, _e250});
  _e251->d_type = _e2;
  _e252 = mkExprInternal(Kind::FUNCTION_TYPE, {_e250, _e251});
  _e252->d_type = _e2;
  _e253 = mkExprInternal(Kind::FUNCTION_TYPE, {_e252, _e250, _e250, _e13});
  _e249 = mkSymbolInternal(Kind::PROGRAM_CONST, "nary.is_subset", _e253);
  _runId[_e249.get()] = 249;
  _e249->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e254 = mkSymbolInternal(Kind::PARAM, "t", _e250);
  _e255 = mkSymbolInternal(Kind::PARAM, "xs", _e250);
  _e256 = mkSymbolInternal(Kind::PARAM, "cons", _e252);
  _e257 = mkExprInternal(Kind::APPLY, {_e249, _e256, _e255, _e254});
  _e258 = mkSymbolInternal(Kind::PARAM, "c", _e250);
  _e259 = mkExprInternal(Kind::APPLY, {_e240, _e256, _e258, _e254});
  _e260 = mkExprInternal(Kind::EVAL_IF_THEN_ELSE, {_e259, _e257, _e26});
  bind("nary.is_subset", _e249);
  _runId[_e253.get()] = 253;
  _e253->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e262 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e263 = mkExprInternal(Kind::FUNCTION_TYPE, {_e262, _e262});
  _e263->d_type = _e2;
  _e264 = mkExprInternal(Kind::FUNCTION_TYPE, {_e262, _e263});
  _e264->d_type = _e2;
  _e265 = mkExprInternal(Kind::FUNCTION_TYPE, {_e264, _e262, _e262, _e262});
  _e261 = mkSymbolInternal(Kind::PROGRAM_CONST, "nary.concat", _e265);
  _runId[_e261.get()] = 261;
  _e261->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e266 = mkSymbolInternal(Kind::PARAM, "ys", _e262);
  _e267 = mkSymbolInternal(Kind::PARAM, "xs", _e262);
  _e268 = mkSymbolInternal(Kind::PARAM, "cons", _e264);
  _e269 = mkExprInternal(Kind::APPLY, {_e261, _e268, _e267, _e266});
  _e270 = mkSymbolInternal(Kind::PARAM, "x", _e262);
  _e271 = mkExprInternal(Kind::APPLY, {_e230, _e268, _e270, _e269});
  bind("nary.concat", _e261);
  _runId[_e265.get()] = 265;
  _e265->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e273 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e274 = mkExprInternal(Kind::FUNCTION_TYPE, {_e273, _e273});
  _e274->d_type = _e2;
  _e275 = mkExprInternal(Kind::FUNCTION_TYPE, {_e273, _e274});
  _e275->d_type = _e2;
  _e276 = mkExprInternal(Kind::FUNCTION_TYPE, {_e275, _e273, _e273, _e273});
  _e272 = mkSymbolInternal(Kind::PROGRAM_CONST, "nary.remove", _e276);
  _runId[_e272.get()] = 272;
  _e272->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e277 = mkSymbolInternal(Kind::PARAM, "xs", _e273);
  _e278 = mkSymbolInternal(Kind::PARAM, "c", _e273);
  _e279 = mkSymbolInternal(Kind::PARAM, "cons", _e275);
  _e280 = mkExprInternal(Kind::APPLY, {_e272, _e279, _e278, _e277});
  _e281 = mkSymbolInternal(Kind::PARAM, "y", _e273);
  _e282 = mkExprInternal(Kind::APPLY, {_e230, _e279, _e281, _e280});
  bind("nary.remove", _e272);
  _runId[_e276.get()] = 276;
  _e276->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e284 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e285 = mkExprInternal(Kind::FUNCTION_TYPE, {_e284, _e284});
  _e285->d_type = _e2;
  _e286 = mkExprInternal(Kind::FUNCTION_TYPE, {_e284, _e285});
  _e286->d_type = _e2;
  _e287 = mkExprInternal(Kind::FUNCTION_TYPE, {_e286, _e284, _e284, _e284});
  _e283 = mkSymbolInternal(Kind::PROGRAM_CONST, "nary.reverseRec", _e287);
  _runId[_e283.get()] = 283;
  _e283->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e288 = mkSymbolInternal(Kind::PARAM, "l", _e284);
  _e289 = mkSymbolInternal(Kind::PARAM, "x", _e284);
  _e290 = mkSymbolInternal(Kind::PARAM, "cons", _e286);
  _e291 = mkExprInternal(Kind::APPLY, {_e230, _e290, _e289, _e288});
  _e292 = mkSymbolInternal(Kind::PARAM, "xs", _e284);
  _e293 = mkExprInternal(Kind::APPLY, {_e283, _e290, _e292, _e291});
  bind("nary.reverseRec", _e283);
  _runId[_e287.get()] = 287;
  _e287->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e295 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e296 = mkExprInternal(Kind::FUNCTION_TYPE, {_e295, _e295});
  _e296->d_type = _e2;
  _e297 = mkExprInternal(Kind::FUNCTION_TYPE, {_e295, _e296});
  _e297->d_type = _e2;
  _e298 = mkExprInternal(Kind::FUNCTION_TYPE, {_e297, _e295, _e295, _e295});
  _e294 = mkSymbolInternal(Kind::PROGRAM_CONST, "nary.reverse", _e298);
  _runId[_e294.get()] = 294;
  _e294->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e299 = mkSymbolInternal(Kind::PARAM, "nil", _e295);
  _e300 = mkSymbolInternal(Kind::PARAM, "xs", _e295);
  _e301 = mkSymbolInternal(Kind::PARAM, "cons", _e297);
  _e302 = mkExprInternal(Kind::APPLY, {_e283, _e301, _e300, _e299});
  bind("nary.reverse", _e294);
  _runId[_e298.get()] = 298;
  _e298->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e304 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e305 = mkExprInternal(Kind::FUNCTION_TYPE, {_e304, _e304});
  _e305->d_type = _e2;
  _e306 = mkExprInternal(Kind::FUNCTION_TYPE, {_e304, _e305});
  _e306->d_type = _e2;
  _e307 = mkExprInternal(Kind::FUNCTION_TYPE, {_e306, _e304, _e304, _e304, _e304});
  _e303 = mkSymbolInternal(Kind::PROGRAM_CONST, "nary.elim", _e307);
  _runId[_e303.get()] = 303;
  _e303->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e308 = mkSymbolInternal(Kind::PARAM, "c", _e304);
  _e309 = mkSymbolInternal(Kind::PARAM, "x", _e304);
  _e310 = mkSymbolInternal(Kind::PARAM, "xs", _e304);
  _e311 = mkSymbolInternal(Kind::PARAM, "cons", _e306);
  _e312 = mkExprInternal(Kind::APPLY, {_e230, _e311, _e309, _e310});
  bind("nary.elim", _e303);
  _runId[_e307.get()] = 307;
  _e307->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e314 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e315 = mkExprInternal(Kind::FUNCTION_TYPE, {_e314, _e314});
  _e315->d_type = _e2;
  _e316 = mkExprInternal(Kind::FUNCTION_TYPE, {_e314, _e315});
  _e316->d_type = _e2;
  _e317 = mkExprInternal(Kind::FUNCTION_TYPE, {_e316, _e314, _e314, _e314});
  _e313 = mkSymbolInternal(Kind::PROGRAM_CONST, "nary.intro", _e317);
  _runId[_e313.get()] = 313;
  _e313->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e318 = mkSymbolInternal(Kind::PARAM, "xs", _e314);
  _e319 = mkSymbolInternal(Kind::PARAM, "x", _e314);
  _e320 = mkSymbolInternal(Kind::PARAM, "cons", _e316);
  _e321 = mkExprInternal(Kind::APPLY, {_e230, _e320, _e319, _e318});
  _e322 = mkSymbolInternal(Kind::PARAM, "nil", _e314);
  _e323 = mkExprInternal(Kind::APPLY, {_e230, _e320, _e319, _e322});
  bind("nary.intro", _e313);
  _runId[_e317.get()] = 317;
  _e317->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e325 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e326 = mkSymbolInternal(Kind::PARAM, "I", _e2);
  _e327 = mkExprInternal(Kind::FUNCTION_TYPE, {_e325, _e325});
  _e327->d_type = _e2;
  _e328 = mkExprInternal(Kind::FUNCTION_TYPE, {_e325, _e327});
  _e328->d_type = _e2;
  _e329 = mkExprInternal(Kind::FUNCTION_TYPE, {_e328, _e326, _e325, _e325});
  _e324 = mkSymbolInternal(Kind::PROGRAM_CONST, "nary.at", _e329);
  _runId[_e324.get()] = 324;
  _e324->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e330 = mkLiteral(Kind::NUMERAL, "0");
  _e331 = mkSymbolInternal(Kind::PARAM, "x", _e325);
  _e332 = mkLiteral(Kind::NUMERAL, "-1");
  _e333 = mkSymbolInternal(Kind::PARAM, "i", _e326);
  _e334 = mkExprInternal(Kind::EVAL_ADD, {_e333, _e332});
  _runId[_e334.get()] = 334;
  _e334->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e335 = mkSymbolInternal(Kind::PARAM, "xs", _e325);
  _e336 = mkSymbolInternal(Kind::PARAM, "cons", _e328);
  _e337 = mkExprInternal(Kind::APPLY, {_e324, _e336, _e334, _e335});
  bind("nary.at", _e324);
  _runId[_e329.get()] = 329;
  _e329->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e339 = mkSymbolInternal(Kind::PARAM, "L", _e2);
  _e340 = mkExprInternal(Kind::FUNCTION_TYPE, {_e339, _e339});
  _e340->d_type = _e2;
  _e341 = mkExprInternal(Kind::FUNCTION_TYPE, {_e339, _e340});
  _e341->d_type = _e2;
  _e342 = mkExprInternal(Kind::FUNCTION_TYPE, {_e341, _e339, _e339, _e13});
  _e338 = mkSymbolInternal(Kind::PROGRAM_CONST, "nary.is_prefix", _e342);
  _runId[_e338.get()] = 338;
  _e338->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e343 = mkSymbolInternal(Kind::PARAM, "c2", _e339);
  _e344 = mkSymbolInternal(Kind::PARAM, "c1", _e339);
  _e345 = mkExprInternal(Kind::EVAL_IS_EQ, {_e344, _e343});
  _runId[_e345.get()] = 345;
  _e345->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e346 = mkSymbolInternal(Kind::PARAM, "xs2", _e339);
  _e347 = mkSymbolInternal(Kind::PARAM, "xs1", _e339);
  _e348 = mkSymbolInternal(Kind::PARAM, "cons", _e341);
  _e349 = mkExprInternal(Kind::APPLY, {_e338, _e348, _e347, _e346});
  _e350 = mkExprInternal(Kind::EVAL_IF_THEN_ELSE, {_e345, _e349, _e26});
  bind("nary.is_prefix", _e338);
  _runId[_e342.get()] = 342;
  _e342->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e352 = mkSymbolInternal(Kind::PARAM, "G", _e13);
  _e353 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e354 = mkExprInternal(Kind::APPLY, {_e49, _e353});
  _e355 = mkExprInternal(Kind::APPLY, {_e354, _e352});
  _e356 = mkExprInternal(Kind::PROOF_TYPE, {_e355});
  _e357 = mkExprInternal(Kind::PROOF_TYPE, {_e352});
  _e358 = mkExprInternal(Kind::QUOTE_TYPE, {_e353});
  _e359 = mkExprInternal(Kind::FUNCTION_TYPE, {_e358, _e357, _e356});
  _e351 = mkSymbolInternal(Kind::PROOF_RULE, "scope", _e359);
  bind("scope", _e351);
  _runId[_e359.get()] = 359;
  _e359->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e361 = mkExprInternal(Kind::FUNCTION_TYPE, {_e13, _e13, _e13});
  _e360 = mkSymbolInternal(Kind::PROGRAM_CONST, "extract_antec", _e361);
  _runId[_e360.get()] = 360;
  _e360->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e362 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e363 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e364 = mkExprInternal(Kind::APPLY, {_e360, _e363, _e362});
  _e365 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e366 = mkExprInternal(Kind::APPLY, {_e230, _e44, _e365, _e364});
  bind("extract_antec", _e360);
  _runId[_e361.get()] = 361;
  _e361->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e367 = mkSymbolInternal(Kind::PROGRAM_CONST, "run_process_scope", _e361);
  _runId[_e367.get()] = 367;
  _e367->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e368 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e369 = mkExprInternal(Kind::APPLY, {_e360, _e368, _e26});
  _e370 = mkExprInternal(Kind::APPLY, {_e303, _e44, _e32, _e25, _e369});
  _e371 = mkExprInternal(Kind::APPLY, {_e38, _e370});
  _e372 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e373 = mkExprInternal(Kind::APPLY, {_e360, _e368, _e372});
  _e374 = mkExprInternal(Kind::APPLY, {_e303, _e44, _e32, _e25, _e373});
  _e375 = mkExprInternal(Kind::APPLY, {_e49, _e374});
  _e376 = mkExprInternal(Kind::APPLY, {_e375, _e372});
  bind("run_process_scope", _e367);
  _e378 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e379 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e380 = mkExprInternal(Kind::APPLY, {_e367, _e379, _e378});
  _e381 = mkExprInternal(Kind::PROOF_TYPE, {_e380});
  _e382 = mkExprInternal(Kind::QUOTE_TYPE, {_e378});
  _e383 = mkExprInternal(Kind::PROOF_TYPE, {_e379});
  _e384 = mkExprInternal(Kind::FUNCTION_TYPE, {_e383, _e382, _e381});
  _e377 = mkSymbolInternal(Kind::PROOF_RULE, "process_scope", _e384);
  bind("process_scope", _e377);
  _runId[_e384.get()] = 384;
  _e384->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e386 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e387 = mkExprInternal(Kind::APPLY, {_e38, _e386});
  _e388 = mkExprInternal(Kind::APPLY, {_e39, _e387});
  _e389 = mkExprInternal(Kind::APPLY, {_e388, _e32});
  _e390 = mkExprInternal(Kind::APPLY, {_e39, _e386});
  _e391 = mkExprInternal(Kind::APPLY, {_e390, _e389});
  _e392 = mkExprInternal(Kind::PROOF_TYPE, {_e391});
  _e393 = mkExprInternal(Kind::QUOTE_TYPE, {_e386});
  _e394 = mkExprInternal(Kind::FUNCTION_TYPE, {_e393, _e392});
  _e385 = mkSymbolInternal(Kind::PROOF_RULE, "split", _e394);
  bind("split", _e385);
  _runId[_e394.get()] = 394;
  _e394->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e395 = mkSymbolInternal(Kind::PROGRAM_CONST, "removeSelf", _e361);
  _runId[_e395.get()] = 395;
  _e395->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e396 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e397 = mkSymbolInternal(Kind::PARAM, "l", _e13);
  _e398 = mkExprInternal(Kind::APPLY, {_e272, _e39, _e397, _e396});
  bind("removeSelf", _e395);
  _e400 = mkExprInternal(Kind::FUNCTION_TYPE, {_e13, _e13, _e13, _e13, _e13});
  _e399 = mkSymbolInternal(Kind::PROGRAM_CONST, "resolve", _e400);
  _runId[_e399.get()] = 399;
  _e399->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e401 = mkSymbolInternal(Kind::PARAM, "L", _e13);
  _e402 = mkExprInternal(Kind::APPLY, {_e38, _e401});
  _runId[_e402.get()] = 402;
  _e402->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e403 = mkSymbolInternal(Kind::PARAM, "C2", _e13);
  _e404 = mkExprInternal(Kind::APPLY, {_e313, _e39, _e32, _e403});
  _e405 = mkExprInternal(Kind::APPLY, {_e395, _e402, _e404});
  _e406 = mkSymbolInternal(Kind::PARAM, "C1", _e13);
  _e407 = mkExprInternal(Kind::APPLY, {_e313, _e39, _e32, _e406});
  _e408 = mkExprInternal(Kind::APPLY, {_e395, _e401, _e407});
  _e409 = mkExprInternal(Kind::APPLY, {_e261, _e39, _e408, _e405});
  _e410 = mkExprInternal(Kind::APPLY, {_e303, _e39, _e32, _e26, _e409});
  _e411 = mkExprInternal(Kind::APPLY, {_e395, _e401, _e404});
  _e412 = mkExprInternal(Kind::APPLY, {_e395, _e402, _e407});
  _e413 = mkExprInternal(Kind::APPLY, {_e261, _e39, _e412, _e411});
  _e414 = mkExprInternal(Kind::APPLY, {_e303, _e39, _e32, _e26, _e413});
  bind("resolve", _e399);
  _runId[_e400.get()] = 400;
  _e400->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e416 = mkSymbolInternal(Kind::PARAM, "L", _e13);
  _e417 = mkSymbolInternal(Kind::PARAM, "pol", _e13);
  _e418 = mkSymbolInternal(Kind::PARAM, "C2", _e13);
  _e419 = mkSymbolInternal(Kind::PARAM, "C1", _e13);
  _e420 = mkExprInternal(Kind::APPLY, {_e399, _e419, _e418, _e417, _e416});
  _e421 = mkExprInternal(Kind::PROOF_TYPE, {_e420});
  _e422 = mkExprInternal(Kind::QUOTE_TYPE, {_e416});
  _e423 = mkExprInternal(Kind::QUOTE_TYPE, {_e417});
  _e424 = mkExprInternal(Kind::PROOF_TYPE, {_e418});
  _e425 = mkExprInternal(Kind::PROOF_TYPE, {_e419});
  _e426 = mkExprInternal(Kind::FUNCTION_TYPE, {_e425, _e424, _e423, _e422, _e421});
  _e415 = mkSymbolInternal(Kind::PROOF_RULE, "resolution", _e426);
  bind("resolution", _e415);
  _runId[_e426.get()] = 426;
  _e426->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e428 = mkExprInternal(Kind::FUNCTION_TYPE, {_e13, _e13, _e13, _e13});
  _e427 = mkSymbolInternal(Kind::PROGRAM_CONST, "chainResolveRec", _e428);
  _runId[_e427.get()] = 427;
  _e427->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e429 = mkSymbolInternal(Kind::PARAM, "C1", _e13);
  _e430 = mkSymbolInternal(Kind::PARAM, "args", _e13);
  _e431 = mkSymbolInternal(Kind::PARAM, "Cs", _e13);
  _e432 = mkSymbolInternal(Kind::PARAM, "L", _e13);
  _e433 = mkSymbolInternal(Kind::PARAM, "pol", _e13);
  _e434 = mkSymbolInternal(Kind::PARAM, "C2", _e13);
  _e435 = mkExprInternal(Kind::APPLY, {_e399, _e429, _e434, _e433, _e432});
  _e436 = mkExprInternal(Kind::APPLY, {_e427, _e435, _e431, _e430});
  bind("chainResolveRec", _e427);
  _runId[_e428.get()] = 428;
  _e428->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e437 = mkSymbolInternal(Kind::PROGRAM_CONST, "chainResolve", _e361);
  _runId[_e437.get()] = 437;
  _e437->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e438 = mkSymbolInternal(Kind::PARAM, "args", _e13);
  _e439 = mkSymbolInternal(Kind::PARAM, "Cs", _e13);
  _e440 = mkSymbolInternal(Kind::PARAM, "C1", _e13);
  _e441 = mkExprInternal(Kind::APPLY, {_e427, _e440, _e439, _e438});
  bind("chainResolve", _e437);
  _e443 = mkSymbolInternal(Kind::PARAM, "args", _e13);
  _e444 = mkSymbolInternal(Kind::PARAM, "Cs", _e13);
  _e445 = mkExprInternal(Kind::APPLY, {_e437, _e444, _e443});
  _e446 = mkExprInternal(Kind::PROOF_TYPE, {_e445});
  _e447 = mkExprInternal(Kind::QUOTE_TYPE, {_e443});
  _e448 = mkExprInternal(Kind::PROOF_TYPE, {_e444});
  _e449 = mkExprInternal(Kind::FUNCTION_TYPE, {_e448, _e447, _e446});
  _e442 = mkSymbolInternal(Kind::PROOF_RULE, "chain_resolution", _e449);
  bind("chain_resolution", _e442);
  _runId[_e449.get()] = 449;
  _e449->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::PREMISE_LIST].push_back(_e44);
  markAttributes(_e442, _amap);
  _e451 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e452 = mkExprInternal(Kind::PROOF_TYPE, {_e451});
  _e453 = mkSymbolInternal(Kind::PARAM, "args", _e13);
  _e454 = mkExprInternal(Kind::QUOTE_TYPE, {_e453});
  _e455 = mkExprInternal(Kind::QUOTE_TYPE, {_e451});
  _e456 = mkSymbolInternal(Kind::PARAM, "Cs", _e13);
  _e457 = mkExprInternal(Kind::PROOF_TYPE, {_e456});
  _e458 = mkExprInternal(Kind::FUNCTION_TYPE, {_e457, _e455, _e454, _e452});
  _e450 = mkSymbolInternal(Kind::PROOF_RULE, "macro_resolution_trust", _e458);
  bind("macro_resolution_trust", _e450);
  _runId[_e458.get()] = 458;
  _e458->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e460 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e461 = mkExprInternal(Kind::PROOF_TYPE, {_e460});
  _e462 = mkSymbolInternal(Kind::PARAM, "args", _e13);
  _e463 = mkExprInternal(Kind::QUOTE_TYPE, {_e462});
  _e464 = mkExprInternal(Kind::QUOTE_TYPE, {_e460});
  _e465 = mkSymbolInternal(Kind::PARAM, "Cs", _e13);
  _e466 = mkExprInternal(Kind::PROOF_TYPE, {_e465});
  _e467 = mkExprInternal(Kind::FUNCTION_TYPE, {_e466, _e464, _e463, _e461});
  _e459 = mkSymbolInternal(Kind::PROOF_RULE, "macro_resolution", _e467);
  bind("macro_resolution", _e459);
  _runId[_e467.get()] = 467;
  _e467->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e468 = mkSymbolInternal(Kind::PROGRAM_CONST, "factorLiterals", _e361);
  _runId[_e468.get()] = 468;
  _e468->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e469 = mkSymbolInternal(Kind::PARAM, "ls", _e13);
  _e470 = mkSymbolInternal(Kind::PARAM, "xs", _e13);
  _e471 = mkSymbolInternal(Kind::PARAM, "l", _e13);
  _e472 = mkExprInternal(Kind::APPLY, {_e230, _e39, _e471, _e470});
  _e473 = mkExprInternal(Kind::APPLY, {_e240, _e39, _e471, _e470});
  _e474 = mkExprInternal(Kind::EVAL_IF_THEN_ELSE, {_e473, _e470, _e472});
  _e475 = mkExprInternal(Kind::APPLY, {_e468, _e474, _e469});
  _e476 = mkExprInternal(Kind::APPLY, {_e230, _e39, _e471, _e475});
  _e477 = mkExprInternal(Kind::EVAL_IF_THEN_ELSE, {_e473, _e475, _e476});
  bind("factorLiterals", _e468);
  _e479 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e480 = mkExprInternal(Kind::APPLY, {_e468, _e32, _e479});
  _e481 = mkExprInternal(Kind::APPLY, {_e303, _e39, _e32, _e26, _e480});
  _e482 = mkExprInternal(Kind::PROOF_TYPE, {_e481});
  _e483 = mkExprInternal(Kind::PROOF_TYPE, {_e479});
  _e484 = mkExprInternal(Kind::FUNCTION_TYPE, {_e483, _e482});
  _e478 = mkSymbolInternal(Kind::PROOF_RULE, "factoring", _e484);
  bind("factoring", _e478);
  _runId[_e484.get()] = 484;
  _e484->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e486 = mkSymbolInternal(Kind::PARAM, "C2", _e13);
  _e487 = mkExprInternal(Kind::PROOF_TYPE, {_e486});
  _e488 = mkSymbolInternal(Kind::PARAM, "C1", _e13);
  _e489 = mkExprInternal(Kind::APPLY, {_e249, _e39, _e488, _e486});
  _e490 = mkExprInternal(Kind::PAIR, {_e489, _e25});
  _e491 = mkExprInternal(Kind::REQUIRES_TYPE, {_e490, _e487});
  _e492 = mkExprInternal(Kind::QUOTE_TYPE, {_e486});
  _e493 = mkExprInternal(Kind::PROOF_TYPE, {_e488});
  _e494 = mkExprInternal(Kind::FUNCTION_TYPE, {_e493, _e492, _e491});
  _e485 = mkSymbolInternal(Kind::PROOF_RULE, "reordering", _e494);
  bind("reordering", _e485);
  _runId[_e494.get()] = 494;
  _e494->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e496 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e497 = mkExprInternal(Kind::PROOF_TYPE, {_e496});
  _e498 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e499 = mkExprInternal(Kind::APPLY, {_e52, _e498});
  _e500 = mkExprInternal(Kind::APPLY, {_e499, _e496});
  _e501 = mkExprInternal(Kind::PROOF_TYPE, {_e500});
  _e502 = mkExprInternal(Kind::PROOF_TYPE, {_e498});
  _e503 = mkExprInternal(Kind::FUNCTION_TYPE, {_e502, _e501, _e497});
  _e495 = mkSymbolInternal(Kind::PROOF_RULE, "eq_resolve", _e503);
  bind("eq_resolve", _e495);
  _runId[_e503.get()] = 503;
  _e503->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e505 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e506 = mkExprInternal(Kind::PROOF_TYPE, {_e505});
  _e507 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e508 = mkExprInternal(Kind::APPLY, {_e49, _e507});
  _e509 = mkExprInternal(Kind::APPLY, {_e508, _e505});
  _e510 = mkExprInternal(Kind::PROOF_TYPE, {_e509});
  _e511 = mkExprInternal(Kind::PROOF_TYPE, {_e507});
  _e512 = mkExprInternal(Kind::FUNCTION_TYPE, {_e511, _e510, _e506});
  _e504 = mkSymbolInternal(Kind::PROOF_RULE, "modus_ponens", _e512);
  bind("modus_ponens", _e504);
  _runId[_e512.get()] = 512;
  _e512->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e514 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e515 = mkExprInternal(Kind::PROOF_TYPE, {_e514});
  _e516 = mkExprInternal(Kind::APPLY, {_e38, _e514});
  _e517 = mkExprInternal(Kind::APPLY, {_e38, _e516});
  _e518 = mkExprInternal(Kind::PROOF_TYPE, {_e517});
  _e519 = mkExprInternal(Kind::FUNCTION_TYPE, {_e518, _e515});
  _e513 = mkSymbolInternal(Kind::PROOF_RULE, "not_not_elim", _e519);
  bind("not_not_elim", _e513);
  _runId[_e519.get()] = 519;
  _e519->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e521 = mkExprInternal(Kind::PROOF_TYPE, {_e26});
  _e522 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e523 = mkExprInternal(Kind::APPLY, {_e38, _e522});
  _e524 = mkExprInternal(Kind::PROOF_TYPE, {_e523});
  _e525 = mkExprInternal(Kind::PROOF_TYPE, {_e522});
  _e526 = mkExprInternal(Kind::FUNCTION_TYPE, {_e525, _e524, _e521});
  _e520 = mkSymbolInternal(Kind::PROOF_RULE, "contra", _e526);
  bind("contra", _e520);
  _runId[_e526.get()] = 526;
  _e526->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e528 = mkSymbolInternal(Kind::PARAM, "Fs", _e13);
  _e529 = mkSymbolInternal(Kind::PARAM, "i", _e125);
  _e530 = mkExprInternal(Kind::APPLY, {_e324, _e44, _e529, _e528});
  _e531 = mkExprInternal(Kind::PROOF_TYPE, {_e530});
  _e532 = mkExprInternal(Kind::QUOTE_TYPE, {_e529});
  _e533 = mkExprInternal(Kind::PROOF_TYPE, {_e528});
  _e534 = mkExprInternal(Kind::FUNCTION_TYPE, {_e533, _e532, _e531});
  _e527 = mkSymbolInternal(Kind::PROOF_RULE, "and_elim", _e534);
  bind("and_elim", _e527);
  _runId[_e534.get()] = 534;
  _e534->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e536 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e537 = mkExprInternal(Kind::PROOF_TYPE, {_e536});
  _e538 = mkExprInternal(Kind::FUNCTION_TYPE, {_e537, _e537});
  _e535 = mkSymbolInternal(Kind::PROOF_RULE, "and_intro", _e538);
  bind("and_intro", _e535);
  _runId[_e538.get()] = 538;
  _e538->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::PREMISE_LIST].push_back(_e44);
  markAttributes(_e535, _amap);
  _e540 = mkSymbolInternal(Kind::PARAM, "Fs", _e13);
  _e541 = mkSymbolInternal(Kind::PARAM, "i", _e125);
  _e542 = mkExprInternal(Kind::APPLY, {_e324, _e39, _e541, _e540});
  _e543 = mkExprInternal(Kind::APPLY, {_e38, _e542});
  _e544 = mkExprInternal(Kind::PROOF_TYPE, {_e543});
  _e545 = mkExprInternal(Kind::QUOTE_TYPE, {_e541});
  _e546 = mkExprInternal(Kind::APPLY, {_e38, _e540});
  _e547 = mkExprInternal(Kind::PROOF_TYPE, {_e546});
  _e548 = mkExprInternal(Kind::FUNCTION_TYPE, {_e547, _e545, _e544});
  _e539 = mkSymbolInternal(Kind::PROOF_RULE, "not_or_elim", _e548);
  bind("not_or_elim", _e539);
  _runId[_e548.get()] = 548;
  _e548->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e550 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e551 = mkExprInternal(Kind::APPLY, {_e39, _e550});
  _e552 = mkExprInternal(Kind::APPLY, {_e551, _e32});
  _e553 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e554 = mkExprInternal(Kind::APPLY, {_e38, _e553});
  _e555 = mkExprInternal(Kind::APPLY, {_e39, _e554});
  _e556 = mkExprInternal(Kind::APPLY, {_e555, _e552});
  _e557 = mkExprInternal(Kind::PROOF_TYPE, {_e556});
  _e558 = mkExprInternal(Kind::APPLY, {_e49, _e553});
  _e559 = mkExprInternal(Kind::APPLY, {_e558, _e550});
  _e560 = mkExprInternal(Kind::PROOF_TYPE, {_e559});
  _e561 = mkExprInternal(Kind::FUNCTION_TYPE, {_e560, _e557});
  _e549 = mkSymbolInternal(Kind::PROOF_RULE, "implies_elim", _e561);
  bind("implies_elim", _e549);
  _runId[_e561.get()] = 561;
  _e561->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e563 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e564 = mkExprInternal(Kind::PROOF_TYPE, {_e563});
  _e565 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e566 = mkExprInternal(Kind::APPLY, {_e49, _e563});
  _e567 = mkExprInternal(Kind::APPLY, {_e566, _e565});
  _e568 = mkExprInternal(Kind::APPLY, {_e38, _e567});
  _e569 = mkExprInternal(Kind::PROOF_TYPE, {_e568});
  _e570 = mkExprInternal(Kind::FUNCTION_TYPE, {_e569, _e564});
  _e562 = mkSymbolInternal(Kind::PROOF_RULE, "not_implies_elim1", _e570);
  bind("not_implies_elim1", _e562);
  _runId[_e570.get()] = 570;
  _e570->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e572 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e573 = mkExprInternal(Kind::APPLY, {_e38, _e572});
  _e574 = mkExprInternal(Kind::PROOF_TYPE, {_e573});
  _e575 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e576 = mkExprInternal(Kind::APPLY, {_e49, _e575});
  _e577 = mkExprInternal(Kind::APPLY, {_e576, _e572});
  _e578 = mkExprInternal(Kind::APPLY, {_e38, _e577});
  _e579 = mkExprInternal(Kind::PROOF_TYPE, {_e578});
  _e580 = mkExprInternal(Kind::FUNCTION_TYPE, {_e579, _e574});
  _e571 = mkSymbolInternal(Kind::PROOF_RULE, "not_implies_elim2", _e580);
  bind("not_implies_elim2", _e571);
  _runId[_e580.get()] = 580;
  _e580->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e582 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e583 = mkExprInternal(Kind::APPLY, {_e39, _e582});
  _e584 = mkExprInternal(Kind::APPLY, {_e583, _e32});
  _e585 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e586 = mkExprInternal(Kind::APPLY, {_e38, _e585});
  _e587 = mkExprInternal(Kind::APPLY, {_e39, _e586});
  _e588 = mkExprInternal(Kind::APPLY, {_e587, _e584});
  _e589 = mkExprInternal(Kind::PROOF_TYPE, {_e588});
  _e590 = mkExprInternal(Kind::APPLY, {_e52, _e585});
  _e591 = mkExprInternal(Kind::APPLY, {_e590, _e582});
  _e592 = mkExprInternal(Kind::PROOF_TYPE, {_e591});
  _e593 = mkExprInternal(Kind::FUNCTION_TYPE, {_e592, _e589});
  _e581 = mkSymbolInternal(Kind::PROOF_RULE, "equiv_elim1", _e593);
  bind("equiv_elim1", _e581);
  _runId[_e593.get()] = 593;
  _e593->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e595 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e596 = mkExprInternal(Kind::APPLY, {_e38, _e595});
  _e597 = mkExprInternal(Kind::APPLY, {_e39, _e596});
  _e598 = mkExprInternal(Kind::APPLY, {_e597, _e32});
  _e599 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e600 = mkExprInternal(Kind::APPLY, {_e39, _e599});
  _e601 = mkExprInternal(Kind::APPLY, {_e600, _e598});
  _e602 = mkExprInternal(Kind::PROOF_TYPE, {_e601});
  _e603 = mkExprInternal(Kind::APPLY, {_e52, _e599});
  _e604 = mkExprInternal(Kind::APPLY, {_e603, _e595});
  _e605 = mkExprInternal(Kind::PROOF_TYPE, {_e604});
  _e606 = mkExprInternal(Kind::FUNCTION_TYPE, {_e605, _e602});
  _e594 = mkSymbolInternal(Kind::PROOF_RULE, "equiv_elim2", _e606);
  bind("equiv_elim2", _e594);
  _runId[_e606.get()] = 606;
  _e606->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e608 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e609 = mkExprInternal(Kind::APPLY, {_e39, _e608});
  _e610 = mkExprInternal(Kind::APPLY, {_e609, _e32});
  _e611 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e612 = mkExprInternal(Kind::APPLY, {_e39, _e611});
  _e613 = mkExprInternal(Kind::APPLY, {_e612, _e610});
  _e614 = mkExprInternal(Kind::PROOF_TYPE, {_e613});
  _e615 = mkExprInternal(Kind::APPLY, {_e52, _e611});
  _e616 = mkExprInternal(Kind::APPLY, {_e615, _e608});
  _e617 = mkExprInternal(Kind::APPLY, {_e38, _e616});
  _e618 = mkExprInternal(Kind::PROOF_TYPE, {_e617});
  _e619 = mkExprInternal(Kind::FUNCTION_TYPE, {_e618, _e614});
  _e607 = mkSymbolInternal(Kind::PROOF_RULE, "not_equiv_elim1", _e619);
  bind("not_equiv_elim1", _e607);
  _runId[_e619.get()] = 619;
  _e619->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e621 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e622 = mkExprInternal(Kind::APPLY, {_e38, _e621});
  _e623 = mkExprInternal(Kind::APPLY, {_e39, _e622});
  _e624 = mkExprInternal(Kind::APPLY, {_e623, _e32});
  _e625 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e626 = mkExprInternal(Kind::APPLY, {_e38, _e625});
  _e627 = mkExprInternal(Kind::APPLY, {_e39, _e626});
  _e628 = mkExprInternal(Kind::APPLY, {_e627, _e624});
  _e629 = mkExprInternal(Kind::PROOF_TYPE, {_e628});
  _e630 = mkExprInternal(Kind::APPLY, {_e52, _e625});
  _e631 = mkExprInternal(Kind::APPLY, {_e630, _e621});
  _e632 = mkExprInternal(Kind::APPLY, {_e38, _e631});
  _e633 = mkExprInternal(Kind::PROOF_TYPE, {_e632});
  _e634 = mkExprInternal(Kind::FUNCTION_TYPE, {_e633, _e629});
  _e620 = mkSymbolInternal(Kind::PROOF_RULE, "not_equiv_elim2", _e634);
  bind("not_equiv_elim2", _e620);
  _runId[_e634.get()] = 634;
  _e634->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e636 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e637 = mkExprInternal(Kind::APPLY, {_e39, _e636});
  _e638 = mkExprInternal(Kind::APPLY, {_e637, _e32});
  _e639 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e640 = mkExprInternal(Kind::APPLY, {_e39, _e639});
  _e641 = mkExprInternal(Kind::APPLY, {_e640, _e638});
  _e642 = mkExprInternal(Kind::PROOF_TYPE, {_e641});
  _e643 = mkExprInternal(Kind::APPLY, {_e51, _e639});
  _e644 = mkExprInternal(Kind::APPLY, {_e643, _e636});
  _e645 = mkExprInternal(Kind::PROOF_TYPE, {_e644});
  _e646 = mkExprInternal(Kind::FUNCTION_TYPE, {_e645, _e642});
  _e635 = mkSymbolInternal(Kind::PROOF_RULE, "xor_elim1", _e646);
  bind("xor_elim1", _e635);
  _runId[_e646.get()] = 646;
  _e646->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e648 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e649 = mkExprInternal(Kind::APPLY, {_e38, _e648});
  _e650 = mkExprInternal(Kind::APPLY, {_e39, _e649});
  _e651 = mkExprInternal(Kind::APPLY, {_e650, _e32});
  _e652 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e653 = mkExprInternal(Kind::APPLY, {_e38, _e652});
  _e654 = mkExprInternal(Kind::APPLY, {_e39, _e653});
  _e655 = mkExprInternal(Kind::APPLY, {_e654, _e651});
  _e656 = mkExprInternal(Kind::PROOF_TYPE, {_e655});
  _e657 = mkExprInternal(Kind::APPLY, {_e51, _e652});
  _e658 = mkExprInternal(Kind::APPLY, {_e657, _e648});
  _e659 = mkExprInternal(Kind::PROOF_TYPE, {_e658});
  _e660 = mkExprInternal(Kind::FUNCTION_TYPE, {_e659, _e656});
  _e647 = mkSymbolInternal(Kind::PROOF_RULE, "xor_elim2", _e660);
  bind("xor_elim2", _e647);
  _runId[_e660.get()] = 660;
  _e660->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e662 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e663 = mkExprInternal(Kind::APPLY, {_e38, _e662});
  _e664 = mkExprInternal(Kind::APPLY, {_e39, _e663});
  _e665 = mkExprInternal(Kind::APPLY, {_e664, _e32});
  _e666 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e667 = mkExprInternal(Kind::APPLY, {_e39, _e666});
  _e668 = mkExprInternal(Kind::APPLY, {_e667, _e665});
  _e669 = mkExprInternal(Kind::PROOF_TYPE, {_e668});
  _e670 = mkExprInternal(Kind::APPLY, {_e51, _e666});
  _e671 = mkExprInternal(Kind::APPLY, {_e670, _e662});
  _e672 = mkExprInternal(Kind::APPLY, {_e38, _e671});
  _e673 = mkExprInternal(Kind::PROOF_TYPE, {_e672});
  _e674 = mkExprInternal(Kind::FUNCTION_TYPE, {_e673, _e669});
  _e661 = mkSymbolInternal(Kind::PROOF_RULE, "not_xor_elim1", _e674);
  bind("not_xor_elim1", _e661);
  _runId[_e674.get()] = 674;
  _e674->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e676 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e677 = mkExprInternal(Kind::APPLY, {_e39, _e676});
  _e678 = mkExprInternal(Kind::APPLY, {_e677, _e32});
  _e679 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e680 = mkExprInternal(Kind::APPLY, {_e38, _e679});
  _e681 = mkExprInternal(Kind::APPLY, {_e39, _e680});
  _e682 = mkExprInternal(Kind::APPLY, {_e681, _e678});
  _e683 = mkExprInternal(Kind::PROOF_TYPE, {_e682});
  _e684 = mkExprInternal(Kind::APPLY, {_e51, _e679});
  _e685 = mkExprInternal(Kind::APPLY, {_e684, _e676});
  _e686 = mkExprInternal(Kind::APPLY, {_e38, _e685});
  _e687 = mkExprInternal(Kind::PROOF_TYPE, {_e686});
  _e688 = mkExprInternal(Kind::FUNCTION_TYPE, {_e687, _e683});
  _e675 = mkSymbolInternal(Kind::PROOF_RULE, "not_xor_elim2", _e688);
  bind("not_xor_elim2", _e675);
  _runId[_e688.get()] = 688;
  _e688->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e690 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e691 = mkExprInternal(Kind::APPLY, {_e39, _e690});
  _e692 = mkExprInternal(Kind::APPLY, {_e691, _e32});
  _e693 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e694 = mkExprInternal(Kind::APPLY, {_e38, _e693});
  _e695 = mkExprInternal(Kind::APPLY, {_e39, _e694});
  _e696 = mkExprInternal(Kind::APPLY, {_e695, _e692});
  _e697 = mkExprInternal(Kind::PROOF_TYPE, {_e696});
  _e698 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e699 = mkExprInternal(Kind::APPLY, {_e33, _e693});
  _e700 = mkExprInternal(Kind::APPLY, {_e699, _e690});
  _e701 = mkExprInternal(Kind::APPLY, {_e700, _e698});
  _e702 = mkExprInternal(Kind::PROOF_TYPE, {_e701});
  _e703 = mkExprInternal(Kind::FUNCTION_TYPE, {_e702, _e697});
  _e689 = mkSymbolInternal(Kind::PROOF_RULE, "ite_elim1", _e703);
  bind("ite_elim1", _e689);
  _runId[_e703.get()] = 703;
  _e703->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e705 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e706 = mkExprInternal(Kind::APPLY, {_e39, _e705});
  _e707 = mkExprInternal(Kind::APPLY, {_e706, _e32});
  _e708 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e709 = mkExprInternal(Kind::APPLY, {_e39, _e708});
  _e710 = mkExprInternal(Kind::APPLY, {_e709, _e707});
  _e711 = mkExprInternal(Kind::PROOF_TYPE, {_e710});
  _e712 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e713 = mkExprInternal(Kind::APPLY, {_e33, _e708});
  _e714 = mkExprInternal(Kind::APPLY, {_e713, _e712});
  _e715 = mkExprInternal(Kind::APPLY, {_e714, _e705});
  _e716 = mkExprInternal(Kind::PROOF_TYPE, {_e715});
  _e717 = mkExprInternal(Kind::FUNCTION_TYPE, {_e716, _e711});
  _e704 = mkSymbolInternal(Kind::PROOF_RULE, "ite_elim2", _e717);
  bind("ite_elim2", _e704);
  _runId[_e717.get()] = 717;
  _e717->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e719 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e720 = mkExprInternal(Kind::APPLY, {_e38, _e719});
  _e721 = mkExprInternal(Kind::APPLY, {_e39, _e720});
  _e722 = mkExprInternal(Kind::APPLY, {_e721, _e32});
  _e723 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e724 = mkExprInternal(Kind::APPLY, {_e38, _e723});
  _e725 = mkExprInternal(Kind::APPLY, {_e39, _e724});
  _e726 = mkExprInternal(Kind::APPLY, {_e725, _e722});
  _e727 = mkExprInternal(Kind::PROOF_TYPE, {_e726});
  _e728 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e729 = mkExprInternal(Kind::APPLY, {_e33, _e723});
  _e730 = mkExprInternal(Kind::APPLY, {_e729, _e719});
  _e731 = mkExprInternal(Kind::APPLY, {_e730, _e728});
  _e732 = mkExprInternal(Kind::APPLY, {_e38, _e731});
  _e733 = mkExprInternal(Kind::PROOF_TYPE, {_e732});
  _e734 = mkExprInternal(Kind::FUNCTION_TYPE, {_e733, _e727});
  _e718 = mkSymbolInternal(Kind::PROOF_RULE, "not_ite_elim1", _e734);
  bind("not_ite_elim1", _e718);
  _runId[_e734.get()] = 734;
  _e734->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e736 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e737 = mkExprInternal(Kind::APPLY, {_e38, _e736});
  _e738 = mkExprInternal(Kind::APPLY, {_e39, _e737});
  _e739 = mkExprInternal(Kind::APPLY, {_e738, _e32});
  _e740 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e741 = mkExprInternal(Kind::APPLY, {_e39, _e740});
  _e742 = mkExprInternal(Kind::APPLY, {_e741, _e739});
  _e743 = mkExprInternal(Kind::PROOF_TYPE, {_e742});
  _e744 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e745 = mkExprInternal(Kind::APPLY, {_e33, _e740});
  _e746 = mkExprInternal(Kind::APPLY, {_e745, _e744});
  _e747 = mkExprInternal(Kind::APPLY, {_e746, _e736});
  _e748 = mkExprInternal(Kind::APPLY, {_e38, _e747});
  _e749 = mkExprInternal(Kind::PROOF_TYPE, {_e748});
  _e750 = mkExprInternal(Kind::FUNCTION_TYPE, {_e749, _e743});
  _e735 = mkSymbolInternal(Kind::PROOF_RULE, "not_ite_elim2", _e750);
  bind("not_ite_elim2", _e735);
  _runId[_e750.get()] = 750;
  _e750->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e751 = mkSymbolInternal(Kind::PROGRAM_CONST, "lowerNotAnd", _e24);
  _runId[_e751.get()] = 751;
  _e751->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e752 = mkSymbolInternal(Kind::PARAM, "l", _e13);
  _e753 = mkExprInternal(Kind::APPLY, {_e38, _e752});
  _runId[_e753.get()] = 753;
  _e753->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e754 = mkSymbolInternal(Kind::PARAM, "ls", _e13);
  _e755 = mkExprInternal(Kind::APPLY, {_e751, _e754});
  _e756 = mkExprInternal(Kind::APPLY, {_e230, _e39, _e753, _e755});
  bind("lowerNotAnd", _e751);
  _e758 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e759 = mkExprInternal(Kind::APPLY, {_e751, _e758});
  _e760 = mkExprInternal(Kind::PROOF_TYPE, {_e759});
  _e761 = mkExprInternal(Kind::APPLY, {_e38, _e758});
  _e762 = mkExprInternal(Kind::PROOF_TYPE, {_e761});
  _e763 = mkExprInternal(Kind::FUNCTION_TYPE, {_e762, _e760});
  _e757 = mkSymbolInternal(Kind::PROOF_RULE, "not_and", _e763);
  bind("not_and", _e757);
  _runId[_e763.get()] = 763;
  _e763->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e765 = mkSymbolInternal(Kind::PARAM, "Fs", _e13);
  _e766 = mkSymbolInternal(Kind::PARAM, "i", _e125);
  _e767 = mkExprInternal(Kind::APPLY, {_e324, _e44, _e766, _e765});
  _e768 = mkExprInternal(Kind::APPLY, {_e39, _e767});
  _e769 = mkExprInternal(Kind::APPLY, {_e768, _e32});
  _e770 = mkExprInternal(Kind::APPLY, {_e38, _e765});
  _e771 = mkExprInternal(Kind::APPLY, {_e39, _e770});
  _e772 = mkExprInternal(Kind::APPLY, {_e771, _e769});
  _e773 = mkExprInternal(Kind::PROOF_TYPE, {_e772});
  _e774 = mkExprInternal(Kind::QUOTE_TYPE, {_e766});
  _e775 = mkExprInternal(Kind::QUOTE_TYPE, {_e765});
  _e776 = mkExprInternal(Kind::FUNCTION_TYPE, {_e775, _e774, _e773});
  _e764 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_and_pos", _e776);
  bind("cnf_and_pos", _e764);
  _runId[_e776.get()] = 776;
  _e776->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e778 = mkSymbolInternal(Kind::PARAM, "Fs", _e13);
  _e779 = mkExprInternal(Kind::APPLY, {_e751, _e778});
  _e780 = mkExprInternal(Kind::APPLY, {_e230, _e39, _e778, _e779});
  _e781 = mkExprInternal(Kind::PROOF_TYPE, {_e780});
  _e782 = mkExprInternal(Kind::QUOTE_TYPE, {_e778});
  _e783 = mkExprInternal(Kind::FUNCTION_TYPE, {_e782, _e781});
  _e777 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_and_neg", _e783);
  bind("cnf_and_neg", _e777);
  _runId[_e783.get()] = 783;
  _e783->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e785 = mkSymbolInternal(Kind::PARAM, "Fs", _e13);
  _e786 = mkExprInternal(Kind::APPLY, {_e38, _e785});
  _e787 = mkExprInternal(Kind::APPLY, {_e230, _e39, _e786, _e785});
  _e788 = mkExprInternal(Kind::PROOF_TYPE, {_e787});
  _e789 = mkExprInternal(Kind::QUOTE_TYPE, {_e785});
  _e790 = mkExprInternal(Kind::FUNCTION_TYPE, {_e789, _e788});
  _e784 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_or_pos", _e790);
  bind("cnf_or_pos", _e784);
  _runId[_e790.get()] = 790;
  _e790->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e792 = mkSymbolInternal(Kind::PARAM, "Fs", _e13);
  _e793 = mkSymbolInternal(Kind::PARAM, "i", _e125);
  _e794 = mkExprInternal(Kind::APPLY, {_e324, _e39, _e793, _e792});
  _e795 = mkExprInternal(Kind::APPLY, {_e38, _e794});
  _e796 = mkExprInternal(Kind::APPLY, {_e230, _e39, _e795, _e32});
  _e797 = mkExprInternal(Kind::APPLY, {_e261, _e39, _e792, _e796});
  _e798 = mkExprInternal(Kind::PROOF_TYPE, {_e797});
  _e799 = mkExprInternal(Kind::QUOTE_TYPE, {_e793});
  _e800 = mkExprInternal(Kind::QUOTE_TYPE, {_e792});
  _e801 = mkExprInternal(Kind::FUNCTION_TYPE, {_e800, _e799, _e798});
  _e791 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_or_neg", _e801);
  bind("cnf_or_neg", _e791);
  _runId[_e801.get()] = 801;
  _e801->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e803 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e804 = mkExprInternal(Kind::APPLY, {_e39, _e803});
  _e805 = mkExprInternal(Kind::APPLY, {_e804, _e32});
  _e806 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e807 = mkExprInternal(Kind::APPLY, {_e38, _e806});
  _e808 = mkExprInternal(Kind::APPLY, {_e39, _e807});
  _e809 = mkExprInternal(Kind::APPLY, {_e808, _e805});
  _e810 = mkExprInternal(Kind::APPLY, {_e49, _e806});
  _e811 = mkExprInternal(Kind::APPLY, {_e810, _e803});
  _e812 = mkExprInternal(Kind::APPLY, {_e38, _e811});
  _e813 = mkExprInternal(Kind::APPLY, {_e39, _e812});
  _e814 = mkExprInternal(Kind::APPLY, {_e813, _e809});
  _e815 = mkExprInternal(Kind::PROOF_TYPE, {_e814});
  _e816 = mkExprInternal(Kind::QUOTE_TYPE, {_e811});
  _e817 = mkExprInternal(Kind::FUNCTION_TYPE, {_e816, _e815});
  _e802 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_implies_pos", _e817);
  bind("cnf_implies_pos", _e802);
  _runId[_e817.get()] = 817;
  _e817->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e819 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e820 = mkExprInternal(Kind::APPLY, {_e39, _e819});
  _e821 = mkExprInternal(Kind::APPLY, {_e820, _e32});
  _e822 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e823 = mkExprInternal(Kind::APPLY, {_e49, _e819});
  _e824 = mkExprInternal(Kind::APPLY, {_e823, _e822});
  _e825 = mkExprInternal(Kind::APPLY, {_e39, _e824});
  _e826 = mkExprInternal(Kind::APPLY, {_e825, _e821});
  _e827 = mkExprInternal(Kind::PROOF_TYPE, {_e826});
  _e828 = mkExprInternal(Kind::QUOTE_TYPE, {_e824});
  _e829 = mkExprInternal(Kind::FUNCTION_TYPE, {_e828, _e827});
  _e818 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_implies_neg1", _e829);
  bind("cnf_implies_neg1", _e818);
  _runId[_e829.get()] = 829;
  _e829->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e831 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e832 = mkExprInternal(Kind::APPLY, {_e38, _e831});
  _e833 = mkExprInternal(Kind::APPLY, {_e39, _e832});
  _e834 = mkExprInternal(Kind::APPLY, {_e833, _e32});
  _e835 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e836 = mkExprInternal(Kind::APPLY, {_e49, _e835});
  _e837 = mkExprInternal(Kind::APPLY, {_e836, _e831});
  _e838 = mkExprInternal(Kind::APPLY, {_e39, _e837});
  _e839 = mkExprInternal(Kind::APPLY, {_e838, _e834});
  _e840 = mkExprInternal(Kind::PROOF_TYPE, {_e839});
  _e841 = mkExprInternal(Kind::QUOTE_TYPE, {_e837});
  _e842 = mkExprInternal(Kind::FUNCTION_TYPE, {_e841, _e840});
  _e830 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_implies_neg2", _e842);
  bind("cnf_implies_neg2", _e830);
  _runId[_e842.get()] = 842;
  _e842->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e844 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e845 = mkExprInternal(Kind::APPLY, {_e39, _e844});
  _e846 = mkExprInternal(Kind::APPLY, {_e845, _e32});
  _e847 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e848 = mkExprInternal(Kind::APPLY, {_e38, _e847});
  _e849 = mkExprInternal(Kind::APPLY, {_e39, _e848});
  _e850 = mkExprInternal(Kind::APPLY, {_e849, _e846});
  _e851 = mkExprInternal(Kind::APPLY, {_e52, _e847});
  _e852 = mkExprInternal(Kind::APPLY, {_e851, _e844});
  _e853 = mkExprInternal(Kind::APPLY, {_e38, _e852});
  _e854 = mkExprInternal(Kind::APPLY, {_e39, _e853});
  _e855 = mkExprInternal(Kind::APPLY, {_e854, _e850});
  _e856 = mkExprInternal(Kind::PROOF_TYPE, {_e855});
  _e857 = mkExprInternal(Kind::QUOTE_TYPE, {_e852});
  _e858 = mkExprInternal(Kind::FUNCTION_TYPE, {_e857, _e856});
  _e843 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_equiv_pos1", _e858);
  bind("cnf_equiv_pos1", _e843);
  _runId[_e858.get()] = 858;
  _e858->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e860 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e861 = mkExprInternal(Kind::APPLY, {_e38, _e860});
  _e862 = mkExprInternal(Kind::APPLY, {_e39, _e861});
  _e863 = mkExprInternal(Kind::APPLY, {_e862, _e32});
  _e864 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e865 = mkExprInternal(Kind::APPLY, {_e39, _e864});
  _e866 = mkExprInternal(Kind::APPLY, {_e865, _e863});
  _e867 = mkExprInternal(Kind::APPLY, {_e52, _e864});
  _e868 = mkExprInternal(Kind::APPLY, {_e867, _e860});
  _e869 = mkExprInternal(Kind::APPLY, {_e38, _e868});
  _e870 = mkExprInternal(Kind::APPLY, {_e39, _e869});
  _e871 = mkExprInternal(Kind::APPLY, {_e870, _e866});
  _e872 = mkExprInternal(Kind::PROOF_TYPE, {_e871});
  _e873 = mkExprInternal(Kind::QUOTE_TYPE, {_e868});
  _e874 = mkExprInternal(Kind::FUNCTION_TYPE, {_e873, _e872});
  _e859 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_equiv_pos2", _e874);
  bind("cnf_equiv_pos2", _e859);
  _runId[_e874.get()] = 874;
  _e874->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e876 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e877 = mkExprInternal(Kind::APPLY, {_e39, _e876});
  _e878 = mkExprInternal(Kind::APPLY, {_e877, _e32});
  _e879 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e880 = mkExprInternal(Kind::APPLY, {_e39, _e879});
  _e881 = mkExprInternal(Kind::APPLY, {_e880, _e878});
  _e882 = mkExprInternal(Kind::APPLY, {_e52, _e879});
  _e883 = mkExprInternal(Kind::APPLY, {_e882, _e876});
  _e884 = mkExprInternal(Kind::APPLY, {_e39, _e883});
  _e885 = mkExprInternal(Kind::APPLY, {_e884, _e881});
  _e886 = mkExprInternal(Kind::PROOF_TYPE, {_e885});
  _e887 = mkExprInternal(Kind::QUOTE_TYPE, {_e883});
  _e888 = mkExprInternal(Kind::FUNCTION_TYPE, {_e887, _e886});
  _e875 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_equiv_neg1", _e888);
  bind("cnf_equiv_neg1", _e875);
  _runId[_e888.get()] = 888;
  _e888->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e890 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e891 = mkExprInternal(Kind::APPLY, {_e38, _e890});
  _e892 = mkExprInternal(Kind::APPLY, {_e39, _e891});
  _e893 = mkExprInternal(Kind::APPLY, {_e892, _e32});
  _e894 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e895 = mkExprInternal(Kind::APPLY, {_e38, _e894});
  _e896 = mkExprInternal(Kind::APPLY, {_e39, _e895});
  _e897 = mkExprInternal(Kind::APPLY, {_e896, _e893});
  _e898 = mkExprInternal(Kind::APPLY, {_e52, _e894});
  _e899 = mkExprInternal(Kind::APPLY, {_e898, _e890});
  _e900 = mkExprInternal(Kind::APPLY, {_e39, _e899});
  _e901 = mkExprInternal(Kind::APPLY, {_e900, _e897});
  _e902 = mkExprInternal(Kind::PROOF_TYPE, {_e901});
  _e903 = mkExprInternal(Kind::QUOTE_TYPE, {_e899});
  _e904 = mkExprInternal(Kind::FUNCTION_TYPE, {_e903, _e902});
  _e889 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_equiv_neg2", _e904);
  bind("cnf_equiv_neg2", _e889);
  _runId[_e904.get()] = 904;
  _e904->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e906 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e907 = mkExprInternal(Kind::APPLY, {_e39, _e906});
  _e908 = mkExprInternal(Kind::APPLY, {_e907, _e32});
  _e909 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e910 = mkExprInternal(Kind::APPLY, {_e39, _e909});
  _e911 = mkExprInternal(Kind::APPLY, {_e910, _e908});
  _e912 = mkExprInternal(Kind::APPLY, {_e51, _e909});
  _e913 = mkExprInternal(Kind::APPLY, {_e912, _e906});
  _e914 = mkExprInternal(Kind::APPLY, {_e38, _e913});
  _e915 = mkExprInternal(Kind::APPLY, {_e39, _e914});
  _e916 = mkExprInternal(Kind::APPLY, {_e915, _e911});
  _e917 = mkExprInternal(Kind::PROOF_TYPE, {_e916});
  _e918 = mkExprInternal(Kind::QUOTE_TYPE, {_e913});
  _e919 = mkExprInternal(Kind::FUNCTION_TYPE, {_e918, _e917});
  _e905 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_xor_pos1", _e919);
  bind("cnf_xor_pos1", _e905);
  _runId[_e919.get()] = 919;
  _e919->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e921 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e922 = mkExprInternal(Kind::APPLY, {_e38, _e921});
  _e923 = mkExprInternal(Kind::APPLY, {_e39, _e922});
  _e924 = mkExprInternal(Kind::APPLY, {_e923, _e32});
  _e925 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e926 = mkExprInternal(Kind::APPLY, {_e38, _e925});
  _e927 = mkExprInternal(Kind::APPLY, {_e39, _e926});
  _e928 = mkExprInternal(Kind::APPLY, {_e927, _e924});
  _e929 = mkExprInternal(Kind::APPLY, {_e51, _e925});
  _e930 = mkExprInternal(Kind::APPLY, {_e929, _e921});
  _e931 = mkExprInternal(Kind::APPLY, {_e38, _e930});
  _e932 = mkExprInternal(Kind::APPLY, {_e39, _e931});
  _e933 = mkExprInternal(Kind::APPLY, {_e932, _e928});
  _e934 = mkExprInternal(Kind::PROOF_TYPE, {_e933});
  _e935 = mkExprInternal(Kind::QUOTE_TYPE, {_e930});
  _e936 = mkExprInternal(Kind::FUNCTION_TYPE, {_e935, _e934});
  _e920 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_xor_pos2", _e936);
  bind("cnf_xor_pos2", _e920);
  _runId[_e936.get()] = 936;
  _e936->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e938 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e939 = mkExprInternal(Kind::APPLY, {_e39, _e938});
  _e940 = mkExprInternal(Kind::APPLY, {_e939, _e32});
  _e941 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e942 = mkExprInternal(Kind::APPLY, {_e38, _e941});
  _e943 = mkExprInternal(Kind::APPLY, {_e39, _e942});
  _e944 = mkExprInternal(Kind::APPLY, {_e943, _e940});
  _e945 = mkExprInternal(Kind::APPLY, {_e51, _e941});
  _e946 = mkExprInternal(Kind::APPLY, {_e945, _e938});
  _e947 = mkExprInternal(Kind::APPLY, {_e39, _e946});
  _e948 = mkExprInternal(Kind::APPLY, {_e947, _e944});
  _e949 = mkExprInternal(Kind::PROOF_TYPE, {_e948});
  _e950 = mkExprInternal(Kind::QUOTE_TYPE, {_e946});
  _e951 = mkExprInternal(Kind::FUNCTION_TYPE, {_e950, _e949});
  _e937 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_xor_neg1", _e951);
  bind("cnf_xor_neg1", _e937);
  _runId[_e951.get()] = 951;
  _e951->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e953 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e954 = mkExprInternal(Kind::APPLY, {_e38, _e953});
  _e955 = mkExprInternal(Kind::APPLY, {_e39, _e954});
  _e956 = mkExprInternal(Kind::APPLY, {_e955, _e32});
  _e957 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e958 = mkExprInternal(Kind::APPLY, {_e39, _e957});
  _e959 = mkExprInternal(Kind::APPLY, {_e958, _e956});
  _e960 = mkExprInternal(Kind::APPLY, {_e51, _e957});
  _e961 = mkExprInternal(Kind::APPLY, {_e960, _e953});
  _e962 = mkExprInternal(Kind::APPLY, {_e39, _e961});
  _e963 = mkExprInternal(Kind::APPLY, {_e962, _e959});
  _e964 = mkExprInternal(Kind::PROOF_TYPE, {_e963});
  _e965 = mkExprInternal(Kind::QUOTE_TYPE, {_e961});
  _e966 = mkExprInternal(Kind::FUNCTION_TYPE, {_e965, _e964});
  _e952 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_xor_neg2", _e966);
  bind("cnf_xor_neg2", _e952);
  _runId[_e966.get()] = 966;
  _e966->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e968 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e969 = mkExprInternal(Kind::APPLY, {_e39, _e968});
  _e970 = mkExprInternal(Kind::APPLY, {_e969, _e32});
  _e971 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e972 = mkExprInternal(Kind::APPLY, {_e38, _e971});
  _e973 = mkExprInternal(Kind::APPLY, {_e39, _e972});
  _e974 = mkExprInternal(Kind::APPLY, {_e973, _e970});
  _e975 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e976 = mkExprInternal(Kind::APPLY, {_e33, _e971});
  _e977 = mkExprInternal(Kind::APPLY, {_e976, _e968});
  _e978 = mkExprInternal(Kind::APPLY, {_e977, _e975});
  _e979 = mkExprInternal(Kind::APPLY, {_e38, _e978});
  _e980 = mkExprInternal(Kind::APPLY, {_e39, _e979});
  _e981 = mkExprInternal(Kind::APPLY, {_e980, _e974});
  _e982 = mkExprInternal(Kind::PROOF_TYPE, {_e981});
  _e983 = mkExprInternal(Kind::QUOTE_TYPE, {_e978});
  _e984 = mkExprInternal(Kind::FUNCTION_TYPE, {_e983, _e982});
  _e967 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_ite_pos1", _e984);
  bind("cnf_ite_pos1", _e967);
  _runId[_e984.get()] = 984;
  _e984->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e986 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e987 = mkExprInternal(Kind::APPLY, {_e39, _e986});
  _e988 = mkExprInternal(Kind::APPLY, {_e987, _e32});
  _e989 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e990 = mkExprInternal(Kind::APPLY, {_e39, _e989});
  _e991 = mkExprInternal(Kind::APPLY, {_e990, _e988});
  _e992 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e993 = mkExprInternal(Kind::APPLY, {_e33, _e989});
  _e994 = mkExprInternal(Kind::APPLY, {_e993, _e992});
  _e995 = mkExprInternal(Kind::APPLY, {_e994, _e986});
  _e996 = mkExprInternal(Kind::APPLY, {_e38, _e995});
  _e997 = mkExprInternal(Kind::APPLY, {_e39, _e996});
  _e998 = mkExprInternal(Kind::APPLY, {_e997, _e991});
  _e999 = mkExprInternal(Kind::PROOF_TYPE, {_e998});
  _e1000 = mkExprInternal(Kind::QUOTE_TYPE, {_e995});
  _e1001 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1000, _e999});
  _e985 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_ite_pos2", _e1001);
  bind("cnf_ite_pos2", _e985);
  _runId[_e1001.get()] = 1001;
  _e1001->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1003 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e1004 = mkExprInternal(Kind::APPLY, {_e39, _e1003});
  _e1005 = mkExprInternal(Kind::APPLY, {_e1004, _e32});
  _e1006 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e1007 = mkExprInternal(Kind::APPLY, {_e39, _e1006});
  _e1008 = mkExprInternal(Kind::APPLY, {_e1007, _e1005});
  _e1009 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e1010 = mkExprInternal(Kind::APPLY, {_e33, _e1009});
  _e1011 = mkExprInternal(Kind::APPLY, {_e1010, _e1006});
  _e1012 = mkExprInternal(Kind::APPLY, {_e1011, _e1003});
  _e1013 = mkExprInternal(Kind::APPLY, {_e38, _e1012});
  _e1014 = mkExprInternal(Kind::APPLY, {_e39, _e1013});
  _e1015 = mkExprInternal(Kind::APPLY, {_e1014, _e1008});
  _e1016 = mkExprInternal(Kind::PROOF_TYPE, {_e1015});
  _e1017 = mkExprInternal(Kind::QUOTE_TYPE, {_e1012});
  _e1018 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1017, _e1016});
  _e1002 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_ite_pos3", _e1018);
  bind("cnf_ite_pos3", _e1002);
  _runId[_e1018.get()] = 1018;
  _e1018->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1020 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e1021 = mkExprInternal(Kind::APPLY, {_e38, _e1020});
  _e1022 = mkExprInternal(Kind::APPLY, {_e39, _e1021});
  _e1023 = mkExprInternal(Kind::APPLY, {_e1022, _e32});
  _e1024 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e1025 = mkExprInternal(Kind::APPLY, {_e38, _e1024});
  _e1026 = mkExprInternal(Kind::APPLY, {_e39, _e1025});
  _e1027 = mkExprInternal(Kind::APPLY, {_e1026, _e1023});
  _e1028 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e1029 = mkExprInternal(Kind::APPLY, {_e33, _e1024});
  _e1030 = mkExprInternal(Kind::APPLY, {_e1029, _e1020});
  _e1031 = mkExprInternal(Kind::APPLY, {_e1030, _e1028});
  _e1032 = mkExprInternal(Kind::APPLY, {_e39, _e1031});
  _e1033 = mkExprInternal(Kind::APPLY, {_e1032, _e1027});
  _e1034 = mkExprInternal(Kind::PROOF_TYPE, {_e1033});
  _e1035 = mkExprInternal(Kind::QUOTE_TYPE, {_e1031});
  _e1036 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1035, _e1034});
  _e1019 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_ite_neg1", _e1036);
  bind("cnf_ite_neg1", _e1019);
  _runId[_e1036.get()] = 1036;
  _e1036->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1038 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e1039 = mkExprInternal(Kind::APPLY, {_e38, _e1038});
  _e1040 = mkExprInternal(Kind::APPLY, {_e39, _e1039});
  _e1041 = mkExprInternal(Kind::APPLY, {_e1040, _e32});
  _e1042 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e1043 = mkExprInternal(Kind::APPLY, {_e39, _e1042});
  _e1044 = mkExprInternal(Kind::APPLY, {_e1043, _e1041});
  _e1045 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e1046 = mkExprInternal(Kind::APPLY, {_e33, _e1042});
  _e1047 = mkExprInternal(Kind::APPLY, {_e1046, _e1045});
  _e1048 = mkExprInternal(Kind::APPLY, {_e1047, _e1038});
  _e1049 = mkExprInternal(Kind::APPLY, {_e39, _e1048});
  _e1050 = mkExprInternal(Kind::APPLY, {_e1049, _e1044});
  _e1051 = mkExprInternal(Kind::PROOF_TYPE, {_e1050});
  _e1052 = mkExprInternal(Kind::QUOTE_TYPE, {_e1048});
  _e1053 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1052, _e1051});
  _e1037 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_ite_neg2", _e1053);
  bind("cnf_ite_neg2", _e1037);
  _runId[_e1053.get()] = 1053;
  _e1053->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1055 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e1056 = mkExprInternal(Kind::APPLY, {_e38, _e1055});
  _e1057 = mkExprInternal(Kind::APPLY, {_e39, _e1056});
  _e1058 = mkExprInternal(Kind::APPLY, {_e1057, _e32});
  _e1059 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e1060 = mkExprInternal(Kind::APPLY, {_e38, _e1059});
  _e1061 = mkExprInternal(Kind::APPLY, {_e39, _e1060});
  _e1062 = mkExprInternal(Kind::APPLY, {_e1061, _e1058});
  _e1063 = mkSymbolInternal(Kind::PARAM, "C", _e13);
  _e1064 = mkExprInternal(Kind::APPLY, {_e33, _e1063});
  _e1065 = mkExprInternal(Kind::APPLY, {_e1064, _e1059});
  _e1066 = mkExprInternal(Kind::APPLY, {_e1065, _e1055});
  _e1067 = mkExprInternal(Kind::APPLY, {_e39, _e1066});
  _e1068 = mkExprInternal(Kind::APPLY, {_e1067, _e1062});
  _e1069 = mkExprInternal(Kind::PROOF_TYPE, {_e1068});
  _e1070 = mkExprInternal(Kind::QUOTE_TYPE, {_e1066});
  _e1071 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1070, _e1069});
  _e1054 = mkSymbolInternal(Kind::PROOF_RULE, "cnf_ite_neg3", _e1071);
  bind("cnf_ite_neg3", _e1054);
  _runId[_e1071.get()] = 1071;
  _e1071->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1073 = mkSymbolInternal(Kind::PARAM, "Fs", _e13);
  _e1074 = mkExprInternal(Kind::PROOF_TYPE, {_e1073});
  _e1075 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1074, _e521});
  _e1072 = mkSymbolInternal(Kind::PROOF_RULE, "sat_refutation", _e1075);
  bind("sat_refutation", _e1072);
  _runId[_e1075.get()] = 1075;
  _e1075->setFlag(ExprValue::Flag::IS_COMPILED, true);
  markIncluded("/home/andrew/alfc/proofs/rules/Uf.smt2");
  _e1078 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1077 = mkSymbolInternal(Kind::PARAM, "t", _e1078);
  _e1079 = mkExprInternal(Kind::APPLY, {_e52, _e1077});
  _e1080 = mkExprInternal(Kind::APPLY, {_e1079, _e1077});
  _e1081 = mkExprInternal(Kind::PROOF_TYPE, {_e1080});
  _e1082 = mkExprInternal(Kind::QUOTE_TYPE, {_e1077});
  _e1083 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1082, _e1081});
  _e1076 = mkSymbolInternal(Kind::PROOF_RULE, "refl", _e1083);
  bind("refl", _e1076);
  _runId[_e1083.get()] = 1083;
  _e1083->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1084 = mkSymbolInternal(Kind::PROGRAM_CONST, "flipEq", _e24);
  _runId[_e1084.get()] = 1084;
  _e1084->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1086 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1085 = mkSymbolInternal(Kind::PARAM, "t1", _e1086);
  _e1087 = mkSymbolInternal(Kind::PARAM, "t2", _e1086);
  _e1088 = mkExprInternal(Kind::APPLY, {_e52, _e1087});
  _e1089 = mkExprInternal(Kind::APPLY, {_e1088, _e1085});
  _runId[_e1089.get()] = 1089;
  _e1089->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1090 = mkExprInternal(Kind::APPLY, {_e38, _e1089});
  _runId[_e1090.get()] = 1090;
  _e1090->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("flipEq", _e1084);
  _e1092 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e1093 = mkExprInternal(Kind::APPLY, {_e1084, _e1092});
  _e1094 = mkExprInternal(Kind::PROOF_TYPE, {_e1093});
  _e1095 = mkExprInternal(Kind::PROOF_TYPE, {_e1092});
  _e1096 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1095, _e1094});
  _e1091 = mkSymbolInternal(Kind::PROOF_RULE, "symm", _e1096);
  bind("symm", _e1091);
  _runId[_e1096.get()] = 1096;
  _e1096->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1097 = mkSymbolInternal(Kind::PROGRAM_CONST, "mk_trans", _e24);
  _runId[_e1097.get()] = 1097;
  _e1097->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1099 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1098 = mkSymbolInternal(Kind::PARAM, "t2", _e1099);
  _e1100 = mkSymbolInternal(Kind::PARAM, "t1", _e1099);
  _e1101 = mkExprInternal(Kind::APPLY, {_e52, _e1100});
  _e1102 = mkExprInternal(Kind::APPLY, {_e1101, _e1098});
  _runId[_e1102.get()] = 1102;
  _e1102->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1104 = mkExprInternal(Kind::FUNCTION_TYPE, {_e154, _e154});
  _e1105 = mkExprInternal(Kind::FUNCTION_TYPE, {_e154, _e1104});
  _e1106 = mkExprInternal(Kind::FUNCTION_TYPE, {_e154, _e1105});
  _e1107 = mkExprInternal(Kind::FUNCTION_TYPE, {_e154, _e1106});
  _e1103 = mkSymbolInternal(Kind::PROGRAM_CONST, "_internal_1", _e1107);
  _e1108 = mkSymbolInternal(Kind::PARAM, "tail", _e13);
  _e1109 = mkExprInternal(Kind::APPLY, {_e1097, _e1108});
  _e1110 = mkExprInternal(Kind::APPLY, {_e1103, _e1109, _e1100, _e1098, _e1108});
  bind("mk_trans", _e1097);
  _e1112 = mkSymbolInternal(Kind::PARAM, "E", _e13);
  _e1113 = mkExprInternal(Kind::APPLY, {_e1097, _e1112});
  _e1114 = mkExprInternal(Kind::PROOF_TYPE, {_e1113});
  _e1115 = mkExprInternal(Kind::PROOF_TYPE, {_e1112});
  _e1116 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1115, _e1114});
  _e1111 = mkSymbolInternal(Kind::PROOF_RULE, "trans", _e1116);
  bind("trans", _e1111);
  _runId[_e1116.get()] = 1116;
  _e1116->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::PREMISE_LIST].push_back(_e44);
  markAttributes(_e1111, _amap);
  _e1117 = mkSymbolInternal(Kind::PROGRAM_CONST, "mk_cong", _e361);
  _runId[_e1117.get()] = 1117;
  _e1117->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1119 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1120 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1121 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1120, _e1119});
  _e1121->d_type = _e2;
  _e1118 = mkSymbolInternal(Kind::PARAM, "f2", _e1121);
  _e1122 = mkSymbolInternal(Kind::PARAM, "f1", _e1121);
  _e1123 = mkExprInternal(Kind::APPLY, {_e52, _e1122});
  _e1124 = mkExprInternal(Kind::APPLY, {_e1123, _e1118});
  _runId[_e1124.get()] = 1124;
  _e1124->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1125 = mkSymbolInternal(Kind::PARAM, "t2", _e1119);
  _e1126 = mkExprInternal(Kind::APPLY, {_e1118, _e1125});
  _e1127 = mkSymbolInternal(Kind::PARAM, "t1", _e1119);
  _e1128 = mkExprInternal(Kind::APPLY, {_e1122, _e1127});
  _e1129 = mkExprInternal(Kind::APPLY, {_e52, _e1128});
  _e1130 = mkExprInternal(Kind::APPLY, {_e1129, _e1126});
  _runId[_e1130.get()] = 1130;
  _e1130->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1131 = mkSymbolInternal(Kind::PARAM, "tail", _e13);
  _e1132 = mkExprInternal(Kind::APPLY, {_e1117, _e1130, _e1131});
  bind("mk_cong", _e1117);
  _e1134 = mkSymbolInternal(Kind::PARAM, "E", _e13);
  _e1136 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1137 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1138 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1137, _e1136});
  _e1138->d_type = _e2;
  _e1135 = mkSymbolInternal(Kind::PARAM, "f", _e1138);
  _e1139 = mkExprInternal(Kind::APPLY, {_e52, _e1135});
  _e1140 = mkExprInternal(Kind::APPLY, {_e1139, _e1135});
  _e1141 = mkExprInternal(Kind::APPLY, {_e1117, _e1140, _e1134});
  _e1142 = mkExprInternal(Kind::PROOF_TYPE, {_e1141});
  _e1143 = mkExprInternal(Kind::QUOTE_TYPE, {_e1135});
  _e1144 = mkExprInternal(Kind::PROOF_TYPE, {_e1134});
  _e1145 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1144, _e1143, _e1142});
  _e1133 = mkSymbolInternal(Kind::PROOF_RULE, "cong", _e1145);
  bind("cong", _e1133);
  _runId[_e1145.get()] = 1145;
  _e1145->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::PREMISE_LIST].push_back(_e44);
  markAttributes(_e1133, _amap);
  _e1147 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1148 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1147, _e1147});
  _e1148->d_type = _e2;
  _e1149 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1148, _e1147, _e1147, _e13, _e13});
  _e1146 = mkSymbolInternal(Kind::PROGRAM_CONST, "add_nary_arg", _e1149);
  _runId[_e1146.get()] = 1146;
  _e1146->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1150 = mkSymbolInternal(Kind::PARAM, "t2", _e1147);
  _e1151 = mkSymbolInternal(Kind::PARAM, "s2", _e1147);
  _e1152 = mkSymbolInternal(Kind::PARAM, "f", _e1148);
  _e1153 = mkExprInternal(Kind::APPLY, {_e1152, _e1151});
  _e1154 = mkExprInternal(Kind::APPLY, {_e1153, _e1150});
  _e1155 = mkSymbolInternal(Kind::PARAM, "t1", _e1147);
  _e1156 = mkSymbolInternal(Kind::PARAM, "s1", _e1147);
  _e1157 = mkExprInternal(Kind::APPLY, {_e1152, _e1156});
  _e1158 = mkExprInternal(Kind::APPLY, {_e1157, _e1155});
  _e1159 = mkExprInternal(Kind::APPLY, {_e52, _e1158});
  _e1160 = mkExprInternal(Kind::APPLY, {_e1159, _e1154});
  _runId[_e1160.get()] = 1160;
  _e1160->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("add_nary_arg", _e1146);
  _runId[_e1149.get()] = 1149;
  _e1149->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1162 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1163 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1162, _e1162});
  _e1163->d_type = _e2;
  _e1164 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1163, _e13, _e13});
  _e1161 = mkSymbolInternal(Kind::PROGRAM_CONST, "mk_nary_cong_eq", _e1164);
  _runId[_e1161.get()] = 1161;
  _e1161->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1165 = mkExprInternal(Kind::APPLY, {_e52, _e32});
  _e1166 = mkExprInternal(Kind::APPLY, {_e1165, _e32});
  _e1167 = mkSymbolInternal(Kind::PARAM, "s2", _e1162);
  _e1168 = mkSymbolInternal(Kind::PARAM, "s1", _e1162);
  _e1169 = mkExprInternal(Kind::APPLY, {_e52, _e1168});
  _e1170 = mkExprInternal(Kind::APPLY, {_e1169, _e1167});
  _runId[_e1170.get()] = 1170;
  _e1170->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1171 = mkSymbolInternal(Kind::PARAM, "tail", _e13);
  _e1172 = mkSymbolInternal(Kind::PARAM, "f", _e1163);
  _e1173 = mkExprInternal(Kind::APPLY, {_e1161, _e1172, _e1171});
  _e1174 = mkExprInternal(Kind::APPLY, {_e1146, _e1172, _e1168, _e1167, _e1173});
  bind("mk_nary_cong_eq", _e1161);
  _runId[_e1164.get()] = 1164;
  _e1164->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1176 = mkSymbolInternal(Kind::PARAM, "E", _e13);
  _e1178 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1179 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1178, _e1178});
  _e1179->d_type = _e2;
  _e1177 = mkSymbolInternal(Kind::PARAM, "f", _e1179);
  _e1180 = mkExprInternal(Kind::APPLY, {_e1161, _e1177, _e1176});
  _e1181 = mkExprInternal(Kind::PROOF_TYPE, {_e1180});
  _e1182 = mkExprInternal(Kind::QUOTE_TYPE, {_e1177});
  _e1183 = mkExprInternal(Kind::PROOF_TYPE, {_e1176});
  _e1184 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1183, _e1182, _e1181});
  _e1175 = mkSymbolInternal(Kind::PROOF_RULE, "nary_cong", _e1184);
  bind("nary_cong", _e1175);
  _runId[_e1184.get()] = 1184;
  _e1184->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::PREMISE_LIST].push_back(_e44);
  markAttributes(_e1175, _amap);
  _e1186 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e1187 = mkExprInternal(Kind::APPLY, {_e52, _e1186});
  _e1188 = mkExprInternal(Kind::APPLY, {_e1187, _e25});
  _e1189 = mkExprInternal(Kind::PROOF_TYPE, {_e1188});
  _e1190 = mkExprInternal(Kind::PROOF_TYPE, {_e1186});
  _e1191 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1190, _e1189});
  _e1185 = mkSymbolInternal(Kind::PROOF_RULE, "true_intro", _e1191);
  bind("true_intro", _e1185);
  _runId[_e1191.get()] = 1191;
  _e1191->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1193 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e1194 = mkExprInternal(Kind::PROOF_TYPE, {_e1193});
  _e1195 = mkExprInternal(Kind::APPLY, {_e52, _e1193});
  _e1196 = mkExprInternal(Kind::APPLY, {_e1195, _e25});
  _e1197 = mkExprInternal(Kind::PROOF_TYPE, {_e1196});
  _e1198 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1197, _e1194});
  _e1192 = mkSymbolInternal(Kind::PROOF_RULE, "true_elim", _e1198);
  bind("true_elim", _e1192);
  _runId[_e1198.get()] = 1198;
  _e1198->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1200 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e1201 = mkExprInternal(Kind::APPLY, {_e52, _e1200});
  _e1202 = mkExprInternal(Kind::APPLY, {_e1201, _e26});
  _e1203 = mkExprInternal(Kind::PROOF_TYPE, {_e1202});
  _e1204 = mkExprInternal(Kind::APPLY, {_e38, _e1200});
  _e1205 = mkExprInternal(Kind::PROOF_TYPE, {_e1204});
  _e1206 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1205, _e1203});
  _e1199 = mkSymbolInternal(Kind::PROOF_RULE, "false_intro", _e1206);
  bind("false_intro", _e1199);
  _runId[_e1206.get()] = 1206;
  _e1206->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1208 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e1209 = mkExprInternal(Kind::APPLY, {_e38, _e1208});
  _e1210 = mkExprInternal(Kind::PROOF_TYPE, {_e1209});
  _e1211 = mkExprInternal(Kind::APPLY, {_e52, _e1208});
  _e1212 = mkExprInternal(Kind::APPLY, {_e1211, _e26});
  _e1213 = mkExprInternal(Kind::PROOF_TYPE, {_e1212});
  _e1214 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1213, _e1210});
  _e1207 = mkSymbolInternal(Kind::PROOF_RULE, "false_elim", _e1214);
  bind("false_elim", _e1207);
  _runId[_e1214.get()] = 1214;
  _e1214->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1217 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1216 = mkSymbolInternal(Kind::PARAM, "t2", _e1217);
  _e1219 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1220 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1217, _e1219});
  _e1220->d_type = _e2;
  _e1218 = mkSymbolInternal(Kind::PARAM, "g", _e1220);
  _e1221 = mkExprInternal(Kind::APPLY, {_e1218, _e1216});
  _e1222 = mkSymbolInternal(Kind::PARAM, "t1", _e1217);
  _e1223 = mkSymbolInternal(Kind::PARAM, "f", _e1220);
  _e1224 = mkExprInternal(Kind::APPLY, {_e1223, _e1222});
  _e1225 = mkExprInternal(Kind::APPLY, {_e52, _e1224});
  _e1226 = mkExprInternal(Kind::APPLY, {_e1225, _e1221});
  _e1227 = mkExprInternal(Kind::PROOF_TYPE, {_e1226});
  _e1228 = mkExprInternal(Kind::APPLY, {_e52, _e1222});
  _e1229 = mkExprInternal(Kind::APPLY, {_e1228, _e1216});
  _e1230 = mkExprInternal(Kind::PROOF_TYPE, {_e1229});
  _e1231 = mkExprInternal(Kind::APPLY, {_e52, _e1223});
  _e1232 = mkExprInternal(Kind::APPLY, {_e1231, _e1218});
  _e1233 = mkExprInternal(Kind::PROOF_TYPE, {_e1232});
  _e1234 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1233, _e1230, _e1227});
  _e1215 = mkSymbolInternal(Kind::PROOF_RULE, "ho_cong", _e1234);
  bind("ho_cong", _e1215);
  _runId[_e1234.get()] = 1234;
  _e1234->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1237 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1236 = mkSymbolInternal(Kind::PARAM, "t_encoded", _e1237);
  _e1238 = mkSymbolInternal(Kind::PARAM, "t", _e1237);
  _e1239 = mkExprInternal(Kind::APPLY, {_e52, _e1238});
  _e1240 = mkExprInternal(Kind::APPLY, {_e1239, _e1236});
  _e1241 = mkExprInternal(Kind::PROOF_TYPE, {_e1240});
  _e1242 = mkExprInternal(Kind::QUOTE_TYPE, {_e1236});
  _e1243 = mkExprInternal(Kind::QUOTE_TYPE, {_e1238});
  _e1244 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1243, _e1242, _e1241});
  _e1235 = mkSymbolInternal(Kind::PROOF_RULE, "ho_app_encode", _e1244);
  bind("ho_app_encode", _e1235);
  _runId[_e1244.get()] = 1244;
  _e1244->setFlag(ExprValue::Flag::IS_COMPILED, true);
  markIncluded("/home/andrew/alfc/proofs/rules/Arith.smt2");
  markIncluded("/home/andrew/alfc/proofs/programs/Arith.smt2");
  _e1246 = mkSymbolInternal(Kind::PARAM, "S", _e2);
  _e1247 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1248 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1249 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1248, _e1247, _e1246});
  _e1245 = mkSymbolInternal(Kind::PROGRAM_CONST, "arith_rel_sum", _e1249);
  _runId[_e1245.get()] = 1245;
  _e1245->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("arith_rel_sum", _e1245);
  _runId[_e1249.get()] = 1249;
  _e1249->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1251 = mkSymbolInternal(Kind::PARAM, "S", _e2);
  _e1252 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1253 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1252, _e1251});
  _e1250 = mkSymbolInternal(Kind::PROGRAM_CONST, "arith_rel_inv", _e1253);
  _runId[_e1250.get()] = 1250;
  _e1250->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("arith_rel_inv", _e1250);
  _runId[_e1253.get()] = 1253;
  _e1253->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1255 = mkSymbolInternal(Kind::PARAM, "S", _e2);
  _e1256 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1257 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1256, _e1255});
  _e1254 = mkSymbolInternal(Kind::PROGRAM_CONST, "arith_rel_neg", _e1257);
  _runId[_e1254.get()] = 1254;
  _e1254->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("arith_rel_neg", _e1254);
  _runId[_e1257.get()] = 1257;
  _e1257->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1259 = mkSymbolInternal(Kind::PARAM, "S", _e2);
  _e1260 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1261 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1262 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1261, _e1260, _e1259});
  _e1258 = mkSymbolInternal(Kind::PROGRAM_CONST, "arith_rel_trichotomy", _e1262);
  _runId[_e1258.get()] = 1258;
  _e1258->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("arith_rel_trichotomy", _e1258);
  _runId[_e1262.get()] = 1262;
  _e1262->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1263 = mkSymbolInternal(Kind::PROGRAM_CONST, "arith_normalize_lit", _e24);
  _runId[_e1263.get()] = 1263;
  _e1263->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1265 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1264 = mkSymbolInternal(Kind::PARAM, "b", _e1265);
  _e1267 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1266 = mkSymbolInternal(Kind::PARAM, "a", _e1267);
  _e1269 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1265, _e13});
  _e1269->d_type = _e2;
  _e1270 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1267, _e1269});
  _e1270->d_type = _e2;
  _e1268 = mkSymbolInternal(Kind::PARAM, "r", _e1270);
  _e1271 = mkExprInternal(Kind::APPLY, {_e1254, _e1268});
  _e1272 = mkExprInternal(Kind::APPLY, {_e1271, _e1266});
  _e1273 = mkExprInternal(Kind::APPLY, {_e1272, _e1264});
  _e1274 = mkExprInternal(Kind::APPLY, {_e1268, _e1266});
  _e1275 = mkExprInternal(Kind::APPLY, {_e1274, _e1264});
  _runId[_e1275.get()] = 1275;
  _e1275->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("arith_normalize_lit", _e1263);
  _e1276 = mkSymbolInternal(Kind::PROGRAM_CONST, "mk_arith_sum_ub_step", _e361);
  _runId[_e1276.get()] = 1276;
  _e1276->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1278 = mkSymbolInternal(Kind::PARAM, "V", _e2);
  _e1277 = mkSymbolInternal(Kind::PARAM, "b2", _e1278);
  _e1280 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1279 = mkSymbolInternal(Kind::PARAM, "b1", _e1280);
  _e1281 = mkExprInternal(Kind::APPLY, {_e132, _e1279});
  _e1282 = mkExprInternal(Kind::APPLY, {_e1281, _e1277});
  _runId[_e1282.get()] = 1282;
  _e1282->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1284 = mkSymbolInternal(Kind::PARAM, "S", _e2);
  _e1283 = mkSymbolInternal(Kind::PARAM, "a2", _e1284);
  _e1286 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1285 = mkSymbolInternal(Kind::PARAM, "a1", _e1286);
  _e1287 = mkExprInternal(Kind::APPLY, {_e132, _e1285});
  _e1288 = mkExprInternal(Kind::APPLY, {_e1287, _e1283});
  _runId[_e1288.get()] = 1288;
  _e1288->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1290 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1278, _e13});
  _e1290->d_type = _e2;
  _e1291 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1284, _e1290});
  _e1291->d_type = _e2;
  _e1289 = mkSymbolInternal(Kind::PARAM, "r2", _e1291);
  _e1293 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1280, _e13});
  _e1293->d_type = _e2;
  _e1294 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1286, _e1293});
  _e1294->d_type = _e2;
  _e1292 = mkSymbolInternal(Kind::PARAM, "r1", _e1294);
  _e1295 = mkExprInternal(Kind::APPLY, {_e1245, _e1292, _e1289});
  _e1296 = mkExprInternal(Kind::APPLY, {_e1295, _e1288});
  _e1297 = mkExprInternal(Kind::APPLY, {_e1296, _e1282});
  bind("mk_arith_sum_ub_step", _e1276);
  _e1298 = mkSymbolInternal(Kind::PROGRAM_CONST, "mk_arith_sum_ub", _e24);
  _runId[_e1298.get()] = 1298;
  _e1298->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1300 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1299 = mkSymbolInternal(Kind::PARAM, "b", _e1300);
  _e1302 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1301 = mkSymbolInternal(Kind::PARAM, "a", _e1302);
  _e1304 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1300, _e13});
  _e1304->d_type = _e2;
  _e1305 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1302, _e1304});
  _e1305->d_type = _e2;
  _e1303 = mkSymbolInternal(Kind::PARAM, "r", _e1305);
  _e1306 = mkExprInternal(Kind::APPLY, {_e1303, _e1301});
  _e1307 = mkExprInternal(Kind::APPLY, {_e1306, _e1299});
  _runId[_e1307.get()] = 1307;
  _e1307->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1308 = mkSymbolInternal(Kind::PARAM, "tail", _e13);
  _e1309 = mkExprInternal(Kind::APPLY, {_e1298, _e1308});
  _e1310 = mkExprInternal(Kind::APPLY, {_e1276, _e1307, _e1309});
  bind("mk_arith_sum_ub", _e1298);
  _e1312 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e1313 = mkExprInternal(Kind::APPLY, {_e1298, _e1312});
  _e1314 = mkExprInternal(Kind::PROOF_TYPE, {_e1313});
  _e1315 = mkExprInternal(Kind::PROOF_TYPE, {_e1312});
  _e1316 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1315, _e1314});
  _e1311 = mkSymbolInternal(Kind::PROOF_RULE, "arith_sum_ub", _e1316);
  bind("arith_sum_ub", _e1311);
  _runId[_e1316.get()] = 1316;
  _e1316->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::PREMISE_LIST].push_back(_e44);
  markAttributes(_e1311, _amap);
  _e1318 = mkSymbolInternal(Kind::PARAM, "S", _e2);
  _e1319 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1318, _e13, _e13});
  _e1317 = mkSymbolInternal(Kind::PROGRAM_CONST, "mk_arith_mult_pos", _e1319);
  _runId[_e1317.get()] = 1317;
  _e1317->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1321 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1320 = mkSymbolInternal(Kind::PARAM, "b", _e1321);
  _e1322 = mkExprInternal(Kind::APPLY, {_e144, _e1320});
  _e1323 = mkExprInternal(Kind::APPLY, {_e1322, _e32});
  _e1324 = mkSymbolInternal(Kind::PARAM, "m", _e1318);
  _e1325 = mkExprInternal(Kind::APPLY, {_e144, _e1324});
  _e1326 = mkExprInternal(Kind::APPLY, {_e1325, _e1323});
  _e1328 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1327 = mkSymbolInternal(Kind::PARAM, "a", _e1328);
  _e1329 = mkExprInternal(Kind::APPLY, {_e144, _e1327});
  _e1330 = mkExprInternal(Kind::APPLY, {_e1329, _e32});
  _e1331 = mkExprInternal(Kind::APPLY, {_e1325, _e1330});
  _e1333 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1321, _e13});
  _e1333->d_type = _e2;
  _e1334 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1328, _e1333});
  _e1334->d_type = _e2;
  _e1332 = mkSymbolInternal(Kind::PARAM, "r", _e1334);
  _e1335 = mkExprInternal(Kind::APPLY, {_e1332, _e1331});
  _e1336 = mkExprInternal(Kind::APPLY, {_e1335, _e1326});
  _runId[_e1336.get()] = 1336;
  _e1336->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("mk_arith_mult_pos", _e1317);
  _runId[_e1319.get()] = 1319;
  _e1319->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1338 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e1340 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1339 = mkSymbolInternal(Kind::PARAM, "m", _e1340);
  _e1341 = mkExprInternal(Kind::APPLY, {_e1317, _e1339, _e1338});
  _e1342 = mkExprInternal(Kind::APPLY, {_e44, _e1338});
  _e1343 = mkExprInternal(Kind::APPLY, {_e1342, _e32});
  _e1344 = mkExprInternal(Kind::APPLY, {_e171, _e1339});
  _e1345 = mkExprInternal(Kind::APPLY, {_e1344, _e330});
  _e1346 = mkExprInternal(Kind::APPLY, {_e44, _e1345});
  _e1347 = mkExprInternal(Kind::APPLY, {_e1346, _e1343});
  _e1348 = mkExprInternal(Kind::APPLY, {_e49, _e1347});
  _e1349 = mkExprInternal(Kind::APPLY, {_e1348, _e1341});
  _e1350 = mkExprInternal(Kind::PROOF_TYPE, {_e1349});
  _e1351 = mkExprInternal(Kind::QUOTE_TYPE, {_e1338});
  _e1352 = mkExprInternal(Kind::QUOTE_TYPE, {_e1339});
  _e1353 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1352, _e1351, _e1350});
  _e1337 = mkSymbolInternal(Kind::PROOF_RULE, "arith_mult_pos", _e1353);
  bind("arith_mult_pos", _e1337);
  _runId[_e1353.get()] = 1353;
  _e1353->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1355 = mkSymbolInternal(Kind::PARAM, "S", _e2);
  _e1356 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1355, _e13, _e13});
  _e1354 = mkSymbolInternal(Kind::PROGRAM_CONST, "mk_arith_mult_neg", _e1356);
  _runId[_e1354.get()] = 1354;
  _e1354->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1358 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1357 = mkSymbolInternal(Kind::PARAM, "b", _e1358);
  _e1359 = mkExprInternal(Kind::APPLY, {_e144, _e1357});
  _e1360 = mkExprInternal(Kind::APPLY, {_e1359, _e32});
  _e1361 = mkSymbolInternal(Kind::PARAM, "m", _e1355);
  _e1362 = mkExprInternal(Kind::APPLY, {_e144, _e1361});
  _e1363 = mkExprInternal(Kind::APPLY, {_e1362, _e1360});
  _runId[_e1363.get()] = 1363;
  _e1363->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1365 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1364 = mkSymbolInternal(Kind::PARAM, "a", _e1365);
  _e1366 = mkExprInternal(Kind::APPLY, {_e144, _e1364});
  _e1367 = mkExprInternal(Kind::APPLY, {_e1366, _e32});
  _e1368 = mkExprInternal(Kind::APPLY, {_e1362, _e1367});
  _runId[_e1368.get()] = 1368;
  _e1368->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1370 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1358, _e13});
  _e1370->d_type = _e2;
  _e1371 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1365, _e1370});
  _e1371->d_type = _e2;
  _e1369 = mkSymbolInternal(Kind::PARAM, "r", _e1371);
  _e1372 = mkExprInternal(Kind::APPLY, {_e1250, _e1369});
  _e1373 = mkExprInternal(Kind::APPLY, {_e1372, _e1368});
  _e1374 = mkExprInternal(Kind::APPLY, {_e1373, _e1363});
  bind("mk_arith_mult_neg", _e1354);
  _runId[_e1356.get()] = 1356;
  _e1356->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1376 = mkSymbolInternal(Kind::PARAM, "F", _e13);
  _e1378 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1377 = mkSymbolInternal(Kind::PARAM, "m", _e1378);
  _e1379 = mkExprInternal(Kind::APPLY, {_e1354, _e1377, _e1376});
  _e1380 = mkExprInternal(Kind::APPLY, {_e44, _e1376});
  _e1381 = mkExprInternal(Kind::APPLY, {_e1380, _e32});
  _e1382 = mkExprInternal(Kind::APPLY, {_e150, _e1377});
  _e1383 = mkExprInternal(Kind::APPLY, {_e1382, _e330});
  _e1384 = mkExprInternal(Kind::APPLY, {_e44, _e1383});
  _e1385 = mkExprInternal(Kind::APPLY, {_e1384, _e1381});
  _e1386 = mkExprInternal(Kind::APPLY, {_e49, _e1385});
  _e1387 = mkExprInternal(Kind::APPLY, {_e1386, _e1379});
  _e1388 = mkExprInternal(Kind::PROOF_TYPE, {_e1387});
  _e1389 = mkExprInternal(Kind::QUOTE_TYPE, {_e1376});
  _e1390 = mkExprInternal(Kind::QUOTE_TYPE, {_e1377});
  _e1391 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1390, _e1389, _e1388});
  _e1375 = mkSymbolInternal(Kind::PROOF_RULE, "arith_mult_neg", _e1391);
  bind("arith_mult_neg", _e1375);
  _runId[_e1391.get()] = 1391;
  _e1391->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1393 = mkSymbolInternal(Kind::PARAM, "S", _e2);
  _e1394 = mkExprInternal(Kind::FUNCTION_TYPE, {_e13, _e1393, _e13});
  _e1392 = mkSymbolInternal(Kind::PROGRAM_CONST, "mk_arith_trichotomy", _e1394);
  _runId[_e1392.get()] = 1392;
  _e1392->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1396 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1395 = mkSymbolInternal(Kind::PARAM, "b", _e1396);
  _e1398 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1397 = mkSymbolInternal(Kind::PARAM, "a", _e1398);
  _e1400 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1396, _e13});
  _e1400->d_type = _e2;
  _e1401 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1398, _e1400});
  _e1401->d_type = _e2;
  _e1399 = mkSymbolInternal(Kind::PARAM, "r2", _e1401);
  _e1402 = mkSymbolInternal(Kind::PARAM, "r1", _e1401);
  _e1403 = mkExprInternal(Kind::APPLY, {_e1258, _e1402, _e1399});
  _e1404 = mkExprInternal(Kind::APPLY, {_e1403, _e1397});
  _e1405 = mkExprInternal(Kind::APPLY, {_e1404, _e1395});
  bind("mk_arith_trichotomy", _e1392);
  _runId[_e1394.get()] = 1394;
  _e1394->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1407 = mkSymbolInternal(Kind::PARAM, "F2", _e13);
  _e1408 = mkExprInternal(Kind::APPLY, {_e1263, _e1407});
  _e1409 = mkSymbolInternal(Kind::PARAM, "F1", _e13);
  _e1410 = mkExprInternal(Kind::APPLY, {_e1263, _e1409});
  _e1411 = mkExprInternal(Kind::APPLY, {_e1392, _e1410, _e1408});
  _e1412 = mkExprInternal(Kind::PROOF_TYPE, {_e1411});
  _e1413 = mkExprInternal(Kind::PROOF_TYPE, {_e1407});
  _e1414 = mkExprInternal(Kind::PROOF_TYPE, {_e1409});
  _e1415 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1414, _e1413, _e1412});
  _e1406 = mkSymbolInternal(Kind::PROOF_RULE, "arith_trichotomy", _e1415);
  bind("arith_trichotomy", _e1406);
  _runId[_e1415.get()] = 1415;
  _e1415->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1417 = mkSymbolInternal(Kind::PARAM, "c", _e125);
  _e1418 = mkSymbolInternal(Kind::PARAM, "s", _e125);
  _e1419 = mkExprInternal(Kind::APPLY, {_e161, _e1418});
  _e1420 = mkExprInternal(Kind::APPLY, {_e1419, _e1417});
  _e1421 = mkExprInternal(Kind::PROOF_TYPE, {_e1420});
  _e1422 = mkExprInternal(Kind::EVAL_NEG, {_e1417});
  _e1423 = mkSymbolInternal(Kind::PARAM, "t", _e126);
  _e1424 = mkExprInternal(Kind::EVAL_ADD, {_e1423, _e1422});
  _e1425 = mkExprInternal(Kind::APPLY, {_e12, _e1424});
  _e1426 = mkExprInternal(Kind::PAIR, {_e1425, _e25});
  _e1427 = mkExprInternal(Kind::REQUIRES_TYPE, {_e1426, _e1421});
  _e1428 = mkExprInternal(Kind::QUOTE_TYPE, {_e1417});
  _e1429 = mkExprInternal(Kind::APPLY, {_e150, _e1418});
  _e1430 = mkExprInternal(Kind::APPLY, {_e1429, _e1423});
  _e1431 = mkExprInternal(Kind::PROOF_TYPE, {_e1430});
  _e1432 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1431, _e1428, _e1427});
  _e1416 = mkSymbolInternal(Kind::PROOF_RULE, "int_tight_ub", _e1432);
  bind("int_tight_ub", _e1416);
  _runId[_e1432.get()] = 1432;
  _e1432->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1434 = mkSymbolInternal(Kind::PARAM, "c", _e125);
  _e1435 = mkSymbolInternal(Kind::PARAM, "s", _e125);
  _e1436 = mkExprInternal(Kind::APPLY, {_e181, _e1435});
  _e1437 = mkExprInternal(Kind::APPLY, {_e1436, _e1434});
  _e1438 = mkExprInternal(Kind::PROOF_TYPE, {_e1437});
  _e1439 = mkSymbolInternal(Kind::PARAM, "t", _e126);
  _e1440 = mkExprInternal(Kind::EVAL_NEG, {_e1439});
  _e1441 = mkExprInternal(Kind::EVAL_ADD, {_e1434, _e1440});
  _e1442 = mkExprInternal(Kind::APPLY, {_e12, _e1441});
  _e1443 = mkExprInternal(Kind::PAIR, {_e1442, _e25});
  _e1444 = mkExprInternal(Kind::REQUIRES_TYPE, {_e1443, _e1438});
  _e1445 = mkExprInternal(Kind::QUOTE_TYPE, {_e1434});
  _e1446 = mkExprInternal(Kind::APPLY, {_e171, _e1435});
  _e1447 = mkExprInternal(Kind::APPLY, {_e1446, _e1439});
  _e1448 = mkExprInternal(Kind::PROOF_TYPE, {_e1447});
  _e1449 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1448, _e1445, _e1444});
  _e1433 = mkSymbolInternal(Kind::PROOF_RULE, "int_tight_lb", _e1449);
  bind("int_tight_lb", _e1433);
  _runId[_e1449.get()] = 1449;
  _e1449->setFlag(ExprValue::Flag::IS_COMPILED, true);
  markIncluded("/home/andrew/alfc/proofs/rules/Strings.smt2");
  markIncluded("/home/andrew/alfc/proofs/theories/Strings.smt2");
  _e1450 = mkSymbolInternal(Kind::CONST, "String", _e2);
  bind("String", _e1450);
  _e1451 = mkSymbolInternal(Kind::CONST, "RegLan", _e2);
  bind("RegLan", _e1451);
  _e1452 = mkSymbolInternal(Kind::CONST, "Seq", _e3);
  bind("Seq", _e1452);
  d_tc.setLiteralTypeRule(Kind::STRING, _e1450);
  _e1453 = mkSymbolInternal(Kind::PROGRAM_CONST, "is_string_type", _e131);
  _runId[_e1453.get()] = 1453;
  _e1453->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("is_string_type", _e1453);
  _e1455 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1456 = mkExprInternal(Kind::APPLY, {_e1453, _e1455});
  _e1456->d_type = _e13;
  _e1457 = mkExprInternal(Kind::PAIR, {_e1456, _e25});
  _e1457->d_type = _e154;
  _e1458 = mkExprInternal(Kind::REQUIRES_TYPE, {_e1457, _e125});
  _e1458->d_type = _e2;
  _e1459 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1455, _e1458});
  _e1459->d_type = _e2;
  _e1454 = mkSymbolInternal(Kind::CONST, "str.len", _e1459);
  bind("str.len", _e1454);
  _runId[_e1459.get()] = 1459;
  _e1459->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1454, _amap);
  _e1461 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1462 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1463 = mkExprInternal(Kind::APPLY, {_e27, _e1461, _e1462});
  _e1463->d_type = _e2;
  _e1464 = mkExprInternal(Kind::PAIR, {_e1463, _e1461});
  _e1464->d_type = _e154;
  _e1465 = mkExprInternal(Kind::APPLY, {_e1453, _e1461});
  _e1465->d_type = _e13;
  _e1466 = mkExprInternal(Kind::PAIR, {_e1465, _e25});
  _e1466->d_type = _e154;
  _e1467 = mkExprInternal(Kind::REQUIRES_TYPE, {_e1466, _e1464, _e1461});
  _e1467->d_type = _e2;
  _e1468 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1462, _e1467});
  _e1468->d_type = _e2;
  _e1469 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1461, _e1468});
  _e1469->d_type = _e2;
  _e1460 = mkSymbolInternal(Kind::CONST, "str.++", _e1469);
  bind("str.++", _e1460);
  _runId[_e1469.get()] = 1469;
  _e1469->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC_NIL].push_back(nullptr);
  markAttributes(_e1460, _amap);
  _e1471 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1472 = mkExprInternal(Kind::APPLY, {_e1453, _e1471});
  _e1472->d_type = _e13;
  _e1473 = mkExprInternal(Kind::PAIR, {_e1472, _e25});
  _e1473->d_type = _e154;
  _e1474 = mkExprInternal(Kind::REQUIRES_TYPE, {_e1473, _e1471});
  _e1474->d_type = _e2;
  _e1475 = mkExprInternal(Kind::FUNCTION_TYPE, {_e125, _e1474});
  _e1475->d_type = _e2;
  _e1476 = mkExprInternal(Kind::FUNCTION_TYPE, {_e125, _e1475});
  _e1476->d_type = _e2;
  _e1477 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1471, _e1476});
  _e1477->d_type = _e2;
  _e1470 = mkSymbolInternal(Kind::CONST, "str.substr", _e1477);
  bind("str.substr", _e1470);
  _runId[_e1477.get()] = 1477;
  _e1477->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1470, _amap);
  _e1479 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1480 = mkExprInternal(Kind::APPLY, {_e1453, _e1479});
  _e1480->d_type = _e13;
  _e1481 = mkExprInternal(Kind::PAIR, {_e1480, _e25});
  _e1481->d_type = _e154;
  _e1482 = mkExprInternal(Kind::REQUIRES_TYPE, {_e1481, _e13});
  _e1482->d_type = _e2;
  _e1483 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1479, _e1482});
  _e1483->d_type = _e2;
  _e1484 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1479, _e1483});
  _e1484->d_type = _e2;
  _e1478 = mkSymbolInternal(Kind::CONST, "str.contains", _e1484);
  bind("str.contains", _e1478);
  _runId[_e1484.get()] = 1484;
  _e1484->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1478, _amap);
  _e1486 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1487 = mkExprInternal(Kind::APPLY, {_e1453, _e1486});
  _e1487->d_type = _e13;
  _e1488 = mkExprInternal(Kind::PAIR, {_e1487, _e25});
  _e1488->d_type = _e154;
  _e1489 = mkExprInternal(Kind::REQUIRES_TYPE, {_e1488, _e1486});
  _e1489->d_type = _e2;
  _e1490 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1486, _e1489});
  _e1490->d_type = _e2;
  _e1491 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1486, _e1490});
  _e1491->d_type = _e2;
  _e1492 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1486, _e1491});
  _e1492->d_type = _e2;
  _e1485 = mkSymbolInternal(Kind::CONST, "str.replace", _e1492);
  bind("str.replace", _e1485);
  _runId[_e1492.get()] = 1492;
  _e1492->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1485, _amap);
  _e1494 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1495 = mkExprInternal(Kind::APPLY, {_e1453, _e1494});
  _e1495->d_type = _e13;
  _e1496 = mkExprInternal(Kind::PAIR, {_e1495, _e25});
  _e1496->d_type = _e154;
  _e1497 = mkExprInternal(Kind::REQUIRES_TYPE, {_e1496, _e125});
  _e1497->d_type = _e2;
  _e1498 = mkExprInternal(Kind::FUNCTION_TYPE, {_e125, _e1497});
  _e1498->d_type = _e2;
  _e1499 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1494, _e1498});
  _e1499->d_type = _e2;
  _e1500 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1494, _e1499});
  _e1500->d_type = _e2;
  _e1493 = mkSymbolInternal(Kind::CONST, "str.indexof", _e1500);
  bind("str.indexof", _e1493);
  _runId[_e1500.get()] = 1500;
  _e1500->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1493, _amap);
  _e1502 = mkExprInternal(Kind::FUNCTION_TYPE, {_e125, _e1450});
  _e1502->d_type = _e2;
  _e1503 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1450, _e1502});
  _e1503->d_type = _e2;
  _e1501 = mkSymbolInternal(Kind::CONST, "str.at", _e1503);
  bind("str.at", _e1501);
  _runId[_e1503.get()] = 1503;
  _e1503->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e1502.get()] = 1502;
  _e1502->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1501, _amap);
  _e1505 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1450, _e13});
  _e1505->d_type = _e2;
  _e1506 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1450, _e1505});
  _e1506->d_type = _e2;
  _e1504 = mkSymbolInternal(Kind::CONST, "str.prefixof", _e1506);
  bind("str.prefixof", _e1504);
  _runId[_e1506.get()] = 1506;
  _e1506->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e1505.get()] = 1505;
  _e1505->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1504, _amap);
  _e1507 = mkSymbolInternal(Kind::CONST, "str.suffixof", _e1506);
  bind("str.suffixof", _e1507);
  _amap.clear();
  markAttributes(_e1507, _amap);
  _e1509 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1450, _e1450});
  _e1509->d_type = _e2;
  _e1508 = mkSymbolInternal(Kind::CONST, "str.rev", _e1509);
  bind("str.rev", _e1508);
  _runId[_e1509.get()] = 1509;
  _e1509->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1508, _amap);
  _e1510 = mkSymbolInternal(Kind::CONST, "str.unit", _e1502);
  bind("str.unit", _e1510);
  _amap.clear();
  markAttributes(_e1510, _amap);
  _e1512 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1450, _e1509});
  _e1512->d_type = _e2;
  _e1513 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1450, _e1512});
  _e1513->d_type = _e2;
  _e1511 = mkSymbolInternal(Kind::CONST, "str.update", _e1513);
  bind("str.update", _e1511);
  _runId[_e1513.get()] = 1513;
  _e1513->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e1512.get()] = 1512;
  _e1512->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1511, _amap);
  _e1514 = mkSymbolInternal(Kind::CONST, "str.to_lower", _e1509);
  bind("str.to_lower", _e1514);
  _amap.clear();
  markAttributes(_e1514, _amap);
  _e1515 = mkSymbolInternal(Kind::CONST, "str.to_upper", _e1509);
  bind("str.to_upper", _e1515);
  _amap.clear();
  markAttributes(_e1515, _amap);
  _e1517 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1450, _e125});
  _e1517->d_type = _e2;
  _e1516 = mkSymbolInternal(Kind::CONST, "str.to_code", _e1517);
  bind("str.to_code", _e1516);
  _runId[_e1517.get()] = 1517;
  _e1517->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1516, _amap);
  _e1518 = mkSymbolInternal(Kind::CONST, "str.from_code", _e1502);
  bind("str.from_code", _e1518);
  _amap.clear();
  markAttributes(_e1518, _amap);
  _e1519 = mkSymbolInternal(Kind::CONST, "str.is_digit", _e1505);
  bind("str.is_digit", _e1519);
  _amap.clear();
  markAttributes(_e1519, _amap);
  _e1520 = mkSymbolInternal(Kind::CONST, "str.to_int", _e1517);
  bind("str.to_int", _e1520);
  _amap.clear();
  markAttributes(_e1520, _amap);
  _e1521 = mkSymbolInternal(Kind::CONST, "str.from_int", _e1502);
  bind("str.from_int", _e1521);
  _amap.clear();
  markAttributes(_e1521, _amap);
  _e1522 = mkSymbolInternal(Kind::CONST, "str.<", _e1506);
  bind("str.<", _e1522);
  _amap.clear();
  markAttributes(_e1522, _amap);
  _e1523 = mkSymbolInternal(Kind::CONST, "str.<=", _e1506);
  bind("str.<=", _e1523);
  _amap.clear();
  markAttributes(_e1523, _amap);
  _e1524 = mkSymbolInternal(Kind::CONST, "str.replace_all", _e1513);
  bind("str.replace_all", _e1524);
  _amap.clear();
  markAttributes(_e1524, _amap);
  _e1526 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1451, _e1509});
  _e1526->d_type = _e2;
  _e1527 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1450, _e1526});
  _e1527->d_type = _e2;
  _e1525 = mkSymbolInternal(Kind::CONST, "str.replace_re", _e1527);
  bind("str.replace_re", _e1525);
  _runId[_e1527.get()] = 1527;
  _e1527->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e1526.get()] = 1526;
  _e1526->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1525, _amap);
  _e1528 = mkSymbolInternal(Kind::CONST, "str.replace_re_all", _e1527);
  bind("str.replace_re_all", _e1528);
  _amap.clear();
  markAttributes(_e1528, _amap);
  _e1529 = mkSymbolInternal(Kind::CONST, "re.allchar", _e1451);
  bind("re.allchar", _e1529);
  _amap.clear();
  markAttributes(_e1529, _amap);
  _e1530 = mkSymbolInternal(Kind::CONST, "re.none", _e1451);
  bind("re.none", _e1530);
  _amap.clear();
  markAttributes(_e1530, _amap);
  _e1531 = mkSymbolInternal(Kind::CONST, "re.all", _e1451);
  bind("re.all", _e1531);
  _amap.clear();
  markAttributes(_e1531, _amap);
  _e1532 = mkSymbolInternal(Kind::CONST, "re.empty", _e1451);
  bind("re.empty", _e1532);
  _amap.clear();
  markAttributes(_e1532, _amap);
  _e1534 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1450, _e1451});
  _e1534->d_type = _e2;
  _e1533 = mkSymbolInternal(Kind::CONST, "str.to_re", _e1534);
  bind("str.to_re", _e1533);
  _runId[_e1534.get()] = 1534;
  _e1534->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1533, _amap);
  _e1536 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1451, _e1451});
  _e1536->d_type = _e2;
  _e1535 = mkSymbolInternal(Kind::CONST, "re.*", _e1536);
  bind("re.*", _e1535);
  _runId[_e1536.get()] = 1536;
  _e1536->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1535, _amap);
  _e1537 = mkSymbolInternal(Kind::CONST, "re.+", _e1536);
  bind("re.+", _e1537);
  _amap.clear();
  markAttributes(_e1537, _amap);
  _e1538 = mkSymbolInternal(Kind::CONST, "re.opt", _e1536);
  bind("re.opt", _e1538);
  _amap.clear();
  markAttributes(_e1538, _amap);
  _e1539 = mkSymbolInternal(Kind::CONST, "re.comp", _e1536);
  bind("re.comp", _e1539);
  _amap.clear();
  markAttributes(_e1539, _amap);
  _e1541 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1450, _e1534});
  _e1541->d_type = _e2;
  _e1540 = mkSymbolInternal(Kind::CONST, "re.range", _e1541);
  bind("re.range", _e1540);
  _runId[_e1541.get()] = 1541;
  _e1541->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1540, _amap);
  _e1543 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1451, _e1536});
  _e1543->d_type = _e2;
  _e1542 = mkSymbolInternal(Kind::CONST, "re.++", _e1543);
  bind("re.++", _e1542);
  _runId[_e1543.get()] = 1543;
  _e1543->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC_NIL].push_back(nullptr);
  markAttributes(_e1542, _amap);
  _e1545 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1546 = mkExprInternal(Kind::APPLY, {_e27, _e1451, _e1545});
  _e1546->d_type = _e2;
  _e1547 = mkExprInternal(Kind::PAIR, {_e1546, _e1451});
  _e1547->d_type = _e154;
  _e1548 = mkExprInternal(Kind::REQUIRES_TYPE, {_e1547, _e1451});
  _e1548->d_type = _e2;
  _e1549 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1545, _e1548});
  _e1549->d_type = _e2;
  _e1550 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1451, _e1549});
  _e1550->d_type = _e2;
  _e1544 = mkSymbolInternal(Kind::CONST, "re.inter", _e1550);
  bind("re.inter", _e1544);
  _runId[_e1550.get()] = 1550;
  _e1550->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e1549.get()] = 1549;
  _e1549->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC_NIL].push_back(nullptr);
  markAttributes(_e1544, _amap);
  _e1552 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1553 = mkExprInternal(Kind::APPLY, {_e27, _e1451, _e1552});
  _e1553->d_type = _e2;
  _e1554 = mkExprInternal(Kind::PAIR, {_e1553, _e1451});
  _e1554->d_type = _e154;
  _e1555 = mkExprInternal(Kind::REQUIRES_TYPE, {_e1554, _e1451});
  _e1555->d_type = _e2;
  _e1556 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1552, _e1555});
  _e1556->d_type = _e2;
  _e1557 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1451, _e1556});
  _e1557->d_type = _e2;
  _e1551 = mkSymbolInternal(Kind::CONST, "re.union", _e1557);
  bind("re.union", _e1551);
  _runId[_e1557.get()] = 1557;
  _e1557->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e1556.get()] = 1556;
  _e1556->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC_NIL].push_back(nullptr);
  markAttributes(_e1551, _amap);
  _e1559 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1560 = mkExprInternal(Kind::APPLY, {_e27, _e1451, _e1559});
  _e1560->d_type = _e2;
  _e1561 = mkExprInternal(Kind::PAIR, {_e1560, _e1451});
  _e1561->d_type = _e154;
  _e1562 = mkExprInternal(Kind::REQUIRES_TYPE, {_e1561, _e1451});
  _e1562->d_type = _e2;
  _e1563 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1559, _e1562});
  _e1563->d_type = _e2;
  _e1564 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1451, _e1563});
  _e1564->d_type = _e2;
  _e1558 = mkSymbolInternal(Kind::CONST, "re.diff", _e1564);
  bind("re.diff", _e1558);
  _runId[_e1564.get()] = 1564;
  _e1564->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e1563.get()] = 1563;
  _e1563->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  _amap[Attr::RIGHT_ASSOC_NIL].push_back(nullptr);
  markAttributes(_e1558, _amap);
  _e1566 = mkExprInternal(Kind::FUNCTION_TYPE, {_e125, _e1536});
  _e1566->d_type = _e2;
  _e1567 = mkExprInternal(Kind::FUNCTION_TYPE, {_e125, _e1566});
  _e1567->d_type = _e2;
  _e1565 = mkSymbolInternal(Kind::CONST, "re.loop", _e1567);
  bind("re.loop", _e1565);
  _runId[_e1567.get()] = 1567;
  _e1567->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e1566.get()] = 1566;
  _e1566->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1565, _amap);
  _e1569 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1451, _e13});
  _e1569->d_type = _e2;
  _e1570 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1450, _e1569});
  _e1570->d_type = _e2;
  _e1568 = mkSymbolInternal(Kind::CONST, "str.in_re", _e1570);
  bind("str.in_re", _e1568);
  _runId[_e1570.get()] = 1570;
  _e1570->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e1569.get()] = 1569;
  _e1569->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1568, _amap);
  _e1572 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1573 = mkExprInternal(Kind::QUOTE_TYPE, {_e1572});
  _e1573->d_type = _e2;
  _e1574 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1573, _e1572});
  _e1574->d_type = _e2;
  _e1571 = mkSymbolInternal(Kind::CONST, "seq.empty", _e1574);
  bind("seq.empty", _e1571);
  _runId[_e1574.get()] = 1574;
  _e1574->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1571, _amap);
  _e1576 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1577 = mkExprInternal(Kind::APPLY, {_e1452, _e1576});
  _e1577->d_type = _e2;
  _e1578 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1576, _e1577});
  _e1578->d_type = _e2;
  _e1575 = mkSymbolInternal(Kind::CONST, "seq.unit", _e1578);
  bind("seq.unit", _e1575);
  _runId[_e1578.get()] = 1578;
  _e1578->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1575, _amap);
  _e1580 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1581 = mkExprInternal(Kind::APPLY, {_e1452, _e1580});
  _e1581->d_type = _e2;
  _e1582 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1581, _e1580});
  _e1582->d_type = _e2;
  _e1579 = mkSymbolInternal(Kind::CONST, "seq.nth", _e1582);
  bind("seq.nth", _e1579);
  _runId[_e1582.get()] = 1582;
  _e1582->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1579, _amap);
  _e1584 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1585 = mkExprInternal(Kind::APPLY, {_e1452, _e1584});
  _e1585->d_type = _e2;
  _e1586 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1585, _e125});
  _e1586->d_type = _e2;
  _e1583 = mkSymbolInternal(Kind::CONST, "seq.len", _e1586);
  bind("seq.len", _e1583);
  _runId[_e1586.get()] = 1586;
  _e1586->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1583, _amap);
  _e1588 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1451, _e1502});
  _e1588->d_type = _e2;
  _e1589 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1450, _e1588});
  _e1589->d_type = _e2;
  _e1587 = mkSymbolInternal(Kind::CONST, "@k.RE_UNFOLD_POS_COMPONENT", _e1589);
  bind("@k.RE_UNFOLD_POS_COMPONENT", _e1587);
  _runId[_e1589.get()] = 1589;
  _e1589->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _runId[_e1588.get()] = 1588;
  _e1588->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _amap.clear();
  markAttributes(_e1587, _amap);
  markIncluded("/home/andrew/alfc/proofs/programs/Strings.smt2");
  _e1591 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1592 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2, _e1591});
  _e1590 = mkSymbolInternal(Kind::PROGRAM_CONST, "mk_emptystr", _e1592);
  _runId[_e1590.get()] = 1590;
  _e1590->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1593 = mkExprInternal(Kind::APPLY, {_e1452, _e1591});
  _e1594 = mkExprInternal(Kind::APPLY, {_e1571, _e1593});
  _runId[_e1594.get()] = 1594;
  _e1594->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1595 = mkLiteral(Kind::STRING, "");
  bind("mk_emptystr", _e1590);
  _runId[_e1592.get()] = 1592;
  _e1592->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1597 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1598 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1597, _e13});
  _e1596 = mkSymbolInternal(Kind::PROGRAM_CONST, "string_is_empty", _e1598);
  _runId[_e1596.get()] = 1596;
  _e1596->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("string_is_empty", _e1596);
  _runId[_e1598.get()] = 1598;
  _e1598->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1599 = mkSymbolInternal(Kind::PARAM, "n", _e125);
  _e1601 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1600 = mkSymbolInternal(Kind::PARAM, "s", _e1601);
  _e1602 = mkExprInternal(Kind::APPLY, {_e1470, _e1600});
  _e1603 = mkExprInternal(Kind::APPLY, {_e1602, _e330});
  _e1604 = mkExprInternal(Kind::APPLY, {_e1603, _e1599});
  _e1605 = mkExprInternal(Kind::VARIABLE_LIST, {_e1601, _e1600, _e1599});
  _e1606 = mkExprInternal(Kind::LAMBDA, {_e1605, _e1604});
  bind("skolem_prefix", _e1606);
  _e1607 = mkSymbolInternal(Kind::PARAM, "n", _e125);
  _e1609 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1608 = mkSymbolInternal(Kind::PARAM, "s", _e1609);
  _e1610 = mkExprInternal(Kind::APPLY, {_e1454, _e1608});
  _e1611 = mkExprInternal(Kind::APPLY, {_e138, _e1610});
  _e1612 = mkExprInternal(Kind::APPLY, {_e1611, _e1607});
  _e1613 = mkExprInternal(Kind::APPLY, {_e1470, _e1608});
  _e1614 = mkExprInternal(Kind::APPLY, {_e1613, _e1607});
  _e1615 = mkExprInternal(Kind::APPLY, {_e1614, _e1612});
  _e1616 = mkExprInternal(Kind::VARIABLE_LIST, {_e1609, _e1608, _e1607});
  _e1617 = mkExprInternal(Kind::LAMBDA, {_e1616, _e1615});
  bind("skolem_suffix_rem", _e1617);
  _e1619 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1618 = mkSymbolInternal(Kind::PARAM, "t", _e1619);
  _e1620 = mkSymbolInternal(Kind::PARAM, "s", _e1619);
  _e1621 = mkExprInternal(Kind::APPLY, {_e1493, _e1620});
  _e1622 = mkExprInternal(Kind::APPLY, {_e1621, _e1618});
  _e1623 = mkExprInternal(Kind::APPLY, {_e1622, _e330});
  _e1624 = mkExprInternal(Kind::APPLY, {_e1470, _e1620});
  _e1625 = mkExprInternal(Kind::APPLY, {_e1624, _e330});
  _e1626 = mkExprInternal(Kind::APPLY, {_e1625, _e1623});
  _e1627 = mkExprInternal(Kind::VARIABLE_LIST, {_e1619, _e1620, _e1618});
  _e1628 = mkExprInternal(Kind::LAMBDA, {_e1627, _e1626});
  bind("skolem_first_ctn_pre", _e1628);
  _e1630 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1629 = mkSymbolInternal(Kind::PARAM, "t", _e1630);
  _e1631 = mkExprInternal(Kind::APPLY, {_e1454, _e1629});
  _e1632 = mkExprInternal(Kind::APPLY, {_e132, _e1631});
  _e1633 = mkExprInternal(Kind::APPLY, {_e1632, _e32});
  _e1634 = mkSymbolInternal(Kind::PARAM, "s", _e1630);
  _e1635 = mkExprInternal(Kind::APPLY, {_e1493, _e1634});
  _e1636 = mkExprInternal(Kind::APPLY, {_e1635, _e1629});
  _e1637 = mkExprInternal(Kind::APPLY, {_e1636, _e330});
  _e1638 = mkExprInternal(Kind::APPLY, {_e1470, _e1634});
  _e1639 = mkExprInternal(Kind::APPLY, {_e1638, _e330});
  _e1640 = mkExprInternal(Kind::APPLY, {_e1639, _e1637});
  _e1641 = mkExprInternal(Kind::APPLY, {_e66, _e1640});
  _e1642 = mkExprInternal(Kind::APPLY, {_e1454, _e1641});
  _e1643 = mkExprInternal(Kind::APPLY, {_e132, _e1642});
  _e1644 = mkExprInternal(Kind::APPLY, {_e1643, _e1633});
  _e1645 = mkExprInternal(Kind::APPLY, {_e1454, _e1634});
  _e1646 = mkExprInternal(Kind::APPLY, {_e138, _e1645});
  _e1647 = mkExprInternal(Kind::APPLY, {_e1646, _e1644});
  _e1648 = mkExprInternal(Kind::APPLY, {_e1638, _e1644});
  _e1649 = mkExprInternal(Kind::APPLY, {_e1648, _e1647});
  _e1650 = mkExprInternal(Kind::VARIABLE_LIST, {_e1630, _e1634, _e1629});
  _e1651 = mkExprInternal(Kind::LAMBDA, {_e1650, _e1649});
  bind("skolem_first_ctn_post", _e1651);
  _e1653 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e1654 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1653, _e1653, _e1653});
  _e1652 = mkSymbolInternal(Kind::PROGRAM_CONST, "string_concat", _e1654);
  _runId[_e1652.get()] = 1652;
  _e1652->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1655 = mkSymbolInternal(Kind::PARAM, "t2", _e1653);
  _e1656 = mkSymbolInternal(Kind::PARAM, "t1", _e1653);
  _e1657 = mkExprInternal(Kind::APPLY, {_e261, _e1460, _e1656, _e1655});
  bind("string_concat", _e1652);
  _runId[_e1654.get()] = 1654;
  _e1654->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1659 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1658 = mkSymbolInternal(Kind::PARAM, "t", _e1659);
  _e1660 = mkExprInternal(Kind::APPLY, {_e294, _e1460, _e1658});
  _e1661 = mkSymbolInternal(Kind::PARAM, "rev", _e13);
  _e1662 = mkExprInternal(Kind::EVAL_IF_THEN_ELSE, {_e1661, _e1660, _e1658});
  _e1663 = mkExprInternal(Kind::VARIABLE_LIST, {_e1659, _e1661, _e1658});
  _e1664 = mkExprInternal(Kind::LAMBDA, {_e1663, _e1662});
  bind("string_rev", _e1664);
  _e1666 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1667 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1666, _e125, _e125, _e2, _e13});
  _e1665 = mkSymbolInternal(Kind::PROGRAM_CONST, "string_reduction_substr", _e1667);
  _runId[_e1665.get()] = 1665;
  _e1665->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1668 = mkSymbolInternal(Kind::PARAM, "m", _e125);
  _e1669 = mkSymbolInternal(Kind::PARAM, "n", _e125);
  _e1670 = mkSymbolInternal(Kind::PARAM, "x", _e1666);
  _e1671 = mkExprInternal(Kind::APPLY, {_e1470, _e1670});
  _e1672 = mkExprInternal(Kind::APPLY, {_e1671, _e1669});
  _e1673 = mkExprInternal(Kind::APPLY, {_e1672, _e1668});
  _e1674 = mkExprInternal(Kind::APPLY, {_e66, _e1673});
  _e1675 = mkExprInternal(Kind::APPLY, {_e52, _e1674});
  _runId[_e1675.get()] = 1675;
  _e1675->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1676 = mkExprInternal(Kind::APPLY, {_e1454, _e1674});
  _e1677 = mkExprInternal(Kind::APPLY, {_e161, _e1676});
  _e1678 = mkExprInternal(Kind::APPLY, {_e1677, _e1668});
  _e1679 = mkExprInternal(Kind::APPLY, {_e44, _e1678});
  _e1680 = mkExprInternal(Kind::APPLY, {_e1679, _e32});
  _e1681 = mkExprInternal(Kind::APPLY, {_e132, _e1668});
  _e1682 = mkExprInternal(Kind::APPLY, {_e1681, _e32});
  _e1683 = mkExprInternal(Kind::APPLY, {_e132, _e1669});
  _e1684 = mkExprInternal(Kind::APPLY, {_e1683, _e1682});
  _e1685 = mkExprInternal(Kind::APPLY, {_e1454, _e1670});
  _e1686 = mkExprInternal(Kind::APPLY, {_e138, _e1685});
  _e1687 = mkExprInternal(Kind::APPLY, {_e1686, _e1684});
  _e1688 = mkExprInternal(Kind::APPLY, {_e1671, _e1684});
  _e1689 = mkExprInternal(Kind::APPLY, {_e1688, _e1687});
  _e1690 = mkExprInternal(Kind::APPLY, {_e66, _e1689});
  _e1691 = mkExprInternal(Kind::APPLY, {_e1454, _e1690});
  _e1692 = mkExprInternal(Kind::APPLY, {_e52, _e1691});
  _e1693 = mkExprInternal(Kind::APPLY, {_e1692, _e330});
  _e1694 = mkExprInternal(Kind::APPLY, {_e39, _e1693});
  _e1695 = mkExprInternal(Kind::APPLY, {_e1694, _e32});
  _e1696 = mkExprInternal(Kind::APPLY, {_e1692, _e1687});
  _e1697 = mkExprInternal(Kind::APPLY, {_e39, _e1696});
  _e1698 = mkExprInternal(Kind::APPLY, {_e1697, _e1695});
  _e1699 = mkExprInternal(Kind::APPLY, {_e44, _e1698});
  _e1700 = mkExprInternal(Kind::APPLY, {_e1699, _e1680});
  _e1701 = mkExprInternal(Kind::APPLY, {_e1671, _e330});
  _e1702 = mkExprInternal(Kind::APPLY, {_e1701, _e1669});
  _e1703 = mkExprInternal(Kind::APPLY, {_e66, _e1702});
  _e1704 = mkExprInternal(Kind::APPLY, {_e1454, _e1703});
  _e1705 = mkExprInternal(Kind::APPLY, {_e52, _e1704});
  _e1706 = mkExprInternal(Kind::APPLY, {_e1705, _e1669});
  _e1707 = mkExprInternal(Kind::APPLY, {_e44, _e1706});
  _e1708 = mkExprInternal(Kind::APPLY, {_e1707, _e1700});
  _e1709 = mkExprInternal(Kind::APPLY, {_e1460, _e1690});
  _e1710 = mkExprInternal(Kind::APPLY, {_e1709, _e32});
  _e1711 = mkExprInternal(Kind::APPLY, {_e1460, _e1674});
  _e1712 = mkExprInternal(Kind::APPLY, {_e1711, _e1710});
  _e1713 = mkExprInternal(Kind::APPLY, {_e1460, _e1703});
  _e1714 = mkExprInternal(Kind::APPLY, {_e1713, _e1712});
  _e1715 = mkExprInternal(Kind::APPLY, {_e52, _e1670});
  _e1716 = mkExprInternal(Kind::APPLY, {_e1715, _e1714});
  _e1717 = mkExprInternal(Kind::APPLY, {_e44, _e1716});
  _e1718 = mkExprInternal(Kind::APPLY, {_e1717, _e1708});
  _e1719 = mkExprInternal(Kind::APPLY, {_e171, _e1668});
  _e1720 = mkExprInternal(Kind::APPLY, {_e1719, _e330});
  _e1721 = mkExprInternal(Kind::APPLY, {_e44, _e1720});
  _e1722 = mkExprInternal(Kind::APPLY, {_e1721, _e32});
  _e1723 = mkExprInternal(Kind::APPLY, {_e171, _e1685});
  _e1724 = mkExprInternal(Kind::APPLY, {_e1723, _e1669});
  _e1725 = mkExprInternal(Kind::APPLY, {_e44, _e1724});
  _e1726 = mkExprInternal(Kind::APPLY, {_e1725, _e1722});
  _e1727 = mkExprInternal(Kind::APPLY, {_e181, _e1669});
  _e1728 = mkExprInternal(Kind::APPLY, {_e1727, _e330});
  _e1729 = mkExprInternal(Kind::APPLY, {_e44, _e1728});
  _e1730 = mkExprInternal(Kind::APPLY, {_e1729, _e1726});
  _e1731 = mkExprInternal(Kind::APPLY, {_e33, _e1730});
  _e1732 = mkExprInternal(Kind::APPLY, {_e1731, _e1718});
  _runId[_e1732.get()] = 1732;
  _e1732->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1733 = mkExprInternal(Kind::APPLY, {_e1590, _e1666});
  _e1734 = mkExprInternal(Kind::APPLY, {_e1675, _e1733});
  _e1735 = mkExprInternal(Kind::APPLY, {_e1732, _e1734});
  bind("string_reduction_substr", _e1665);
  _runId[_e1667.get()] = 1667;
  _e1667->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1737 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1738 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1737, _e1737, _e125, _e2, _e13});
  _e1736 = mkSymbolInternal(Kind::PROGRAM_CONST, "string_reduction_indexof", _e1738);
  _runId[_e1736.get()] = 1736;
  _e1736->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1739 = mkSymbolInternal(Kind::PARAM, "y", _e1737);
  _e1740 = mkSymbolInternal(Kind::PARAM, "n", _e125);
  _e1741 = mkSymbolInternal(Kind::PARAM, "x", _e1737);
  _e1742 = mkExprInternal(Kind::APPLY, {_e1454, _e1741});
  _e1743 = mkExprInternal(Kind::APPLY, {_e138, _e1742});
  _e1744 = mkExprInternal(Kind::APPLY, {_e1743, _e1740});
  _e1745 = mkExprInternal(Kind::APPLY, {_e1470, _e1741});
  _e1746 = mkExprInternal(Kind::APPLY, {_e1745, _e1740});
  _e1747 = mkExprInternal(Kind::APPLY, {_e1746, _e1744});
  _e1748 = mkExprInternal(Kind::APPLY, {_e1493, _e1747});
  _e1749 = mkExprInternal(Kind::APPLY, {_e1748, _e1739});
  _e1750 = mkExprInternal(Kind::APPLY, {_e1749, _e330});
  _e1751 = mkExprInternal(Kind::APPLY, {_e1470, _e1747});
  _e1752 = mkExprInternal(Kind::APPLY, {_e1751, _e330});
  _e1753 = mkExprInternal(Kind::APPLY, {_e1752, _e1750});
  _e1754 = mkExprInternal(Kind::APPLY, {_e66, _e1753});
  _e1755 = mkExprInternal(Kind::APPLY, {_e1454, _e1754});
  _e1756 = mkExprInternal(Kind::APPLY, {_e132, _e1755});
  _e1757 = mkExprInternal(Kind::APPLY, {_e1756, _e32});
  _e1758 = mkExprInternal(Kind::APPLY, {_e132, _e1740});
  _e1759 = mkExprInternal(Kind::APPLY, {_e1758, _e1757});
  _e1760 = mkExprInternal(Kind::APPLY, {_e1493, _e1741});
  _e1761 = mkExprInternal(Kind::APPLY, {_e1760, _e1739});
  _e1762 = mkExprInternal(Kind::APPLY, {_e1761, _e1740});
  _e1763 = mkExprInternal(Kind::APPLY, {_e66, _e1762});
  _e1764 = mkExprInternal(Kind::APPLY, {_e52, _e1763});
  _e1765 = mkExprInternal(Kind::APPLY, {_e1764, _e1759});
  _e1766 = mkExprInternal(Kind::APPLY, {_e44, _e1765});
  _e1767 = mkExprInternal(Kind::APPLY, {_e1766, _e32});
  _e1768 = mkLiteral(Kind::NUMERAL, "1");
  _e1769 = mkExprInternal(Kind::APPLY, {_e1454, _e1739});
  _e1770 = mkExprInternal(Kind::APPLY, {_e138, _e1769});
  _e1771 = mkExprInternal(Kind::APPLY, {_e1770, _e1768});
  _e1772 = mkExprInternal(Kind::APPLY, {_e1470, _e1739});
  _e1773 = mkExprInternal(Kind::APPLY, {_e1772, _e330});
  _e1774 = mkExprInternal(Kind::APPLY, {_e1773, _e1771});
  _e1775 = mkExprInternal(Kind::APPLY, {_e1460, _e1774});
  _e1776 = mkExprInternal(Kind::APPLY, {_e1775, _e32});
  _e1777 = mkExprInternal(Kind::APPLY, {_e1460, _e1754});
  _e1778 = mkExprInternal(Kind::APPLY, {_e1777, _e1776});
  _e1779 = mkExprInternal(Kind::APPLY, {_e1478, _e1778});
  _e1780 = mkExprInternal(Kind::APPLY, {_e1779, _e1739});
  _e1781 = mkExprInternal(Kind::APPLY, {_e38, _e1780});
  _e1782 = mkExprInternal(Kind::APPLY, {_e44, _e1781});
  _e1783 = mkExprInternal(Kind::APPLY, {_e1782, _e1767});
  _e1784 = mkExprInternal(Kind::APPLY, {_e132, _e1769});
  _e1785 = mkExprInternal(Kind::APPLY, {_e1784, _e32});
  _e1786 = mkExprInternal(Kind::APPLY, {_e1756, _e1785});
  _e1787 = mkExprInternal(Kind::APPLY, {_e1454, _e1747});
  _e1788 = mkExprInternal(Kind::APPLY, {_e138, _e1787});
  _e1789 = mkExprInternal(Kind::APPLY, {_e1788, _e1786});
  _e1790 = mkExprInternal(Kind::APPLY, {_e1751, _e1786});
  _e1791 = mkExprInternal(Kind::APPLY, {_e1790, _e1789});
  _e1792 = mkExprInternal(Kind::APPLY, {_e66, _e1791});
  _e1793 = mkExprInternal(Kind::APPLY, {_e1460, _e1792});
  _e1794 = mkExprInternal(Kind::APPLY, {_e1793, _e32});
  _e1795 = mkExprInternal(Kind::APPLY, {_e1460, _e1739});
  _e1796 = mkExprInternal(Kind::APPLY, {_e1795, _e1794});
  _e1797 = mkExprInternal(Kind::APPLY, {_e1777, _e1796});
  _e1798 = mkExprInternal(Kind::APPLY, {_e52, _e1747});
  _e1799 = mkExprInternal(Kind::APPLY, {_e1798, _e1797});
  _e1800 = mkExprInternal(Kind::APPLY, {_e44, _e1799});
  _e1801 = mkExprInternal(Kind::APPLY, {_e1800, _e1783});
  _runId[_e1801.get()] = 1801;
  _e1801->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1802 = mkExprInternal(Kind::APPLY, {_e1764, _e1740});
  _runId[_e1802.get()] = 1802;
  _e1802->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1803 = mkExprInternal(Kind::APPLY, {_e52, _e1739});
  _runId[_e1803.get()] = 1803;
  _e1803->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1804 = mkExprInternal(Kind::APPLY, {_e1764, _e332});
  _e1805 = mkExprInternal(Kind::APPLY, {_e171, _e330});
  _e1806 = mkExprInternal(Kind::APPLY, {_e1805, _e1740});
  _e1807 = mkExprInternal(Kind::APPLY, {_e39, _e1806});
  _e1808 = mkExprInternal(Kind::APPLY, {_e1807, _e32});
  _e1809 = mkExprInternal(Kind::APPLY, {_e171, _e1740});
  _e1810 = mkExprInternal(Kind::APPLY, {_e1809, _e1742});
  _e1811 = mkExprInternal(Kind::APPLY, {_e39, _e1810});
  _e1812 = mkExprInternal(Kind::APPLY, {_e1811, _e1808});
  _e1813 = mkExprInternal(Kind::APPLY, {_e1478, _e1747});
  _e1814 = mkExprInternal(Kind::APPLY, {_e1813, _e1739});
  _e1815 = mkExprInternal(Kind::APPLY, {_e38, _e1814});
  _e1816 = mkExprInternal(Kind::APPLY, {_e39, _e1815});
  _e1817 = mkExprInternal(Kind::APPLY, {_e1816, _e1812});
  _e1818 = mkExprInternal(Kind::APPLY, {_e33, _e1817});
  _e1819 = mkExprInternal(Kind::APPLY, {_e1818, _e1804});
  _runId[_e1819.get()] = 1819;
  _e1819->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1820 = mkExprInternal(Kind::APPLY, {_e1590, _e1737});
  _e1821 = mkExprInternal(Kind::APPLY, {_e1803, _e1820});
  _e1822 = mkExprInternal(Kind::APPLY, {_e33, _e1821});
  _e1823 = mkExprInternal(Kind::APPLY, {_e1822, _e1802});
  _e1824 = mkExprInternal(Kind::APPLY, {_e1823, _e1801});
  _e1825 = mkExprInternal(Kind::APPLY, {_e1819, _e1824});
  bind("string_reduction_indexof", _e1736);
  _runId[_e1738.get()] = 1738;
  _e1738->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1827 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1828 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1827, _e2, _e13});
  _e1826 = mkSymbolInternal(Kind::PROGRAM_CONST, "string_reduction_pred", _e1828);
  _runId[_e1826.get()] = 1826;
  _e1826->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1829 = mkSymbolInternal(Kind::PARAM, "m", _e125);
  _e1830 = mkSymbolInternal(Kind::PARAM, "n", _e125);
  _e1831 = mkSymbolInternal(Kind::PARAM, "x", _e1827);
  _e1832 = mkExprInternal(Kind::APPLY, {_e1665, _e1831, _e1830, _e1829, _e1827});
  _e1833 = mkSymbolInternal(Kind::PARAM, "y", _e1827);
  _e1834 = mkExprInternal(Kind::APPLY, {_e1736, _e1831, _e1833, _e1830, _e1827});
  bind("string_reduction_pred", _e1826);
  _runId[_e1828.get()] = 1828;
  _e1828->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1836 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1837 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1836, _e1836, _e2, _e13});
  _e1835 = mkSymbolInternal(Kind::PROGRAM_CONST, "string_eager_reduction_contains", _e1837);
  _runId[_e1835.get()] = 1835;
  _e1835->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1838 = mkSymbolInternal(Kind::PARAM, "r", _e1836);
  _e1839 = mkSymbolInternal(Kind::PARAM, "t", _e1836);
  _e1840 = mkExprInternal(Kind::APPLY, {_e52, _e1839});
  _e1841 = mkExprInternal(Kind::APPLY, {_e1840, _e1838});
  _e1842 = mkExprInternal(Kind::APPLY, {_e38, _e1841});
  _e1843 = mkExprInternal(Kind::APPLY, {_e1454, _e1838});
  _e1844 = mkExprInternal(Kind::APPLY, {_e132, _e1843});
  _e1845 = mkExprInternal(Kind::APPLY, {_e1844, _e32});
  _e1846 = mkExprInternal(Kind::APPLY, {_e1493, _e1839});
  _e1847 = mkExprInternal(Kind::APPLY, {_e1846, _e1838});
  _e1848 = mkExprInternal(Kind::APPLY, {_e1847, _e330});
  _e1849 = mkExprInternal(Kind::APPLY, {_e1470, _e1839});
  _e1850 = mkExprInternal(Kind::APPLY, {_e1849, _e330});
  _e1851 = mkExprInternal(Kind::APPLY, {_e1850, _e1848});
  _e1852 = mkExprInternal(Kind::APPLY, {_e66, _e1851});
  _e1853 = mkExprInternal(Kind::APPLY, {_e1454, _e1852});
  _e1854 = mkExprInternal(Kind::APPLY, {_e132, _e1853});
  _e1855 = mkExprInternal(Kind::APPLY, {_e1854, _e1845});
  _e1856 = mkExprInternal(Kind::APPLY, {_e1454, _e1839});
  _e1857 = mkExprInternal(Kind::APPLY, {_e138, _e1856});
  _e1858 = mkExprInternal(Kind::APPLY, {_e1857, _e1855});
  _e1859 = mkExprInternal(Kind::APPLY, {_e1849, _e1855});
  _e1860 = mkExprInternal(Kind::APPLY, {_e1859, _e1858});
  _e1861 = mkExprInternal(Kind::APPLY, {_e66, _e1860});
  _e1862 = mkExprInternal(Kind::APPLY, {_e1460, _e1861});
  _e1863 = mkExprInternal(Kind::APPLY, {_e1862, _e32});
  _e1864 = mkExprInternal(Kind::APPLY, {_e1460, _e1838});
  _e1865 = mkExprInternal(Kind::APPLY, {_e1864, _e1863});
  _e1866 = mkExprInternal(Kind::APPLY, {_e1460, _e1852});
  _e1867 = mkExprInternal(Kind::APPLY, {_e1866, _e1865});
  _e1868 = mkExprInternal(Kind::APPLY, {_e1840, _e1867});
  _e1869 = mkExprInternal(Kind::APPLY, {_e1478, _e1839});
  _e1870 = mkExprInternal(Kind::APPLY, {_e1869, _e1838});
  _e1871 = mkExprInternal(Kind::APPLY, {_e33, _e1870});
  _e1872 = mkExprInternal(Kind::APPLY, {_e1871, _e1868});
  _e1873 = mkExprInternal(Kind::APPLY, {_e1872, _e1842});
  _runId[_e1873.get()] = 1873;
  _e1873->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("string_eager_reduction_contains", _e1835);
  _runId[_e1837.get()] = 1837;
  _e1837->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1874 = mkSymbolInternal(Kind::PARAM, "s", _e1450);
  _e1875 = mkExprInternal(Kind::APPLY, {_e1516, _e1874});
  _e1875->d_type = _e125;
  _e1876 = mkExprInternal(Kind::APPLY, {_e52, _e1875});
  _e1876->d_type = _e228;
  _e1877 = mkExprInternal(Kind::APPLY, {_e1876, _e332});
  _e1877->d_type = _e13;
  _e1878 = mkLiteral(Kind::NUMERAL, "196608");
  _e1880 = mkExprInternal(Kind::PAIR, {_e25, _e25});
  _e1881 = mkExprInternal(Kind::REQUIRES_TYPE, {_e1880, _e153, _e13});
  _e1882 = mkExprInternal(Kind::FUNCTION_TYPE, {_e151, _e1881});
  _e1879 = mkExprInternal(Kind::APPLY, {_e150, _e1875});
  _e1879->d_type = _e1882;
  _e1883 = mkExprInternal(Kind::APPLY, {_e1879, _e1878});
  _e1883->d_type = _e13;
  _e1884 = mkExprInternal(Kind::APPLY, {_e44, _e1883});
  _e1884->d_type = _e47;
  _e1885 = mkExprInternal(Kind::APPLY, {_e1884, _e32});
  _e1885->d_type = _e13;
  _e1887 = mkExprInternal(Kind::REQUIRES_TYPE, {_e1880, _e184, _e13});
  _e1888 = mkExprInternal(Kind::FUNCTION_TYPE, {_e182, _e1887});
  _e1886 = mkExprInternal(Kind::APPLY, {_e181, _e1875});
  _e1886->d_type = _e1888;
  _e1889 = mkExprInternal(Kind::APPLY, {_e1886, _e330});
  _e1889->d_type = _e13;
  _e1890 = mkExprInternal(Kind::APPLY, {_e44, _e1889});
  _e1890->d_type = _e47;
  _e1891 = mkExprInternal(Kind::APPLY, {_e1890, _e1885});
  _e1891->d_type = _e13;
  _e1892 = mkExprInternal(Kind::APPLY, {_e1454, _e1874});
  _e1892->d_type = _e125;
  _e1893 = mkExprInternal(Kind::APPLY, {_e52, _e1892});
  _e1893->d_type = _e228;
  _e1894 = mkExprInternal(Kind::APPLY, {_e1893, _e1768});
  _e1894->d_type = _e13;
  _e1895 = mkExprInternal(Kind::APPLY, {_e33, _e1894});
  _e1895->d_type = _e36;
  _e1896 = mkExprInternal(Kind::APPLY, {_e1895, _e1891});
  _e1896->d_type = _e24;
  _e1897 = mkExprInternal(Kind::APPLY, {_e1896, _e1877});
  _e1897->d_type = _e13;
  _e1898 = mkExprInternal(Kind::VARIABLE_LIST, {_e1874});
  _e1899 = mkExprInternal(Kind::LAMBDA, {_e1898, _e1897});
  bind("string_eager_reduction_to_code", _e1899);
  _e1901 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1902 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1901, _e1901, _e125, _e13});
  _e1900 = mkSymbolInternal(Kind::PROGRAM_CONST, "string_eager_reduction_indexof", _e1902);
  _runId[_e1900.get()] = 1900;
  _e1900->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1903 = mkSymbolInternal(Kind::PARAM, "x", _e1901);
  _e1904 = mkExprInternal(Kind::APPLY, {_e1454, _e1903});
  _e1905 = mkSymbolInternal(Kind::PARAM, "n", _e125);
  _e1906 = mkSymbolInternal(Kind::PARAM, "y", _e1901);
  _e1907 = mkExprInternal(Kind::APPLY, {_e1493, _e1903});
  _e1908 = mkExprInternal(Kind::APPLY, {_e1907, _e1906});
  _e1909 = mkExprInternal(Kind::APPLY, {_e1908, _e1905});
  _e1910 = mkExprInternal(Kind::APPLY, {_e161, _e1909});
  _e1911 = mkExprInternal(Kind::APPLY, {_e1910, _e1904});
  _e1912 = mkExprInternal(Kind::APPLY, {_e44, _e1911});
  _e1913 = mkExprInternal(Kind::APPLY, {_e1912, _e32});
  _e1914 = mkExprInternal(Kind::APPLY, {_e181, _e1909});
  _e1915 = mkExprInternal(Kind::APPLY, {_e1914, _e1905});
  _e1916 = mkExprInternal(Kind::APPLY, {_e39, _e1915});
  _e1917 = mkExprInternal(Kind::APPLY, {_e1916, _e32});
  _e1918 = mkExprInternal(Kind::APPLY, {_e52, _e1909});
  _e1919 = mkExprInternal(Kind::APPLY, {_e1918, _e332});
  _e1920 = mkExprInternal(Kind::APPLY, {_e39, _e1919});
  _e1921 = mkExprInternal(Kind::APPLY, {_e1920, _e1917});
  _e1922 = mkExprInternal(Kind::APPLY, {_e44, _e1921});
  _e1923 = mkExprInternal(Kind::APPLY, {_e1922, _e1913});
  _runId[_e1923.get()] = 1923;
  _e1923->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("string_eager_reduction_indexof", _e1900);
  _runId[_e1902.get()] = 1902;
  _e1902->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1925 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1926 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1925, _e2, _e13});
  _e1924 = mkSymbolInternal(Kind::PROGRAM_CONST, "mk_string_eager_reduction", _e1926);
  _runId[_e1924.get()] = 1924;
  _e1924->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1927 = mkSymbolInternal(Kind::PARAM, "x", _e1925);
  _e1928 = mkExprInternal(Kind::APPLY, {_e1516, _e1927});
  _e1929 = mkExprInternal(Kind::APPLY, {_e52, _e1928});
  _e1930 = mkExprInternal(Kind::APPLY, {_e1929, _e332});
  _e1931 = mkExprInternal(Kind::APPLY, {_e150, _e1928});
  _e1932 = mkExprInternal(Kind::APPLY, {_e1931, _e1878});
  _e1933 = mkExprInternal(Kind::APPLY, {_e44, _e1932});
  _e1934 = mkExprInternal(Kind::APPLY, {_e1933, _e32});
  _e1935 = mkExprInternal(Kind::APPLY, {_e181, _e1928});
  _e1936 = mkExprInternal(Kind::APPLY, {_e1935, _e330});
  _e1937 = mkExprInternal(Kind::APPLY, {_e44, _e1936});
  _e1938 = mkExprInternal(Kind::APPLY, {_e1937, _e1934});
  _e1939 = mkExprInternal(Kind::APPLY, {_e1454, _e1927});
  _e1940 = mkExprInternal(Kind::APPLY, {_e52, _e1939});
  _e1941 = mkExprInternal(Kind::APPLY, {_e1940, _e1768});
  _e1942 = mkExprInternal(Kind::APPLY, {_e33, _e1941});
  _e1943 = mkExprInternal(Kind::APPLY, {_e1942, _e1938});
  _e1944 = mkExprInternal(Kind::APPLY, {_e1943, _e1930});
  _runId[_e1944.get()] = 1944;
  _e1944->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1945 = mkSymbolInternal(Kind::PARAM, "y", _e1925);
  _e1946 = mkExprInternal(Kind::APPLY, {_e1835, _e1927, _e1945, _e1925});
  _e1947 = mkSymbolInternal(Kind::PARAM, "n", _e125);
  _e1948 = mkExprInternal(Kind::APPLY, {_e1736, _e1927, _e1945, _e1947});
  bind("mk_string_eager_reduction", _e1924);
  _runId[_e1926.get()] = 1926;
  _e1926->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1950 = mkExprInternal(Kind::APPLY, {_e1, _e1450});
  _e1950->d_type = _e3;
  _e1951 = mkExprInternal(Kind::APPLY, {_e1950, _e13});
  _e1951->d_type = _e2;
  _e1952 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1450, _e1451, _e1451, _e125, _e1951, _e13});
  _e1949 = mkSymbolInternal(Kind::PROGRAM_CONST, "re_unfold_pos_concat_step", _e1952);
  _runId[_e1949.get()] = 1949;
  _e1949->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1953 = mkSymbolInternal(Kind::PARAM, "M", _e13);
  _e1954 = mkSymbolInternal(Kind::PARAM, "c", _e1450);
  _e1955 = mkSymbolInternal(Kind::PARAM, "s", _e1450);
  _e1956 = mkExprInternal(Kind::APPLY, {_e1460, _e1955});
  _e1957 = mkExprInternal(Kind::APPLY, {_e1956, _e1954});
  _e1958 = mkExprInternal(Kind::APPLY, {_e5, _e1957});
  _e1959 = mkExprInternal(Kind::APPLY, {_e1958, _e1953});
  _runId[_e1959.get()] = 1959;
  _e1959->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1960 = mkSymbolInternal(Kind::PARAM, "r", _e1451);
  _e1961 = mkSymbolInternal(Kind::PARAM, "i", _e125);
  _e1962 = mkSymbolInternal(Kind::PARAM, "ro", _e1451);
  _e1963 = mkSymbolInternal(Kind::PARAM, "t", _e1450);
  _e1964 = mkExprInternal(Kind::APPLY, {_e1587, _e1963});
  _e1965 = mkExprInternal(Kind::APPLY, {_e1964, _e1962});
  _e1966 = mkExprInternal(Kind::APPLY, {_e1965, _e1961});
  _e1967 = mkExprInternal(Kind::APPLY, {_e66, _e1966});
  _e1968 = mkExprInternal(Kind::APPLY, {_e1568, _e1967});
  _e1969 = mkExprInternal(Kind::APPLY, {_e1968, _e1960});
  _e1970 = mkExprInternal(Kind::APPLY, {_e44, _e1969});
  _e1971 = mkExprInternal(Kind::APPLY, {_e1970, _e1953});
  _e1972 = mkExprInternal(Kind::APPLY, {_e1460, _e1967});
  _e1973 = mkExprInternal(Kind::APPLY, {_e1972, _e1954});
  _e1974 = mkExprInternal(Kind::APPLY, {_e5, _e1973});
  _e1975 = mkExprInternal(Kind::APPLY, {_e1974, _e1971});
  _runId[_e1975.get()] = 1975;
  _e1975->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("re_unfold_pos_concat_step", _e1949);
  _runId[_e1952.get()] = 1952;
  _e1952->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1977 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1450, _e1451, _e1451, _e125, _e1951});
  _e1976 = mkSymbolInternal(Kind::PROGRAM_CONST, "re_unfold_pos_concat_rec", _e1977);
  _runId[_e1976.get()] = 1976;
  _e1976->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1978 = mkExprInternal(Kind::APPLY, {_e5, _e32});
  _e1979 = mkExprInternal(Kind::APPLY, {_e1978, _e32});
  _e1980 = mkSymbolInternal(Kind::PARAM, "i", _e125);
  _e1981 = mkExprInternal(Kind::EVAL_ADD, {_e1980, _e1768});
  _runId[_e1981.get()] = 1981;
  _e1981->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1982 = mkSymbolInternal(Kind::PARAM, "ro", _e1451);
  _e1983 = mkSymbolInternal(Kind::PARAM, "r2", _e1451);
  _e1984 = mkSymbolInternal(Kind::PARAM, "t", _e1450);
  _e1985 = mkExprInternal(Kind::APPLY, {_e1976, _e1984, _e1983, _e1982, _e1981});
  _e1986 = mkSymbolInternal(Kind::PARAM, "r1", _e1451);
  _e1987 = mkExprInternal(Kind::APPLY, {_e1949, _e1984, _e1986, _e1982, _e1980, _e1985});
  bind("re_unfold_pos_concat_rec", _e1976);
  _runId[_e1977.get()] = 1977;
  _e1977->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1988 = mkSymbolInternal(Kind::PARAM, "r", _e1451);
  _e1989 = mkSymbolInternal(Kind::PARAM, "t", _e1450);
  _e1990 = mkExprInternal(Kind::APPLY, {_e1976, _e1989, _e1988, _e1988, _e330});
  _e1990->d_type = _e1951;
  _e1991 = mkExprInternal(Kind::VARIABLE_LIST, {_e1989, _e1988});
  _e1992 = mkExprInternal(Kind::LAMBDA, {_e1991, _e1990});
  bind("re_unfold_pos_concat", _e1992);
  _e1994 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e1995 = mkExprInternal(Kind::FUNCTION_TYPE, {_e1994, _e2, _e13});
  _e1993 = mkSymbolInternal(Kind::PROGRAM_CONST, "non_empty_concats", _e1995);
  _runId[_e1993.get()] = 1993;
  _e1993->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1996 = mkSymbolInternal(Kind::PARAM, "t", _e1994);
  _e1997 = mkExprInternal(Kind::APPLY, {_e52, _e1996});
  _runId[_e1997.get()] = 1997;
  _e1997->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e1998 = mkSymbolInternal(Kind::PARAM, "s", _e1994);
  _e1999 = mkExprInternal(Kind::APPLY, {_e1993, _e1998, _e1994});
  _e2000 = mkExprInternal(Kind::APPLY, {_e1590, _e1994});
  _e2001 = mkExprInternal(Kind::APPLY, {_e1997, _e2000});
  _e2002 = mkExprInternal(Kind::APPLY, {_e230, _e44, _e2001, _e1999});
  bind("non_empty_concats", _e1993);
  _runId[_e1995.get()] = 1995;
  _e1995->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2003 = mkSymbolInternal(Kind::PARAM, "s", _e1450);
  _e2004 = mkExprInternal(Kind::EVAL_LENGTH, {_e2003});
  _e2005 = mkExprInternal(Kind::EVAL_IS_EQ, {_e2004, _e1768});
  _e2006 = mkExprInternal(Kind::APPLY, {_e23, _e2005});
  _e2007 = mkExprInternal(Kind::VARIABLE_LIST, {_e2003});
  _e2008 = mkExprInternal(Kind::LAMBDA, {_e2007, _e2006});
  bind("check_length_one", _e2008);
  _e2009 = mkSymbolInternal(Kind::PARAM, "s", _e1450);
  _e2010 = mkExprInternal(Kind::EVAL_LENGTH, {_e2009});
  _e2011 = mkExprInternal(Kind::EVAL_NEG, {_e2010});
  _e2012 = mkExprInternal(Kind::EVAL_ADD, {_e1768, _e2011});
  _e2013 = mkExprInternal(Kind::EVAL_IS_NEG, {_e2012});
  _e2014 = mkExprInternal(Kind::APPLY, {_e23, _e2013});
  _e2015 = mkExprInternal(Kind::VARIABLE_LIST, {_e2009});
  _e2016 = mkExprInternal(Kind::LAMBDA, {_e2015, _e2014});
  bind("check_length_gt_one", _e2016);
  _e2018 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e2019 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2018, _e2018});
  _e2017 = mkSymbolInternal(Kind::PROGRAM_CONST, "string_first_char_or_empty", _e2019);
  _runId[_e2017.get()] = 2017;
  _e2017->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2021 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e2020 = mkSymbolInternal(Kind::PARAM, "s", _e2021);
  _e2022 = mkExprInternal(Kind::APPLY, {_e1575, _e2020});
  _runId[_e2022.get()] = 2022;
  _e2022->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2023 = mkExprInternal(Kind::FAIL, {});
  _e2024 = mkSymbolInternal(Kind::PARAM, "t", _e2018);
  _e2025 = mkExprInternal(Kind::EVAL_LENGTH, {_e2024});
  _e2026 = mkExprInternal(Kind::EVAL_IS_EQ, {_e2025, _e1768});
  _runId[_e2026.get()] = 2026;
  _e2026->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2027 = mkExprInternal(Kind::APPLY, {_e23, _e2026});
  _e2028 = mkExprInternal(Kind::EVAL_IF_THEN_ELSE, {_e2027, _e2024, _e2023});
  bind("string_first_char_or_empty", _e2017);
  _runId[_e2019.get()] = 2019;
  _e2019->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2029 = mkSymbolInternal(Kind::PROGRAM_CONST, "string_flatten_word", _e1509);
  _runId[_e2029.get()] = 2029;
  _e2029->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2030 = mkSymbolInternal(Kind::PARAM, "t", _e1450);
  _e2031 = mkExprInternal(Kind::APPLY, {_e1454, _e2030});
  _e2032 = mkExprInternal(Kind::EVAL_EXTRACT, {_e1768, _e2031, _e2030});
  _runId[_e2032.get()] = 2032;
  _e2032->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2033 = mkExprInternal(Kind::EVAL_EXTRACT, {_e330, _e1768, _e2030});
  _runId[_e2033.get()] = 2033;
  _e2033->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2034 = mkExprInternal(Kind::EVAL_LENGTH, {_e2030});
  _e2035 = mkExprInternal(Kind::EVAL_IS_EQ, {_e2034, _e1768});
  _runId[_e2035.get()] = 2035;
  _e2035->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2036 = mkExprInternal(Kind::APPLY, {_e2029, _e2032});
  _e2037 = mkExprInternal(Kind::APPLY, {_e230, _e1460, _e2033, _e2036});
  _e2038 = mkExprInternal(Kind::APPLY, {_e230, _e1460, _e2030, _e32});
  _e2039 = mkExprInternal(Kind::APPLY, {_e23, _e2035});
  _e2040 = mkExprInternal(Kind::EVAL_IF_THEN_ELSE, {_e2039, _e2038, _e2037});
  bind("string_flatten_word", _e2029);
  _e2042 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e2043 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2042, _e2042});
  _e2041 = mkSymbolInternal(Kind::PROGRAM_CONST, "string_flatten", _e2043);
  _runId[_e2041.get()] = 2041;
  _e2041->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2044 = mkSymbolInternal(Kind::PARAM, "tail2", _e2042);
  _e2045 = mkSymbolInternal(Kind::PARAM, "t", _e2042);
  _e2046 = mkExprInternal(Kind::APPLY, {_e1460, _e2045});
  _e2047 = mkExprInternal(Kind::APPLY, {_e2046, _e2044});
  _runId[_e2047.get()] = 2047;
  _e2047->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2048 = mkSymbolInternal(Kind::PARAM, "tail", _e2042);
  _e2049 = mkExprInternal(Kind::APPLY, {_e2041, _e2048});
  _e2050 = mkExprInternal(Kind::APPLY, {_e261, _e1460, _e2047, _e2049});
  _e2051 = mkExprInternal(Kind::EVAL_LENGTH, {_e2045});
  _e2052 = mkExprInternal(Kind::EVAL_NEG, {_e2051});
  _e2053 = mkExprInternal(Kind::EVAL_ADD, {_e1768, _e2052});
  _e2054 = mkExprInternal(Kind::EVAL_IS_NEG, {_e2053});
  _runId[_e2054.get()] = 2054;
  _e2054->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2055 = mkExprInternal(Kind::APPLY, {_e230, _e1460, _e2045, _e2049});
  _e2056 = mkExprInternal(Kind::APPLY, {_e2029, _e2045});
  _e2057 = mkExprInternal(Kind::APPLY, {_e261, _e1460, _e2056, _e2049});
  _e2058 = mkExprInternal(Kind::APPLY, {_e23, _e2054});
  _e2059 = mkExprInternal(Kind::EVAL_IF_THEN_ELSE, {_e2058, _e2057, _e2055});
  bind("string_flatten", _e2041);
  _runId[_e2043.get()] = 2043;
  _e2043->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2061 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e2062 = mkExprInternal(Kind::APPLY, {_e1, _e2061});
  _e2062->d_type = _e3;
  _e2063 = mkExprInternal(Kind::APPLY, {_e2062, _e2061});
  _e2063->d_type = _e2;
  _e2064 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2061, _e2063});
  _e2060 = mkSymbolInternal(Kind::PROGRAM_CONST, "string_collect_acc", _e2064);
  _runId[_e2060.get()] = 2060;
  _e2060->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2065 = mkSymbolInternal(Kind::PARAM, "tail", _e1450);
  _e2066 = mkSymbolInternal(Kind::PARAM, "t", _e2061);
  _e2067 = mkExprInternal(Kind::APPLY, {_e1460, _e2066});
  _e2068 = mkExprInternal(Kind::APPLY, {_e2067, _e2065});
  _e2069 = mkExprInternal(Kind::APPLY, {_e1978, _e2068});
  _runId[_e2069.get()] = 2069;
  _e2069->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2070 = mkSymbolInternal(Kind::PROGRAM_CONST, "_internal_2", _e1106);
  _e2071 = mkExprInternal(Kind::EVAL_LENGTH, {_e2066});
  _e2072 = mkExprInternal(Kind::EVAL_IS_EQ, {_e2071, _e1768});
  _runId[_e2072.get()] = 2072;
  _e2072->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2073 = mkExprInternal(Kind::APPLY, {_e2060, _e2065});
  _e2074 = mkExprInternal(Kind::APPLY, {_e2070, _e2073, _e2066, _e2065});
  _e2075 = mkExprInternal(Kind::APPLY, {_e23, _e2072});
  _e2076 = mkExprInternal(Kind::EVAL_IF_THEN_ELSE, {_e2075, _e2074, _e2069});
  bind("string_collect_acc", _e2060);
  _runId[_e2064.get()] = 2064;
  _e2064->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2078 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e2079 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2078, _e2, _e2078});
  _e2077 = mkSymbolInternal(Kind::PROGRAM_CONST, "string_collect", _e2079);
  _runId[_e2077.get()] = 2077;
  _e2077->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2080 = mkSymbolInternal(Kind::PROGRAM_CONST, "_internal_3", _e1107);
  _e2081 = mkSymbolInternal(Kind::PARAM, "t", _e2078);
  _e2082 = mkSymbolInternal(Kind::PARAM, "s", _e2078);
  _e2083 = mkExprInternal(Kind::APPLY, {_e2060, _e2081, _e2078});
  _e2084 = mkExprInternal(Kind::APPLY, {_e2080, _e2083, _e2078, _e2082, _e2081});
  bind("string_collect", _e2077);
  _runId[_e2079.get()] = 2079;
  _e2079->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2086 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e2087 = mkExprInternal(Kind::APPLY, {_e1, _e2086});
  _e2087->d_type = _e3;
  _e2088 = mkExprInternal(Kind::APPLY, {_e2087, _e2086});
  _e2088->d_type = _e2;
  _e2089 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2086, _e2086, _e2088});
  _e2085 = mkSymbolInternal(Kind::PROGRAM_CONST, "strip_prefix", _e2089);
  _runId[_e2085.get()] = 2085;
  _e2085->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2090 = mkSymbolInternal(Kind::PARAM, "s2", _e2086);
  _e2091 = mkSymbolInternal(Kind::PARAM, "t2", _e2086);
  _e2092 = mkExprInternal(Kind::APPLY, {_e2085, _e2091, _e2090});
  _e2093 = mkSymbolInternal(Kind::PARAM, "s", _e2086);
  _e2094 = mkSymbolInternal(Kind::PARAM, "t", _e2086);
  _e2095 = mkExprInternal(Kind::APPLY, {_e5, _e2094});
  _e2096 = mkExprInternal(Kind::APPLY, {_e2095, _e2093});
  _runId[_e2096.get()] = 2096;
  _e2096->setFlag(ExprValue::Flag::IS_COMPILED, true);
  bind("strip_prefix", _e2085);
  _runId[_e2089.get()] = 2089;
  _e2089->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2097 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e2098 = mkSymbolInternal(Kind::PARAM, "s", _e2097);
  _e2099 = mkExprInternal(Kind::APPLY, {_e313, _e1460, _e2098, _e2097});
  _e2100 = mkExprInternal(Kind::APPLY, {_e2041, _e2099, _e2097});
  _e2101 = mkExprInternal(Kind::APPLY, {_e294, _e1460, _e2100});
  _e2102 = mkSymbolInternal(Kind::PARAM, "rev", _e13);
  _e2103 = mkExprInternal(Kind::EVAL_IF_THEN_ELSE, {_e2102, _e2101, _e2100});
  _e2104 = mkExprInternal(Kind::VARIABLE_LIST, {_e2097, _e2098, _e2102});
  _e2105 = mkExprInternal(Kind::LAMBDA, {_e2104, _e2103});
  bind("string_to_flat_form", _e2105);
  _e2106 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e2107 = mkSymbolInternal(Kind::PARAM, "s", _e2106);
  _e2108 = mkExprInternal(Kind::APPLY, {_e294, _e1460, _e2107});
  _e2109 = mkSymbolInternal(Kind::PARAM, "rev", _e13);
  _e2110 = mkExprInternal(Kind::EVAL_IF_THEN_ELSE, {_e2109, _e2108, _e2107});
  _e2111 = mkExprInternal(Kind::APPLY, {_e2077, _e2110, _e2106});
  _e2112 = mkExprInternal(Kind::APPLY, {_e303, _e1460, _e2111, _e2106});
  _e2113 = mkExprInternal(Kind::VARIABLE_LIST, {_e2106, _e2107, _e2109});
  _e2114 = mkExprInternal(Kind::LAMBDA, {_e2113, _e2112});
  bind("string_from_flat_form", _e2114);
  _e2116 = mkSymbolInternal(Kind::PARAM, "s", _e2);
  _e2117 = mkExprInternal(Kind::APPLY, {_e1454, _e2116});
  _e2118 = mkExprInternal(Kind::APPLY, {_e52, _e2117});
  _e2119 = mkExprInternal(Kind::APPLY, {_e2118, _e330});
  _e2120 = mkExprInternal(Kind::APPLY, {_e38, _e2119});
  _e2121 = mkExprInternal(Kind::PROOF_TYPE, {_e2120});
  _e2122 = mkSymbolInternal(Kind::PARAM, "t", _e2);
  _e2123 = mkExprInternal(Kind::APPLY, {_e1596, _e2122});
  _e2124 = mkExprInternal(Kind::PAIR, {_e2123, _e25});
  _e2125 = mkExprInternal(Kind::REQUIRES_TYPE, {_e2124, _e2121});
  _e2126 = mkExprInternal(Kind::APPLY, {_e52, _e2116});
  _e2127 = mkExprInternal(Kind::APPLY, {_e2126, _e2122});
  _e2128 = mkExprInternal(Kind::APPLY, {_e38, _e2127});
  _e2129 = mkExprInternal(Kind::PROOF_TYPE, {_e2128});
  _e2130 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2129, _e2125});
  _e2115 = mkSymbolInternal(Kind::PROOF_RULE, "string_length_non_empty", _e2130);
  bind("string_length_non_empty", _e2115);
  _runId[_e2130.get()] = 2130;
  _e2130->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2133 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e2132 = mkSymbolInternal(Kind::PARAM, "s", _e2133);
  _e2134 = mkSymbolInternal(Kind::PARAM, "t", _e2133);
  _e2135 = mkSymbolInternal(Kind::PARAM, "rev", _e13);
  _e2136 = mkExprInternal(Kind::APPLY, {_e313, _e1460, _e2134, _e2133});
  _e2137 = mkExprInternal(Kind::APPLY, {_e2041, _e2136, _e2133});
  _e2138 = mkExprInternal(Kind::APPLY, {_e294, _e1460, _e2137});
  _e2139 = mkExprInternal(Kind::EVAL_IF_THEN_ELSE, {_e2135, _e2138, _e2137});
  _e2140 = mkExprInternal(Kind::APPLY, {_e313, _e1460, _e2132, _e2133});
  _e2141 = mkExprInternal(Kind::APPLY, {_e2041, _e2140, _e2133});
  _e2142 = mkExprInternal(Kind::APPLY, {_e294, _e1460, _e2141});
  _e2143 = mkExprInternal(Kind::EVAL_IF_THEN_ELSE, {_e2135, _e2142, _e2141});
  _e2144 = mkExprInternal(Kind::APPLY, {_e2085, _e2143, _e2139, _e2133});
  _e2146 = mkExprInternal(Kind::FUNCTION_TYPE, {_e154, _e1107});
  _e2145 = mkSymbolInternal(Kind::PROGRAM_CONST, "_internal_4", _e2146);
  _e2147 = mkExprInternal(Kind::APPLY, {_e2145, _e2144, _e2133, _e2135, _e2134, _e2132});
  _e2148 = mkExprInternal(Kind::PROOF_TYPE, {_e2147});
  _e2149 = mkExprInternal(Kind::QUOTE_TYPE, {_e2135});
  _e2150 = mkExprInternal(Kind::QUOTE_TYPE, {_e2133});
  _e2151 = mkExprInternal(Kind::APPLY, {_e52, _e2132});
  _e2152 = mkExprInternal(Kind::APPLY, {_e2151, _e2134});
  _e2153 = mkExprInternal(Kind::PROOF_TYPE, {_e2152});
  _e2154 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2153, _e2150, _e2149, _e2148});
  _e2131 = mkSymbolInternal(Kind::PROOF_RULE, "concat_eq", _e2154);
  bind("concat_eq", _e2131);
  _runId[_e2154.get()] = 2154;
  _e2154->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2157 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e2156 = mkSymbolInternal(Kind::PARAM, "s", _e2157);
  _e2158 = mkExprInternal(Kind::APPLY, {_e1454, _e2156});
  _e2159 = mkExprInternal(Kind::APPLY, {_e171, _e2158});
  _e2160 = mkExprInternal(Kind::APPLY, {_e2159, _e330});
  _e2161 = mkExprInternal(Kind::APPLY, {_e39, _e2160});
  _e2162 = mkExprInternal(Kind::APPLY, {_e2161, _e32});
  _e2163 = mkExprInternal(Kind::APPLY, {_e1590, _e2157});
  _e2164 = mkExprInternal(Kind::APPLY, {_e52, _e2156});
  _e2165 = mkExprInternal(Kind::APPLY, {_e2164, _e2163});
  _e2166 = mkExprInternal(Kind::APPLY, {_e44, _e2165});
  _e2167 = mkExprInternal(Kind::APPLY, {_e2166, _e32});
  _e2168 = mkExprInternal(Kind::APPLY, {_e52, _e2158});
  _e2169 = mkExprInternal(Kind::APPLY, {_e2168, _e330});
  _e2170 = mkExprInternal(Kind::APPLY, {_e44, _e2169});
  _e2171 = mkExprInternal(Kind::APPLY, {_e2170, _e2167});
  _e2172 = mkExprInternal(Kind::APPLY, {_e39, _e2171});
  _e2173 = mkExprInternal(Kind::APPLY, {_e2172, _e2162});
  _e2174 = mkExprInternal(Kind::PROOF_TYPE, {_e2173});
  _e2175 = mkExprInternal(Kind::QUOTE_TYPE, {_e2156});
  _e2176 = mkExprInternal(Kind::QUOTE_TYPE, {_e2157});
  _e2177 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2176, _e2175, _e2174});
  _e2155 = mkSymbolInternal(Kind::PROOF_RULE, "string_length_pos", _e2177);
  bind("string_length_pos", _e2155);
  _runId[_e2177.get()] = 2177;
  _e2177->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2179 = mkSymbolInternal(Kind::PARAM, "t", _e1451);
  _e2180 = mkExprInternal(Kind::APPLY, {_e1544, _e2179});
  _e2181 = mkExprInternal(Kind::APPLY, {_e2180, _e32});
  _e2182 = mkSymbolInternal(Kind::PARAM, "s", _e1451);
  _e2183 = mkExprInternal(Kind::APPLY, {_e1544, _e2182});
  _e2184 = mkExprInternal(Kind::APPLY, {_e2183, _e2181});
  _e2185 = mkExprInternal(Kind::APPLY, {_e1568, _e2184});
  _e2186 = mkExprInternal(Kind::PROOF_TYPE, {_e2185});
  _e2187 = mkSymbolInternal(Kind::PARAM, "x", _e1450);
  _e2188 = mkExprInternal(Kind::APPLY, {_e1568, _e2187});
  _e2189 = mkExprInternal(Kind::APPLY, {_e2188, _e2179});
  _e2190 = mkExprInternal(Kind::PROOF_TYPE, {_e2189});
  _e2191 = mkExprInternal(Kind::APPLY, {_e2188, _e2182});
  _e2192 = mkExprInternal(Kind::PROOF_TYPE, {_e2191});
  _e2193 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2192, _e2190, _e2186});
  _e2178 = mkSymbolInternal(Kind::PROOF_RULE, "re_inter", _e2193);
  bind("re_inter", _e2178);
  _runId[_e2193.get()] = 2193;
  _e2193->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2196 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e2195 = mkSymbolInternal(Kind::PARAM, "s", _e2196);
  _e2197 = mkExprInternal(Kind::APPLY, {_e66, _e2195});
  _e2198 = mkExprInternal(Kind::APPLY, {_e52, _e2195});
  _e2199 = mkExprInternal(Kind::APPLY, {_e2198, _e2197});
  _e2200 = mkExprInternal(Kind::APPLY, {_e44, _e2199});
  _e2201 = mkExprInternal(Kind::APPLY, {_e2200, _e32});
  _e2202 = mkExprInternal(Kind::APPLY, {_e1826, _e2195, _e2196});
  _e2203 = mkExprInternal(Kind::APPLY, {_e44, _e2202});
  _e2204 = mkExprInternal(Kind::APPLY, {_e2203, _e2201});
  _e2205 = mkExprInternal(Kind::PROOF_TYPE, {_e2204});
  _e2206 = mkExprInternal(Kind::QUOTE_TYPE, {_e2195});
  _e2207 = mkExprInternal(Kind::QUOTE_TYPE, {_e2196});
  _e2208 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2207, _e2206, _e2205});
  _e2194 = mkSymbolInternal(Kind::PROOF_RULE, "string_reduction", _e2208);
  bind("string_reduction", _e2194);
  _runId[_e2208.get()] = 2208;
  _e2208->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2210 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e2211 = mkSymbolInternal(Kind::PARAM, "s", _e2210);
  _e2212 = mkExprInternal(Kind::APPLY, {_e1924, _e2211, _e2210});
  _e2213 = mkExprInternal(Kind::PROOF_TYPE, {_e2212});
  _e2214 = mkExprInternal(Kind::QUOTE_TYPE, {_e2211});
  _e2215 = mkExprInternal(Kind::QUOTE_TYPE, {_e2210});
  _e2216 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2215, _e2214, _e2213});
  _e2209 = mkSymbolInternal(Kind::PROOF_RULE, "string_eager_reduction", _e2216);
  bind("string_eager_reduction", _e2209);
  _runId[_e2216.get()] = 2216;
  _e2216->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2218 = mkSymbolInternal(Kind::PARAM, "S", _e2);
  _e2219 = mkExprInternal(Kind::FUNCTION_TYPE, {_e2218, _e2218});
  _e2217 = mkSymbolInternal(Kind::PROGRAM_CONST, "run_evaluate", _e2219);
  _runId[_e2217.get()] = 2217;
  _e2217->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2221 = mkSymbolInternal(Kind::PARAM, "U", _e2);
  _e2220 = mkSymbolInternal(Kind::PARAM, "b", _e2221);
  _e2222 = mkExprInternal(Kind::APPLY, {_e2217, _e2220});
  _e2224 = mkSymbolInternal(Kind::PARAM, "T", _e2);
  _e2223 = mkSymbolInternal(Kind::PARAM, "a", _e2224);
  _e2225 = mkExprInternal(Kind::APPLY, {_e2217, _e2223});
  _e2226 = mkExprInternal(Kind::EVAL_IS_EQ, {_e2225, _e2222});
  _e2227 = mkExprInternal(Kind::APPLY, {_e138, _e2223});
  _e2228 = mkExprInternal(Kind::APPLY, {_e2227, _e2220});
  _runId[_e2228.get()] = 2228;
  _e2228->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2229 = mkExprInternal(Kind::APPLY, {_e2217, _e2228});
  _e2230 = mkExprInternal(Kind::EVAL_IS_NEG, {_e2229});
  _e2231 = mkExprInternal(Kind::EVAL_IS_ZERO, {_e2229});
  _e2232 = mkExprInternal(Kind::EVAL_OR, {_e2230, _e2231});
  _e2233 = mkExprInternal(Kind::APPLY, {_e138, _e2220});
  _e2234 = mkExprInternal(Kind::APPLY, {_e2233, _e2223});
  _runId[_e2234.get()] = 2234;
  _e2234->setFlag(ExprValue::Flag::IS_COMPILED, true);
  _e2235 = mkExprInternal(Kind::APPLY, {_e2217, _e2234});
  _e2236 = mkExprInternal(Kind::EVAL_IS_NEG, {_e2235});
  _e2237 = mkExprInternal(Kind::EVAL_IS_ZERO, {_e2235});
  _e2238 = mkExprInternal(Kind::EVAL_OR, {_e2236, _e2237});
  _e2239 = mkExprInternal(Kind::EVAL_ADD, {_e2225, _e2222});
  _e2240 = mkExprInternal(Kind::EVAL_NEG, {_e2222});
  _e2241 = mkExprInternal(Kind::EVAL_ADD, {_e2225, _e2240});
  _e2242 = mkExprInternal(Kind::EVAL_MUL, {_e2225, _e2222});
  _e2243 = mkSymbolInternal(Kind::PARAM, "z", _e2218);
  bind("run_evaluate", _e2217);
  _runId[_e2219.get()] = 2219;
  _e2219->setFlag(ExprValue::Flag::IS_COMPILED, true);
}

Expr TypeChecker::run_getTypeInternal(Expr& hdType, const std::vector<Expr>& args, std::ostream* out)
{
  std::map<ExprValue*, size_t>::iterator itr = _runId.find(hdType.get());
  switch(itr->second)
  {
  // type rule for (-> Type (-> Type Type))
  case 4:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e2))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e3;
  }
  break;
  // type rule for (-> Type Type)
  case 3:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e2))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e2;
  }
  break;
  // type rule for (-> U (-> T ((Pair U) T)))
  case 11:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  // assign variables
  _p2 = a0;
  _p1 = _e6;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e1, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  _p5 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _p4});
  return _p5;
  }
  break;
  // type rule for (-> R Bool)
  case 15:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> Bool Bool)
  case 24:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e13))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> T U T)
  case 30:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  // assign variables
  _p1 = a0;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> Bool (-> A (-> A A)))
  case 37:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e13))
  {
     return nullptr;
  }
  // assign variables
  _p1 = _e34;
  // construct return type
  return _e36;
  }
  break;
  // type rule for (-> A (-> A A))
  case 36:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _p1});
  return _p2;
  }
  break;
  // type rule for (-> Bool (-> U (maybe_nil Bool U)))
  case 43:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e13))
  {
     return nullptr;
  }
  // assign variables
  _p1 = _e40;
  // construct return type
  return _e42;
  }
  break;
  // type rule for (-> U (maybe_nil Bool U))
  case 42:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e27, _e13, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  return _p2;
  }
  break;
  // type rule for (-> Bool (-> U (maybe_nil Bool U)))
  case 48:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e13))
  {
     return nullptr;
  }
  // assign variables
  _p1 = _e45;
  // construct return type
  return _e47;
  }
  break;
  // type rule for (-> U (maybe_nil Bool U))
  case 47:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e27, _e13, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  return _p2;
  }
  break;
  // type rule for (-> Bool (-> Bool Bool))
  case 50:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e13))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e24;
  }
  break;
  // type rule for (-> A (-> A Bool))
  case 55:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _e13});
  return _p2;
  }
  break;
  // type rule for (-> A Bool)
  case 58:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> A Bool)
  case 61:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> A (-> A Bool))
  case 65:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _e13});
  return _p2;
  }
  break;
  // type rule for (-> A A)
  case 68:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // assign variables
  _p1 = a0;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (Quote F) (Quote theory) (Quote method) (Proof F))
  case 106:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  Expr _p4;
  // assign variables
  _p1 = a0;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p4;
  }
  break;
  // type rule for (let ((_v0 (skolem t))) (-> (Quote _v0) (Proof ((= _v0) t))))
  case 115:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00==_e66))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e66, _p1});
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  _p5 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p4});
  return _p5;
  }
  break;
  // type rule for (-> (Quote F) (Proof F))
  case 120:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p2;
  }
  break;
  // type rule for (let ((_v0 (Proof F))) (-> _v0 _v0))
  case 124:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  Expr _p2;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p2;
  }
  break;
  // type rule for (-> Type Type Type)
  case 128:
  {
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  // check requirements
  if (!(a0==_e2 && a1==_e2))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e2;
  }
  break;
  // type rule for (-> Type Bool)
  case 131:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e2))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> T (-> U (arith_typeunion_nary T U)))
  case 137:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  Expr _p3;
  Expr _p4;
  // assign variables
  _p2 = a0;
  _p1 = _e133;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e127, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _p3});
  return _p4;
  }
  break;
  // type rule for (-> T (-> U (arith_typeunion T U)))
  case 143:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  Expr _p3;
  Expr _p4;
  // assign variables
  _p2 = a0;
  _p1 = _e139;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e129, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _p3});
  return _p4;
  }
  break;
  // type rule for (-> T (-> U (arith_typeunion_nary T U)))
  case 149:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  Expr _p3;
  Expr _p4;
  // assign variables
  _p2 = a0;
  _p1 = _e145;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e127, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _p3});
  return _p4;
  }
  break;
  // type rule for (-> T (-> U (Requires ((is_arith_type T) true) ((is_arith_type U) true) Bool)))
  case 160:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // assign variables
  _p2 = a0;
  _p1 = _e151;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e130, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PAIR, {_p3, _e25});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e130, _p2}, _ctxTmp);
  _p5 = evaluate(_etmp, _ctxTmp);
  _p6 = d_state.mkExprInternal(Kind::PAIR, {_p5, _e25});
  _p7 = d_state.mkExprInternal(Kind::REQUIRES_TYPE, {_p6, _p4, _e13});
  _p8 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _p7});
  return _p8;
  }
  break;
  // type rule for (-> T (-> U (Requires ((is_arith_type T) true) ((is_arith_type U) true) Bool)))
  case 170:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // assign variables
  _p2 = a0;
  _p1 = _e162;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e130, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PAIR, {_p3, _e25});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e130, _p2}, _ctxTmp);
  _p5 = evaluate(_etmp, _ctxTmp);
  _p6 = d_state.mkExprInternal(Kind::PAIR, {_p5, _e25});
  _p7 = d_state.mkExprInternal(Kind::REQUIRES_TYPE, {_p6, _p4, _e13});
  _p8 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _p7});
  return _p8;
  }
  break;
  // type rule for (-> T (-> U (Requires ((is_arith_type T) true) ((is_arith_type U) true) Bool)))
  case 180:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // assign variables
  _p2 = a0;
  _p1 = _e172;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e130, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PAIR, {_p3, _e25});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e130, _p2}, _ctxTmp);
  _p5 = evaluate(_etmp, _ctxTmp);
  _p6 = d_state.mkExprInternal(Kind::PAIR, {_p5, _e25});
  _p7 = d_state.mkExprInternal(Kind::REQUIRES_TYPE, {_p6, _p4, _e13});
  _p8 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _p7});
  return _p8;
  }
  break;
  // type rule for (-> T (-> U (Requires ((is_arith_type T) true) ((is_arith_type U) true) Bool)))
  case 190:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // assign variables
  _p2 = a0;
  _p1 = _e182;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e130, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PAIR, {_p3, _e25});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e130, _p2}, _ctxTmp);
  _p5 = evaluate(_etmp, _ctxTmp);
  _p6 = d_state.mkExprInternal(Kind::PAIR, {_p5, _e25});
  _p7 = d_state.mkExprInternal(Kind::REQUIRES_TYPE, {_p6, _p4, _e13});
  _p8 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _p7});
  return _p8;
  }
  break;
  // type rule for (-> T (Requires ((is_arith_type T) true) Real))
  case 196:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // handle requirement ((is_arith_type T) true)
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e130, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  if (_p2!=_e25)
  {
    if (out) { (*out) << "Failed compiled requirement: " << _p2 << " == " << _e25; }
    return nullptr;
  }
  // construct return type
  return _e126;
  }
  break;
  // type rule for (-> T (Requires ((is_arith_type T) true) Int))
  case 202:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // handle requirement ((is_arith_type T) true)
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e130, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  if (_p2!=_e25)
  {
    if (out) { (*out) << "Failed compiled requirement: " << _p2 << " == " << _e25; }
    return nullptr;
  }
  // construct return type
  return _e125;
  }
  break;
  // type rule for (-> T (Requires ((is_arith_type T) true) Bool))
  case 208:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // handle requirement ((is_arith_type T) true)
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e130, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  if (_p2!=_e25)
  {
    if (out) { (*out) << "Failed compiled requirement: " << _p2 << " == " << _e25; }
    return nullptr;
  }
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> T (Requires ((is_arith_type T) true) T))
  case 214:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // handle requirement ((is_arith_type T) true)
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e130, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  if (_p2!=_e25)
  {
    if (out) { (*out) << "Failed compiled requirement: " << _p2 << " == " << _e25; }
    return nullptr;
  }
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> T (Requires ((is_arith_type T) true) T))
  case 220:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // handle requirement ((is_arith_type T) true)
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e130, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  if (_p2!=_e25)
  {
    if (out) { (*out) << "Failed compiled requirement: " << _p2 << " == " << _e25; }
    return nullptr;
  }
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> Int (-> Int Int))
  case 223:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e125))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e222;
  }
  break;
  // type rule for (-> Int Int)
  case 222:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e125))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e125;
  }
  break;
  // type rule for (-> Int (-> Int Bool))
  case 229:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e125))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e228;
  }
  break;
  // type rule for (-> Int Bool)
  case 228:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e125))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L L)
  case 234:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L Bool)
  case 244:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L Bool)
  case 253:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L L)
  case 265:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L L)
  case 276:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L L)
  case 287:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L L)
  case 298:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L L L)
  case 307:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011 && a3==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L L)
  case 317:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) I L L)
  case 329:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a011;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (-> L (-> L L)) L L Bool)
  case 342:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  if(a01->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a011 = a01->getChildren()[1];
  Expr& a010 = a01->getChildren()[0];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a01->getKind()==Kind::FUNCTION_TYPE && a010==a011 && a00==a011 && a1==a011 && a2==a011))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> (Quote F) (Proof G) (Proof ((=> F) G)))
  case 359:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  // check requirements
  if (!(a1->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a10;
  _p2 = a0;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e49, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  _p5 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p4});
  return _p5;
  }
  break;
  // type rule for (-> Bool Bool Bool)
  case 361:
  {
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  // check requirements
  if (!(a0==_e13 && a1==_e13))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> (Proof F) (Quote C) (Proof (run_process_scope F C)))
  case 384:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00;
  _p1 = a1;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e367, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Quote F) (Proof ((or F) ((or (not F)) alf.nil))))
  case 394:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e32});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p4});
  _p7 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p6});
  return _p7;
  }
  break;
  // type rule for (-> Bool Bool Bool Bool Bool)
  case 400:
  {
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a0==_e13 && a1==_e13 && a2==_e13 && a3==_e13))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> (Proof C1) (Proof C2) (Quote pol) (Quote L) (Proof (resolve C1 C2 pol L)))
  case 426:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  Expr _p5;
  Expr _p6;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a1->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p3 = a10;
  _p4 = a00;
  _p2 = a2;
  _p1 = a3;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e399, _p4, _p3, _p2, _p1}, _ctxTmp);
  _p5 = evaluate(_etmp, _ctxTmp);
  _p6 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p5});
  return _p6;
  }
  break;
  // type rule for (-> Bool Bool Bool Bool)
  case 428:
  {
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a0==_e13 && a1==_e13 && a2==_e13))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> (Proof Cs) (Quote args) (Proof (chainResolve Cs args)))
  case 449:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00;
  _p1 = a1;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e437, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof Cs) (Quote C) (Quote args) (Proof C))
  case 458:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a1;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p4;
  }
  break;
  // type rule for (-> (Proof Cs) (Quote C) (Quote args) (Proof C))
  case 467:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a1;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p4;
  }
  break;
  // type rule for (-> (Proof C) (Proof (nary.elim or alf.nil false (factorLiterals alf.nil C))))
  case 484:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e468, _e32, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e303, _e39, _e32, _e26, _p2}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof C1) (Quote C2) (Requires ((nary.is_subset or C1 C2) true) (Proof C2)))
  case 494:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00;
  _p1 = a1;
  // handle requirement ((nary.is_subset or C1 C2) true)
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e249, _e39, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  if (_p3!=_e25)
  {
    if (out) { (*out) << "Failed compiled requirement: " << _p3 << " == " << _e25; }
    return nullptr;
  }
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p4;
  }
  break;
  // type rule for (-> (Proof F1) (Proof ((= F1) F2)) (Proof F2))
  case 503:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  if(a100->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a1001 = a100->getChildren()[1];
  Expr& a1000 = a100->getChildren()[0];
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a1->getKind()==Kind::PROOF_TYPE && a10->getKind()==Kind::APPLY && a100->getKind()==Kind::APPLY && a1001==a00 && a1000==_e52))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a101;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p3;
  }
  break;
  // type rule for (-> (Proof F1) (Proof ((=> F1) F2)) (Proof F2))
  case 512:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  if(a100->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a1001 = a100->getChildren()[1];
  Expr& a1000 = a100->getChildren()[0];
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a1->getKind()==Kind::PROOF_TYPE && a10->getKind()==Kind::APPLY && a100->getKind()==Kind::APPLY && a1001==a00 && a1000==_e49))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a101;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p3;
  }
  break;
  // type rule for (-> (Proof (not (not F))) (Proof F))
  case 519:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p2;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010==_e38 && a000==_e38))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0011;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p2;
  }
  break;
  // type rule for (-> (Proof F) (Proof (not F)) (Proof false))
  case 526:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a1->getKind()==Kind::PROOF_TYPE && a10->getKind()==Kind::APPLY && a101==a00 && a100==_e38))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e521;
  }
  break;
  // type rule for (-> (Proof Fs) (Quote i) (Proof (nary.at and i Fs)))
  case 534:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a1;
  _p1 = a00;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e324, _e44, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (let ((_v0 (Proof F))) (-> _v0 _v0))
  case 538:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  Expr _p2;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p2;
  }
  break;
  // type rule for (-> (Proof (not Fs)) (Quote i) (Proof (not (nary.at or i Fs))))
  case 548:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000==_e38))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a001;
  _p2 = a1;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e324, _e39, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p3});
  _p5 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p4});
  return _p5;
  }
  break;
  // type rule for (-> (Proof ((=> F1) F2)) (Proof ((or (not F1)) ((or F2) alf.nil))))
  case 561:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e49))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p1 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e32});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p4});
  _p8 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p7});
  return _p8;
  }
  break;
  // type rule for (-> (Proof (not ((=> F1) F2))) (Proof F1))
  case 570:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100==_e49 && a000==_e38))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00101;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p3;
  }
  break;
  // type rule for (-> (Proof (not ((=> F1) F2))) (Proof (not F2)))
  case 580:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100==_e49 && a000==_e38))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0011;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof ((= F1) F2)) (Proof ((or (not F1)) ((or F2) alf.nil))))
  case 593:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e52))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p1 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e32});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p4});
  _p8 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p7});
  return _p8;
  }
  break;
  // type rule for (-> (Proof ((= F1) F2)) (Proof ((or F1) ((or (not F2)) alf.nil))))
  case 606:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e52))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p1 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p7});
  return _p8;
  }
  break;
  // type rule for (-> (Proof (not ((= F1) F2))) (Proof ((or F1) ((or F2) alf.nil))))
  case 619:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100==_e52 && a000==_e38))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0011;
  _p2 = a00101;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e32});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p4});
  _p7 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p6});
  return _p7;
  }
  break;
  // type rule for (-> (Proof (not ((= F1) F2))) (Proof ((or (not F1)) ((or (not F2)) alf.nil))))
  case 634:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100==_e52 && a000==_e38))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00101;
  _p1 = a0011;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> (Proof ((xor F1) F2)) (Proof ((or F1) ((or F2) alf.nil))))
  case 646:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a001;
  _p2 = a0001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e32});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p4});
  _p7 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p6});
  return _p7;
  }
  break;
  // type rule for (-> (Proof ((xor F1) F2)) (Proof ((or (not F1)) ((or (not F2)) alf.nil))))
  case 660:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p1 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> (Proof (not ((xor F1) F2))) (Proof ((or F1) ((or (not F2)) alf.nil))))
  case 674:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100==_e51 && a000==_e38))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0011;
  _p2 = a00101;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p7});
  return _p8;
  }
  break;
  // type rule for (-> (Proof (not ((xor F1) F2))) (Proof ((or (not F1)) ((or F2) alf.nil))))
  case 688:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100==_e51 && a000==_e38))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0011;
  _p2 = a00101;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e32});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p4});
  _p8 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p7});
  return _p8;
  }
  break;
  // type rule for (-> (Proof (((ite C) F1) F2)) (Proof ((or (not C)) ((or F1) alf.nil))))
  case 703:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  if(a0000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00001 = a0000->getChildren()[1];
  Expr& a00000 = a0000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000->getKind()==Kind::APPLY && a00000==_e33))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00001;
  _p1 = a0001;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> (Proof (((ite C) F1) F2)) (Proof ((or C) ((or F2) alf.nil))))
  case 717:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  if(a0000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00001 = a0000->getChildren()[1];
  Expr& a00000 = a0000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000->getKind()==Kind::APPLY && a00000==_e33))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00001;
  _p1 = a001;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p7});
  return _p8;
  }
  break;
  // type rule for (-> (Proof (not (((ite C) F1) F2))) (Proof ((or (not C)) ((or (not F1)) alf.nil))))
  case 734:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  if(a00100->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001001 = a00100->getChildren()[1];
  Expr& a001000 = a00100->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100->getKind()==Kind::APPLY && a001000==_e33 && a000==_e38))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a001001;
  _p1 = a00101;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p4});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _e32});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p7});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p6});
  _p10 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p9});
  return _p10;
  }
  break;
  // type rule for (-> (Proof (not (((ite C) F1) F2))) (Proof ((or C) ((or (not F2)) alf.nil))))
  case 750:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  if(a00100->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001001 = a00100->getChildren()[1];
  Expr& a001000 = a00100->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100->getKind()==Kind::APPLY && a001000==_e33 && a000==_e38))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a001001;
  _p1 = a0011;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p4});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _e32});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p6});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> (Proof (not F)) (Proof (lowerNotAnd F)))
  case 763:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p2;
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000==_e38))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a001;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e751, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  _p3 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p2});
  return _p3;
  }
  break;
  // type rule for (-> (Quote Fs) (Quote i) (Proof ((or (not Fs)) ((or (nary.at and i Fs)) alf.nil))))
  case 776:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // assign variables
  _p1 = a0;
  _p2 = a1;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e324, _e44, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> (Quote Fs) (Proof (nary.append or Fs (lowerNotAnd Fs))))
  case 783:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  // assign variables
  _p1 = a0;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e751, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e230, _e39, _p1, _p2}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Quote Fs) (Proof (nary.append or (not Fs) Fs)))
  case 790:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e230, _e39, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Quote Fs) (Quote i) (Proof (nary.concat or Fs (nary.append or (not (nary.at or i Fs)) alf.nil))))
  case 801:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  // assign variables
  _p2 = a1;
  _p1 = a0;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e324, _e39, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p3});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e230, _e39, _p4, _e32}, _ctxTmp);
  _p5 = evaluate(_etmp, _ctxTmp);
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e261, _e39, _p1, _p5}, _ctxTmp);
  _p6 = evaluate(_etmp, _ctxTmp);
  _p7 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p6});
  return _p7;
  }
  break;
  // type rule for (let ((_v0 ((=> F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or (not F1)) ((or F2) alf.nil))))))
  case 817:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e49))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a001;
  _p1 = a01;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e32});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p4});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e49, _p2});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p1});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _p7});
  _p13 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p12});
  return _p13;
  }
  break;
  // type rule for (let ((_v0 ((=> F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or F1) alf.nil)))))
  case 829:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e49))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a01;
  _p1 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e32});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e49, _p1});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p4});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (let ((_v0 ((=> F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or (not F2)) alf.nil)))))
  case 842:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e49))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a001;
  _p1 = a01;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e49, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p1});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p7});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p5});
  _p10 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p9});
  return _p10;
  }
  break;
  // type rule for (let ((_v0 ((= F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or (not F1)) ((or F2) alf.nil))))))
  case 858:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e52))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e32});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p4});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p2});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p1});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _p7});
  _p13 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p12});
  return _p13;
  }
  break;
  // type rule for (let ((_v0 ((= F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or F1) ((or (not F2)) alf.nil))))))
  case 874:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e52))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p2});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p1});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _p7});
  _p13 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p12});
  return _p13;
  }
  break;
  // type rule for (let ((_v0 ((= F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or F1) ((or F2) alf.nil))))))
  case 888:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e52))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e32});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p4});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p1});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p8});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p6});
  _p11 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p10});
  return _p11;
  }
  break;
  // type rule for (let ((_v0 ((= F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or (not F1)) ((or (not F2)) alf.nil))))))
  case 904:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e52))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p2});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p1});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _p8});
  _p13 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p12});
  return _p13;
  }
  break;
  // type rule for (let ((_v0 ((xor F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or F1) ((or F2) alf.nil))))))
  case 919:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e32});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p4});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p1});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p8});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p6});
  _p12 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p11});
  return _p12;
  }
  break;
  // type rule for (let ((_v0 ((xor F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or (not F1)) ((or (not F2)) alf.nil))))))
  case 936:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p1});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p11});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_p12, _p8});
  _p14 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p13});
  return _p14;
  }
  break;
  // type rule for (let ((_v0 ((xor F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or (not F1)) ((or F2) alf.nil))))))
  case 951:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e32});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p4});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p1});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p7});
  _p12 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p11});
  return _p12;
  }
  break;
  // type rule for (let ((_v0 ((xor F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or F1) ((or (not F2)) alf.nil))))))
  case 966:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000==_e51))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  _p2 = a001;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e51, _p2});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p1});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p7});
  _p12 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p11});
  return _p12;
  }
  break;
  // type rule for (let ((_v0 (((ite C) F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or (not C)) ((or F1) alf.nil))))))
  case 984:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e33))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a001;
  _p2 = a0001;
  _p3 = a01;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e33, _p2});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p1});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p3});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p11});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p12});
  _p14 = d_state.mkExprInternal(Kind::APPLY, {_p13, _p8});
  _p15 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p14});
  return _p15;
  }
  break;
  // type rule for (let ((_v0 (((ite C) F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or C) ((or F2) alf.nil))))))
  case 1001:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e33))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p3 = a001;
  _p1 = a01;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e33, _p2});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p3});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p1});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p11});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_p12, _p7});
  _p14 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p13});
  return _p14;
  }
  break;
  // type rule for (let ((_v0 (((ite C) F1) F2))) (-> (Quote _v0) (Proof ((or (not _v0)) ((or F1) ((or F2) alf.nil))))))
  case 1018:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e33))
  {
     return nullptr;
  }
  // assign variables
  _p3 = a0001;
  _p2 = a001;
  _p1 = a01;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e33, _p3});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p2});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p1});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p11});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_p12, _p7});
  _p14 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p13});
  return _p14;
  }
  break;
  // type rule for (let ((_v0 (((ite C) F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or (not C)) ((or (not F1)) alf.nil))))))
  case 1036:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e33))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p1 = a001;
  _p3 = a01;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p4});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _e32});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p7});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p6});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e33, _p2});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p1});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _p3});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p12});
  _p14 = d_state.mkExprInternal(Kind::APPLY, {_p13, _p9});
  _p15 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p14});
  return _p15;
  }
  break;
  // type rule for (let ((_v0 (((ite C) F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or C) ((or (not F2)) alf.nil))))))
  case 1053:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e33))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p3 = a001;
  _p1 = a01;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p4});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _e32});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p6});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e33, _p2});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p3});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p1});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p11});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_p12, _p8});
  _p14 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p13});
  return _p14;
  }
  break;
  // type rule for (let ((_v0 (((ite C) F1) F2))) (-> (Quote _v0) (Proof ((or _v0) ((or (not F1)) ((or (not F2)) alf.nil))))))
  case 1071:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e33))
  {
     return nullptr;
  }
  // assign variables
  _p3 = a0001;
  _p2 = a001;
  _p1 = a01;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p4});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _e32});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p7});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p6});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e33, _p3});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p2});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _p1});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p12});
  _p14 = d_state.mkExprInternal(Kind::APPLY, {_p13, _p9});
  _p15 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p14});
  return _p15;
  }
  break;
  // type rule for (-> (Proof Fs) (Proof false))
  case 1075:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e521;
  }
  break;
  // type rule for (-> (Quote t) (Proof ((= t) t)))
  case 1083:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p1});
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_p2, _p1});
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof F) (Proof (flipEq F)))
  case 1096:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  Expr _p2;
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1084, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  _p3 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p2});
  return _p3;
  }
  break;
  // type rule for (-> (Proof E) (Proof (mk_trans E)))
  case 1116:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  Expr _p2;
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1097, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  _p3 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p2});
  return _p3;
  }
  break;
  // type rule for (-> (Proof E) (Quote f) (Proof (mk_cong ((= f) f) E)))
  case 1145:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00;
  _p2 = a1;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p2});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1117, _p4, _p1}, _ctxTmp);
  _p5 = evaluate(_etmp, _ctxTmp);
  _p6 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p5});
  return _p6;
  }
  break;
  // type rule for (-> (-> U U) U U Bool Bool)
  case 1149:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a00==a01 && a1==a01 && a2==a01 && a3==_e13))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> (-> U U) Bool Bool)
  case 1164:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  // check requirements
  if (!(a0->getKind()==Kind::FUNCTION_TYPE && a00==a01 && a1==_e13))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> (Proof E) (Quote f) (Proof (mk_nary_cong_eq f E)))
  case 1184:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00;
  _p2 = a1;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1161, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof F) (Proof ((= F) true)))
  case 1191:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p1});
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_p2, _e25});
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof ((= F) true)) (Proof F))
  case 1198:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p2;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001==_e25 && a000->getKind()==Kind::APPLY && a0000==_e52))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0001;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p1});
  return _p2;
  }
  break;
  // type rule for (-> (Proof (not F)) (Proof ((= F) false)))
  case 1206:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000==_e38))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a001;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p1});
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_p2, _e26});
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> (Proof ((= F) false)) (Proof (not F)))
  case 1214:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  Expr _p2;
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001==_e26 && a000->getKind()==Kind::APPLY && a0000==_e52))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0001;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  _p3 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p2});
  return _p3;
  }
  break;
  // type rule for (-> (Proof ((= f) g)) (Proof ((= t1) t2)) (Proof ((= (f t1)) (g t2))))
  case 1234:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  if(a100->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a1001 = a100->getChildren()[1];
  Expr& a1000 = a100->getChildren()[0];
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e52 && a1->getKind()==Kind::PROOF_TYPE && a10->getKind()==Kind::APPLY && a100->getKind()==Kind::APPLY && a1000==_e52))
  {
     return nullptr;
  }
  // assign variables
  _p4 = a0001;
  _p1 = a101;
  _p2 = a001;
  _p3 = a1001;
  // construct return type
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p2, _p1});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p3});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> (Quote t) (Quote t_encoded) (Proof ((= t) t_encoded)))
  case 1244:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  // assign variables
  _p2 = a0;
  _p1 = a1;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  _p5 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p4});
  return _p5;
  }
  break;
  // type rule for (-> T U S)
  case 1249:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  // assign variables
  _p1 = _e1246;
  // construct return type
  return _e1246;
  }
  break;
  // type rule for (-> T S)
  case 1253:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  // assign variables
  _p1 = _e1251;
  // construct return type
  return _e1251;
  }
  break;
  // type rule for (-> T S)
  case 1257:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  // assign variables
  _p1 = _e1255;
  // construct return type
  return _e1255;
  }
  break;
  // type rule for (-> T U S)
  case 1262:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  // assign variables
  _p1 = _e1259;
  // construct return type
  return _e1259;
  }
  break;
  // type rule for (-> (Proof F) (Proof (mk_arith_sum_ub F)))
  case 1316:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  Expr _p2;
  Expr _p3;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1298, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  _p3 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p2});
  return _p3;
  }
  break;
  // type rule for (-> S Bool Bool)
  case 1319:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e13))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> (Quote m) (Quote F) (Proof ((=> ((and ((> m) 0)) ((and F) alf.nil))) (mk_arith_mult_pos m F))))
  case 1353:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  // assign variables
  _p2 = a0;
  _p1 = a1;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1317, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e171, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _e330});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p7});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p5});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e49, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p3});
  _p12 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p11});
  return _p12;
  }
  break;
  // type rule for (-> S Bool Bool)
  case 1356:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e13))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> (Quote m) (Quote F) (Proof ((=> ((and ((< m) 0)) ((and F) alf.nil))) (mk_arith_mult_neg m F))))
  case 1391:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  // assign variables
  _p1 = a1;
  _p2 = a0;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1354, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e150, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _e330});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p7});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p5});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e49, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p3});
  _p12 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p11});
  return _p12;
  }
  break;
  // type rule for (-> Bool S Bool)
  case 1394:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  // check requirements
  if (!(a0==_e13))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> (Proof F1) (Proof F2) (Proof (mk_arith_trichotomy (arith_normalize_lit F1) (arith_normalize_lit F2))))
  case 1415:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a1->getKind()==Kind::PROOF_TYPE))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a00;
  _p1 = a10;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1263, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1263, _p2}, _ctxTmp);
  _p4 = evaluate(_etmp, _ctxTmp);
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1392, _p4, _p3}, _ctxTmp);
  _p5 = evaluate(_etmp, _ctxTmp);
  _p6 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p5});
  return _p6;
  }
  break;
  // type rule for (-> (Proof ((< s) t)) (Quote c) (Requires ((between_zero_and_one (alf.add t (alf.neg c))) true) (Proof ((<= s) c))))
  case 1432:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e150))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p3 = a001;
  _p1 = a1;
  // handle requirement ((between_zero_and_one (alf.add t (alf.neg c))) true)
  _p4 = evaluateLiteralOp(Kind::EVAL_NEG, {_p1});
  _p5 = evaluateLiteralOp(Kind::EVAL_ADD, {_p3, _p4});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e12, _p5}, _ctxTmp);
  _p6 = evaluate(_etmp, _ctxTmp);
  if (_p6!=_e25)
  {
    if (out) { (*out) << "Failed compiled requirement: " << _p6 << " == " << _e25; }
    return nullptr;
  }
  // construct return type
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e161, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p1});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> (Proof ((> s) t)) (Quote c) (Requires ((between_zero_and_one (alf.add c (alf.neg t))) true) (Proof ((>= s) c))))
  case 1449:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  const Expr& a1 = args[1];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e171))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a0001;
  _p3 = a001;
  _p1 = a1;
  // handle requirement ((between_zero_and_one (alf.add c (alf.neg t))) true)
  _p4 = evaluateLiteralOp(Kind::EVAL_NEG, {_p3});
  _p5 = evaluateLiteralOp(Kind::EVAL_ADD, {_p1, _p4});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e12, _p5}, _ctxTmp);
  _p6 = evaluate(_etmp, _ctxTmp);
  if (_p6!=_e25)
  {
    if (out) { (*out) << "Failed compiled requirement: " << _p6 << " == " << _e25; }
    return nullptr;
  }
  // construct return type
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e181, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p1});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> T (Requires ((is_string_type T) true) Int))
  case 1459:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // handle requirement ((is_string_type T) true)
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1453, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  if (_p2!=_e25)
  {
    if (out) { (*out) << "Failed compiled requirement: " << _p2 << " == " << _e25; }
    return nullptr;
  }
  // construct return type
  return _e125;
  }
  break;
  // type rule for (-> T (-> U (Requires ((is_string_type T) true) ((maybe_nil T U) T) T)))
  case 1469:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // assign variables
  _p1 = a0;
  _p2 = _e1462;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e27, _p1, _p2}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PAIR, {_p3, _p1});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1453, _p1}, _ctxTmp);
  _p5 = evaluate(_etmp, _ctxTmp);
  _p6 = d_state.mkExprInternal(Kind::PAIR, {_p5, _e25});
  _p7 = d_state.mkExprInternal(Kind::REQUIRES_TYPE, {_p6, _p4, _p1});
  _p8 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p2, _p7});
  return _p8;
  }
  break;
  // type rule for (-> T (-> Int (-> Int (Requires ((is_string_type T) true) T))))
  case 1477:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  // assign variables
  _p1 = a0;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1453, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  _p3 = d_state.mkExprInternal(Kind::PAIR, {_p2, _e25});
  _p4 = d_state.mkExprInternal(Kind::REQUIRES_TYPE, {_p3, _p1});
  _p5 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_e125, _p4});
  _p6 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_e125, _p5});
  return _p6;
  }
  break;
  // type rule for (-> T (-> T (Requires ((is_string_type T) true) Bool)))
  case 1484:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  // assign variables
  _p1 = a0;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1453, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  _p3 = d_state.mkExprInternal(Kind::PAIR, {_p2, _e25});
  _p4 = d_state.mkExprInternal(Kind::REQUIRES_TYPE, {_p3, _e13});
  _p5 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _p4});
  return _p5;
  }
  break;
  // type rule for (-> T (-> T (-> T (Requires ((is_string_type T) true) T))))
  case 1492:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  // assign variables
  _p1 = a0;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1453, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  _p3 = d_state.mkExprInternal(Kind::PAIR, {_p2, _e25});
  _p4 = d_state.mkExprInternal(Kind::REQUIRES_TYPE, {_p3, _p1});
  _p5 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _p4});
  _p6 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _p5});
  return _p6;
  }
  break;
  // type rule for (-> T (-> T (-> Int (Requires ((is_string_type T) true) Int))))
  case 1500:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  // assign variables
  _p1 = a0;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1453, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  _p3 = d_state.mkExprInternal(Kind::PAIR, {_p2, _e25});
  _p4 = d_state.mkExprInternal(Kind::REQUIRES_TYPE, {_p3, _e125});
  _p5 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_e125, _p4});
  _p6 = d_state.mkExprInternal(Kind::FUNCTION_TYPE, {_p1, _p5});
  return _p6;
  }
  break;
  // type rule for (-> String (-> Int String))
  case 1503:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1450))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1502;
  }
  break;
  // type rule for (-> Int String)
  case 1502:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e125))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1450;
  }
  break;
  // type rule for (-> String (-> String Bool))
  case 1506:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1450))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1505;
  }
  break;
  // type rule for (-> String Bool)
  case 1505:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1450))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> String String)
  case 1509:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1450))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1450;
  }
  break;
  // type rule for (-> String (-> String (-> String String)))
  case 1513:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1450))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1512;
  }
  break;
  // type rule for (-> String (-> String String))
  case 1512:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1450))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1509;
  }
  break;
  // type rule for (-> String Int)
  case 1517:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1450))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e125;
  }
  break;
  // type rule for (-> String (-> RegLan (-> String String)))
  case 1527:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1450))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1526;
  }
  break;
  // type rule for (-> RegLan (-> String String))
  case 1526:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1451))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1509;
  }
  break;
  // type rule for (-> String RegLan)
  case 1534:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1450))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1451;
  }
  break;
  // type rule for (-> RegLan RegLan)
  case 1536:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1451))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1451;
  }
  break;
  // type rule for (-> String (-> String RegLan))
  case 1541:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1450))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1534;
  }
  break;
  // type rule for (-> RegLan (-> RegLan RegLan))
  case 1543:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1451))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1536;
  }
  break;
  // type rule for (-> RegLan (-> U (Requires ((maybe_nil RegLan U) RegLan) RegLan)))
  case 1550:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1451))
  {
     return nullptr;
  }
  // assign variables
  _p1 = _e1545;
  // construct return type
  return _e1549;
  }
  break;
  // type rule for (-> U (Requires ((maybe_nil RegLan U) RegLan) RegLan))
  case 1549:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // handle requirement ((maybe_nil RegLan U) RegLan)
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e27, _e1451, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  if (_p2!=_e1451)
  {
    if (out) { (*out) << "Failed compiled requirement: " << _p2 << " == " << _e1451; }
    return nullptr;
  }
  // construct return type
  return _e1451;
  }
  break;
  // type rule for (-> RegLan (-> U (Requires ((maybe_nil RegLan U) RegLan) RegLan)))
  case 1557:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1451))
  {
     return nullptr;
  }
  // assign variables
  _p1 = _e1552;
  // construct return type
  return _e1556;
  }
  break;
  // type rule for (-> U (Requires ((maybe_nil RegLan U) RegLan) RegLan))
  case 1556:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // handle requirement ((maybe_nil RegLan U) RegLan)
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e27, _e1451, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  if (_p2!=_e1451)
  {
    if (out) { (*out) << "Failed compiled requirement: " << _p2 << " == " << _e1451; }
    return nullptr;
  }
  // construct return type
  return _e1451;
  }
  break;
  // type rule for (-> RegLan (-> U (Requires ((maybe_nil RegLan U) RegLan) RegLan)))
  case 1564:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1451))
  {
     return nullptr;
  }
  // assign variables
  _p1 = _e1559;
  // construct return type
  return _e1563;
  }
  break;
  // type rule for (-> U (Requires ((maybe_nil RegLan U) RegLan) RegLan))
  case 1563:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // handle requirement ((maybe_nil RegLan U) RegLan)
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e27, _e1451, _p1}, _ctxTmp);
  _p2 = evaluate(_etmp, _ctxTmp);
  if (_p2!=_e1451)
  {
    if (out) { (*out) << "Failed compiled requirement: " << _p2 << " == " << _e1451; }
    return nullptr;
  }
  // construct return type
  return _e1451;
  }
  break;
  // type rule for (-> Int (-> Int (-> RegLan RegLan)))
  case 1567:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e125))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1566;
  }
  break;
  // type rule for (-> Int (-> RegLan RegLan))
  case 1566:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e125))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1536;
  }
  break;
  // type rule for (-> String (-> RegLan Bool))
  case 1570:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1450))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1569;
  }
  break;
  // type rule for (-> RegLan Bool)
  case 1569:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1451))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> (Quote T) T)
  case 1574:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // assign variables
  _p1 = a0;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> T (Seq T))
  case 1578:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e1452, _p1});
  return _p2;
  }
  break;
  // type rule for (-> (Seq T) T)
  case 1582:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00==_e1452))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a01;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> (Seq T) Int)
  case 1586:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a01 = a0->getChildren()[1];
  Expr& a00 = a0->getChildren()[0];
  // check requirements
  if (!(a0->getKind()==Kind::APPLY && a00==_e1452))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e125;
  }
  break;
  // type rule for (-> String (-> RegLan (-> Int String)))
  case 1589:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1450))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1588;
  }
  break;
  // type rule for (-> RegLan (-> Int String))
  case 1588:
  {
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e1451))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1502;
  }
  break;
  // type rule for (-> Type U)
  case 1592:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // check requirements
  if (!(a0==_e2))
  {
     return nullptr;
  }
  // assign variables
  _p1 = _e1591;
  // construct return type
  return _e1591;
  }
  break;
  // type rule for (-> U Bool)
  case 1598:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> T T T)
  case 1654:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==a0))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> U Int Int Type Bool)
  case 1667:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a1==_e125 && a2==_e125 && a3==_e2))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> U U Int Type Bool)
  case 1738:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a1==a0 && a2==_e125 && a3==_e2))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> U Type Bool)
  case 1828:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e2))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> U U Type Bool)
  case 1837:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==a0 && a2==_e2))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> U U Int Bool)
  case 1902:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==a0 && a2==_e125))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> U Type Bool)
  case 1926:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e2))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> String RegLan RegLan Int ((Pair String) Bool) Bool)
  case 1952:
  {
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  if (!(a0==_e1450 && a1==_e1451 && a2==_e1451 && a3==_e125 && a4==_e1951))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> String RegLan RegLan Int ((Pair String) Bool))
  case 1977:
  {
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a0==_e1450 && a1==_e1451 && a2==_e1451 && a3==_e125))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e1951;
  }
  break;
  // type rule for (-> U Type Bool)
  case 1995:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e2))
  {
     return nullptr;
  }
  // assign variables
  // construct return type
  return _e13;
  }
  break;
  // type rule for (-> U U)
  case 2019:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // assign variables
  _p1 = a0;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> U U)
  case 2043:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // assign variables
  _p1 = a0;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> U ((Pair U) U))
  case 2064:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  Expr _p2;
  Expr _p3;
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e1, _p1});
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_p2, _p1});
  return _p3;
  }
  break;
  // type rule for (-> U Type U)
  case 2079:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e2))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0;
  // construct return type
  return _p1;
  }
  break;
  // type rule for (-> U U ((Pair U) U))
  case 2089:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  Expr _p2;
  Expr _p3;
  // check requirements
  if (!(a1==a0))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a0;
  // construct return type
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e1, _p1});
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_p2, _p1});
  return _p3;
  }
  break;
  // type rule for (-> (Proof (not ((= s) t))) (Requires ((string_is_empty t) true) (Proof (not ((= (str.len s)) 0)))))
  case 2130:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  if(a001->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0011 = a001->getChildren()[1];
  Expr& a0010 = a001->getChildren()[0];
  if(a0010->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a00101 = a0010->getChildren()[1];
  Expr& a00100 = a0010->getChildren()[0];
  Expr& a000 = a00->getChildren()[0];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a001->getKind()==Kind::APPLY && a0010->getKind()==Kind::APPLY && a00100==_e52 && a000==_e38))
  {
     return nullptr;
  }
  // assign variables
  _p1 = a00101;
  _p2 = a0011;
  // handle requirement ((string_is_empty t) true)
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1596, _p2}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  if (_p3!=_e25)
  {
    if (out) { (*out) << "Failed compiled requirement: " << _p3 << " == " << _e25; }
    return nullptr;
  }
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p4});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _e330});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p6});
  _p8 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p7});
  return _p8;
  }
  break;
  // type rule for (let ((_v1 (string_flatten (nary.intro str.++ s U) U))) (let ((_v0 (string_flatten (nary.intro str.++ t U) U))) (-> (Proof ((= s) t)) (Quote U) (Quote rev) (Proof (_internal_4 (strip_prefix (alf.ite rev (nary.reverse str.++ _v1) _v1) (alf.ite rev (nary.reverse str.++ _v0) _v0) U) U rev t s)))))
  case 2154:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e52))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a001;
  _p3 = a2;
  _p1 = a0001;
  _p4 = a1;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e313, _e1460, _p2, _p4}, _ctxTmp);
  _p5 = evaluate(_etmp, _ctxTmp);
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e2041, _p5, _p4}, _ctxTmp);
  _p6 = evaluate(_etmp, _ctxTmp);
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e294, _e1460, _p6}, _ctxTmp);
  _p7 = evaluate(_etmp, _ctxTmp);
  _p8 = evaluateLiteralOp(Kind::EVAL_IF_THEN_ELSE, {_p3, _p7, _p6});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e313, _e1460, _p1, _p4}, _ctxTmp);
  _p9 = evaluate(_etmp, _ctxTmp);
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e2041, _p9, _p4}, _ctxTmp);
  _p10 = evaluate(_etmp, _ctxTmp);
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e294, _e1460, _p10}, _ctxTmp);
  _p11 = evaluate(_etmp, _ctxTmp);
  _p12 = evaluateLiteralOp(Kind::EVAL_IF_THEN_ELSE, {_p3, _p11, _p10});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e2085, _p12, _p8, _p4}, _ctxTmp);
  _p13 = evaluate(_etmp, _ctxTmp);
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e2145, _p13, _p4, _p3, _p2, _p1}, _ctxTmp);
  _p14 = evaluate(_etmp, _ctxTmp);
  _p15 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p14});
  return _p15;
  }
  break;
  // type rule for (let ((_v0 (str.len s))) (-> (Quote U) (Quote s) (Proof ((or ((and ((= _v0) 0)) ((and ((= s) (mk_emptystr U))) alf.nil))) ((or ((> _v0) 0)) alf.nil)))))
  case 2177:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  Expr _p16;
  Expr _p17;
  Expr _p18;
  Expr _p19;
  // assign variables
  _p2 = a0;
  _p1 = a1;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e171, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e330});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _e32});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1590, _p2}, _ctxTmp);
  _p8 = evaluate(_etmp, _ctxTmp);
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p1});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p8});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _e32});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p3});
  _p14 = d_state.mkExprInternal(Kind::APPLY, {_p13, _e330});
  _p15 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p14});
  _p16 = d_state.mkExprInternal(Kind::APPLY, {_p15, _p12});
  _p17 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p16});
  _p18 = d_state.mkExprInternal(Kind::APPLY, {_p17, _p7});
  _p19 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p18});
  return _p19;
  }
  break;
  // type rule for (let ((_v0 (str.in_re x))) (-> (Proof (_v0 s)) (Proof (_v0 t)) (Proof (str.in_re ((re.inter s) ((re.inter t) alf.nil))))))
  case 2193:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  const Expr& a0 = args[0];
  if(a0->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a00 = a0->getChildren()[0];
  if(a00->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a001 = a00->getChildren()[1];
  Expr& a000 = a00->getChildren()[0];
  if(a000->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a0001 = a000->getChildren()[1];
  Expr& a0000 = a000->getChildren()[0];
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=1)
  {
    return nullptr;
  }
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  if(a100->getNumChildren()!=2)
  {
    return nullptr;
  }
  Expr& a1001 = a100->getChildren()[1];
  Expr& a1000 = a100->getChildren()[0];
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  // check requirements
  if (!(a0->getKind()==Kind::PROOF_TYPE && a00->getKind()==Kind::APPLY && a000->getKind()==Kind::APPLY && a0000==_e1568 && a1->getKind()==Kind::PROOF_TYPE && a10->getKind()==Kind::APPLY && a100->getKind()==Kind::APPLY && a1001==a0001 && a1000==_e1568))
  {
     return nullptr;
  }
  // assign variables
  _p2 = a001;
  _p1 = a101;
  // construct return type
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e1544, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e32});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e1544, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p5});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e1568, _p7});
  _p9 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p8});
  return _p9;
  }
  break;
  // type rule for (-> (Quote U) (Quote s) (Proof ((and (string_reduction_pred s U)) ((and ((= s) (skolem s))) alf.nil))))
  case 2208:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  // assign variables
  _p2 = a0;
  _p1 = a1;
  // construct return type
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e66, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p3});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _e32});
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1826, _p1, _p2}, _ctxTmp);
  _p8 = evaluate(_etmp, _ctxTmp);
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p8});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p7});
  _p11 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p10});
  return _p11;
  }
  break;
  // type rule for (-> (Quote U) (Quote s) (Proof (mk_string_eager_reduction s U)))
  case 2216:
  {
  Expr _p1;
  Expr _p2;
  const Expr& a0 = args[0];
  const Expr& a1 = args[1];
  Expr _p3;
  Expr _p4;
  // assign variables
  _p1 = a0;
  _p2 = a1;
  // construct return type
  _ctxTmp.clear();
  _etmp = evaluateProgram({_e1924, _p2, _p1}, _ctxTmp);
  _p3 = evaluate(_etmp, _ctxTmp);
  _p4 = d_state.mkExprInternal(Kind::PROOF_TYPE, {_p3});
  return _p4;
  }
  break;
  // type rule for (-> S S)
  case 2219:
  {
  Expr _p1;
  const Expr& a0 = args[0];
  // assign variables
  _p1 = a0;
  // construct return type
  return _p1;
  }
  break;
  default: break;
  }
  return nullptr;
}

Expr TypeChecker::run_evaluate(Expr& e, Ctx& ctx)
{
  Ctx::iterator itc;
  std::map<ExprValue*, size_t>::iterator itr = _runId.find(e.get());
  switch(itr->second)
  {
  // evaluation for (alf.and (alf.not (alf.is_neg c)) (alf.is_neg (alf.add c -1)))
  case 22:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  itc = ctx.find(_e17);
  _p1 = (itc==ctx.end() ? _e17 : itc->second);
  _p2 = evaluateLiteralOp(Kind::EVAL_ADD, {_p1, _e16});
  _p3 = evaluateLiteralOp(Kind::EVAL_IS_NEG, {_p2});
  _p4 = evaluateLiteralOp(Kind::EVAL_IS_NEG, {_p1});
  _p5 = evaluateLiteralOp(Kind::EVAL_NOT, {_p4});
  _p6 = evaluateLiteralOp(Kind::EVAL_AND, {_p5, _p3});
  return _p6;
  }
  break;
  // evaluation for ((cons c) xs)
  case 239:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  itc = ctx.find(_e235);
  _p1 = (itc==ctx.end() ? _e235 : itc->second);
  itc = ctx.find(_e236);
  _p2 = (itc==ctx.end() ? _e236 : itc->second);
  itc = ctx.find(_e237);
  _p3 = (itc==ctx.end() ? _e237 : itc->second);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p2});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p1});
  return _p5;
  }
  break;
  // evaluation for (alf.add i -1)
  case 334:
  {
  Expr _p1;
  Expr _p2;
  itc = ctx.find(_e333);
  _p1 = (itc==ctx.end() ? _e333 : itc->second);
  _p2 = evaluateLiteralOp(Kind::EVAL_ADD, {_p1, _e332});
  return _p2;
  }
  break;
  // evaluation for (alf.is_eq c1 c2)
  case 345:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  itc = ctx.find(_e343);
  _p1 = (itc==ctx.end() ? _e343 : itc->second);
  itc = ctx.find(_e344);
  _p2 = (itc==ctx.end() ? _e344 : itc->second);
  _p3 = evaluateLiteralOp(Kind::EVAL_IS_EQ, {_p2, _p1});
  return _p3;
  }
  break;
  // evaluation for (not L)
  case 402:
  {
  Expr _p1;
  Expr _p2;
  itc = ctx.find(_e401);
  _p1 = (itc==ctx.end() ? _e401 : itc->second);
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  return _p2;
  }
  break;
  // evaluation for (not l)
  case 753:
  {
  Expr _p1;
  Expr _p2;
  itc = ctx.find(_e752);
  _p1 = (itc==ctx.end() ? _e752 : itc->second);
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p1});
  return _p2;
  }
  break;
  // evaluation for ((= t2) t1)
  case 1089:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  itc = ctx.find(_e1085);
  _p1 = (itc==ctx.end() ? _e1085 : itc->second);
  itc = ctx.find(_e1087);
  _p2 = (itc==ctx.end() ? _e1087 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  return _p4;
  }
  break;
  // evaluation for (not ((= t2) t1))
  case 1090:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  itc = ctx.find(_e1085);
  _p1 = (itc==ctx.end() ? _e1085 : itc->second);
  itc = ctx.find(_e1087);
  _p2 = (itc==ctx.end() ? _e1087 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p4});
  return _p5;
  }
  break;
  // evaluation for ((= t1) t2)
  case 1102:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  itc = ctx.find(_e1098);
  _p1 = (itc==ctx.end() ? _e1098 : itc->second);
  itc = ctx.find(_e1100);
  _p2 = (itc==ctx.end() ? _e1100 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  return _p4;
  }
  break;
  // evaluation for ((= f1) f2)
  case 1124:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  itc = ctx.find(_e1118);
  _p1 = (itc==ctx.end() ? _e1118 : itc->second);
  itc = ctx.find(_e1122);
  _p2 = (itc==ctx.end() ? _e1122 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  return _p4;
  }
  break;
  // evaluation for ((= (f1 t1)) (f2 t2))
  case 1130:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  itc = ctx.find(_e1125);
  _p1 = (itc==ctx.end() ? _e1125 : itc->second);
  itc = ctx.find(_e1118);
  _p2 = (itc==ctx.end() ? _e1118 : itc->second);
  itc = ctx.find(_e1127);
  _p3 = (itc==ctx.end() ? _e1127 : itc->second);
  itc = ctx.find(_e1122);
  _p4 = (itc==ctx.end() ? _e1122 : itc->second);
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p2, _p1});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p3});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p5});
  return _p8;
  }
  break;
  // evaluation for ((= ((f s1) t1)) ((f s2) t2))
  case 1160:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  itc = ctx.find(_e1150);
  _p1 = (itc==ctx.end() ? _e1150 : itc->second);
  itc = ctx.find(_e1151);
  _p2 = (itc==ctx.end() ? _e1151 : itc->second);
  itc = ctx.find(_e1152);
  _p3 = (itc==ctx.end() ? _e1152 : itc->second);
  itc = ctx.find(_e1155);
  _p4 = (itc==ctx.end() ? _e1155 : itc->second);
  itc = ctx.find(_e1156);
  _p5 = (itc==ctx.end() ? _e1156 : itc->second);
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p1});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p5});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p4});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p7});
  return _p11;
  }
  break;
  // evaluation for ((= s1) s2)
  case 1170:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  itc = ctx.find(_e1167);
  _p1 = (itc==ctx.end() ? _e1167 : itc->second);
  itc = ctx.find(_e1168);
  _p2 = (itc==ctx.end() ? _e1168 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  return _p4;
  }
  break;
  // evaluation for ((r a) b)
  case 1275:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  itc = ctx.find(_e1264);
  _p1 = (itc==ctx.end() ? _e1264 : itc->second);
  itc = ctx.find(_e1266);
  _p2 = (itc==ctx.end() ? _e1266 : itc->second);
  itc = ctx.find(_e1268);
  _p3 = (itc==ctx.end() ? _e1268 : itc->second);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p2});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p1});
  return _p5;
  }
  break;
  // evaluation for ((+ b1) b2)
  case 1282:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  itc = ctx.find(_e1277);
  _p1 = (itc==ctx.end() ? _e1277 : itc->second);
  itc = ctx.find(_e1279);
  _p2 = (itc==ctx.end() ? _e1279 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e132, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  return _p4;
  }
  break;
  // evaluation for ((+ a1) a2)
  case 1288:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  itc = ctx.find(_e1283);
  _p1 = (itc==ctx.end() ? _e1283 : itc->second);
  itc = ctx.find(_e1285);
  _p2 = (itc==ctx.end() ? _e1285 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e132, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  return _p4;
  }
  break;
  // evaluation for ((r a) b)
  case 1307:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  itc = ctx.find(_e1299);
  _p1 = (itc==ctx.end() ? _e1299 : itc->second);
  itc = ctx.find(_e1301);
  _p2 = (itc==ctx.end() ? _e1301 : itc->second);
  itc = ctx.find(_e1303);
  _p3 = (itc==ctx.end() ? _e1303 : itc->second);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p2});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p1});
  return _p5;
  }
  break;
  // evaluation for (let ((_v0 (* m))) ((r (_v0 ((* a) alf.nil))) (_v0 ((* b) alf.nil))))
  case 1336:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  itc = ctx.find(_e1320);
  _p1 = (itc==ctx.end() ? _e1320 : itc->second);
  itc = ctx.find(_e1324);
  _p2 = (itc==ctx.end() ? _e1324 : itc->second);
  itc = ctx.find(_e1327);
  _p3 = (itc==ctx.end() ? _e1327 : itc->second);
  itc = ctx.find(_e1332);
  _p4 = (itc==ctx.end() ? _e1332 : itc->second);
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e144, _p1});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _e32});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e144, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p6});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e144, _p3});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _e32});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p11});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_p12, _p8});
  return _p13;
  }
  break;
  // evaluation for ((* m) ((* b) alf.nil))
  case 1363:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  itc = ctx.find(_e1357);
  _p1 = (itc==ctx.end() ? _e1357 : itc->second);
  itc = ctx.find(_e1361);
  _p2 = (itc==ctx.end() ? _e1361 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e144, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e32});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e144, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p4});
  return _p6;
  }
  break;
  // evaluation for ((* m) ((* a) alf.nil))
  case 1368:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  itc = ctx.find(_e1364);
  _p1 = (itc==ctx.end() ? _e1364 : itc->second);
  itc = ctx.find(_e1361);
  _p2 = (itc==ctx.end() ? _e1361 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e144, _p1});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e32});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e144, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p4});
  return _p6;
  }
  break;
  // evaluation for (seq.empty (Seq U))
  case 1594:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  itc = ctx.find(_e1591);
  _p1 = (itc==ctx.end() ? _e1591 : itc->second);
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e1452, _p1});
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e1571, _p2});
  return _p3;
  }
  break;
  // evaluation for (= (skolem (((str.substr x) n) m)))
  case 1675:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  itc = ctx.find(_e1668);
  _p1 = (itc==ctx.end() ? _e1668 : itc->second);
  itc = ctx.find(_e1669);
  _p2 = (itc==ctx.end() ? _e1669 : itc->second);
  itc = ctx.find(_e1670);
  _p3 = (itc==ctx.end() ? _e1670 : itc->second);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e1470, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p1});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e66, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p7});
  return _p8;
  }
  break;
  // evaluation for (let ((_v6 (skolem ((_v1 0) n)))) (let ((_v7 (str.len x))) (let ((_v0 ((+ n) ((+ m) alf.nil)))) (let ((_v2 ((- _v7) _v0))) (let ((_v4 (skolem ((_v1 _v0) _v2)))) (let ((_v3 (= (str.len _v4)))) (let ((_v1 (str.substr x))) (let ((_v5 (skolem ((_v1 n) m)))) ((ite ((and ((>= n) 0)) ((and ((> _v7) n)) ((and ((> m) 0)) alf.nil)))) ((and ((= x) ((str.++ _v6) ((str.++ _v5) ((str.++ _v4) alf.nil))))) ((and ((= (str.len _v6)) n)) ((and ((or (_v3 _v2)) ((or (_v3 0)) alf.nil))) ((and ((<= (str.len _v5)) m)) alf.nil)))))))))))))
  case 1732:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  Expr _p16;
  Expr _p17;
  Expr _p18;
  Expr _p19;
  Expr _p20;
  Expr _p21;
  Expr _p22;
  Expr _p23;
  Expr _p24;
  Expr _p25;
  Expr _p26;
  Expr _p27;
  Expr _p28;
  Expr _p29;
  Expr _p30;
  Expr _p31;
  Expr _p32;
  Expr _p33;
  Expr _p34;
  Expr _p35;
  Expr _p36;
  Expr _p37;
  Expr _p38;
  Expr _p39;
  Expr _p40;
  Expr _p41;
  Expr _p42;
  Expr _p43;
  Expr _p44;
  Expr _p45;
  Expr _p46;
  Expr _p47;
  Expr _p48;
  Expr _p49;
  Expr _p50;
  Expr _p51;
  Expr _p52;
  Expr _p53;
  Expr _p54;
  Expr _p55;
  Expr _p56;
  Expr _p57;
  Expr _p58;
  Expr _p59;
  Expr _p60;
  Expr _p61;
  Expr _p62;
  Expr _p63;
  Expr _p64;
  itc = ctx.find(_e1668);
  _p1 = (itc==ctx.end() ? _e1668 : itc->second);
  itc = ctx.find(_e1669);
  _p2 = (itc==ctx.end() ? _e1669 : itc->second);
  itc = ctx.find(_e1670);
  _p3 = (itc==ctx.end() ? _e1670 : itc->second);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e1470, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p1});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e66, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p7});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e161, _p8});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p1});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _e32});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_e132, _p1});
  _p14 = d_state.mkExprInternal(Kind::APPLY, {_p13, _e32});
  _p15 = d_state.mkExprInternal(Kind::APPLY, {_e132, _p2});
  _p16 = d_state.mkExprInternal(Kind::APPLY, {_p15, _p14});
  _p17 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p3});
  _p18 = d_state.mkExprInternal(Kind::APPLY, {_e138, _p17});
  _p19 = d_state.mkExprInternal(Kind::APPLY, {_p18, _p16});
  _p20 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p16});
  _p21 = d_state.mkExprInternal(Kind::APPLY, {_p20, _p19});
  _p22 = d_state.mkExprInternal(Kind::APPLY, {_e66, _p21});
  _p23 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p22});
  _p24 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p23});
  _p25 = d_state.mkExprInternal(Kind::APPLY, {_p24, _e330});
  _p26 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p25});
  _p27 = d_state.mkExprInternal(Kind::APPLY, {_p26, _e32});
  _p28 = d_state.mkExprInternal(Kind::APPLY, {_p24, _p19});
  _p29 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p28});
  _p30 = d_state.mkExprInternal(Kind::APPLY, {_p29, _p27});
  _p31 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p30});
  _p32 = d_state.mkExprInternal(Kind::APPLY, {_p31, _p12});
  _p33 = d_state.mkExprInternal(Kind::APPLY, {_p4, _e330});
  _p34 = d_state.mkExprInternal(Kind::APPLY, {_p33, _p2});
  _p35 = d_state.mkExprInternal(Kind::APPLY, {_e66, _p34});
  _p36 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p35});
  _p37 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p36});
  _p38 = d_state.mkExprInternal(Kind::APPLY, {_p37, _p2});
  _p39 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p38});
  _p40 = d_state.mkExprInternal(Kind::APPLY, {_p39, _p32});
  _p41 = d_state.mkExprInternal(Kind::APPLY, {_e1460, _p22});
  _p42 = d_state.mkExprInternal(Kind::APPLY, {_p41, _e32});
  _p43 = d_state.mkExprInternal(Kind::APPLY, {_e1460, _p7});
  _p44 = d_state.mkExprInternal(Kind::APPLY, {_p43, _p42});
  _p45 = d_state.mkExprInternal(Kind::APPLY, {_e1460, _p35});
  _p46 = d_state.mkExprInternal(Kind::APPLY, {_p45, _p44});
  _p47 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p3});
  _p48 = d_state.mkExprInternal(Kind::APPLY, {_p47, _p46});
  _p49 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p48});
  _p50 = d_state.mkExprInternal(Kind::APPLY, {_p49, _p40});
  _p51 = d_state.mkExprInternal(Kind::APPLY, {_e171, _p1});
  _p52 = d_state.mkExprInternal(Kind::APPLY, {_p51, _e330});
  _p53 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p52});
  _p54 = d_state.mkExprInternal(Kind::APPLY, {_p53, _e32});
  _p55 = d_state.mkExprInternal(Kind::APPLY, {_e171, _p17});
  _p56 = d_state.mkExprInternal(Kind::APPLY, {_p55, _p2});
  _p57 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p56});
  _p58 = d_state.mkExprInternal(Kind::APPLY, {_p57, _p54});
  _p59 = d_state.mkExprInternal(Kind::APPLY, {_e181, _p2});
  _p60 = d_state.mkExprInternal(Kind::APPLY, {_p59, _e330});
  _p61 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p60});
  _p62 = d_state.mkExprInternal(Kind::APPLY, {_p61, _p58});
  _p63 = d_state.mkExprInternal(Kind::APPLY, {_e33, _p62});
  _p64 = d_state.mkExprInternal(Kind::APPLY, {_p63, _p50});
  return _p64;
  }
  break;
  // evaluation for (let ((_v4 (_v3 ((+ _v2) alf.nil)))) (let ((_v6 (str.++ _v1))) (let ((_v2 (str.len y))) (let ((_v5 (str.substr _v0))) (let ((_v0 (((str.substr x) n) ((- (str.len x)) n)))) (let ((_v1 (skolem ((_v5 0) (((str.indexof _v0) y) 0))))) (let ((_v3 (+ (str.len _v1)))) ((and ((= _v0) (_v6 ((str.++ y) ((str.++ (skolem ((_v5 _v4) ((- (str.len _v0)) _v4)))) alf.nil))))) ((and (not ((str.contains (_v6 ((str.++ (((str.substr y) 0) ((- _v2) 1))) alf.nil))) y))) ((and ((= (skolem (((str.indexof x) y) n))) ((+ n) (_v3 alf.nil)))) alf.nil))))))))))
  case 1801:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  Expr _p16;
  Expr _p17;
  Expr _p18;
  Expr _p19;
  Expr _p20;
  Expr _p21;
  Expr _p22;
  Expr _p23;
  Expr _p24;
  Expr _p25;
  Expr _p26;
  Expr _p27;
  Expr _p28;
  Expr _p29;
  Expr _p30;
  Expr _p31;
  Expr _p32;
  Expr _p33;
  Expr _p34;
  Expr _p35;
  Expr _p36;
  Expr _p37;
  Expr _p38;
  Expr _p39;
  Expr _p40;
  Expr _p41;
  Expr _p42;
  Expr _p43;
  Expr _p44;
  Expr _p45;
  Expr _p46;
  Expr _p47;
  Expr _p48;
  Expr _p49;
  Expr _p50;
  Expr _p51;
  Expr _p52;
  Expr _p53;
  Expr _p54;
  Expr _p55;
  Expr _p56;
  Expr _p57;
  Expr _p58;
  Expr _p59;
  Expr _p60;
  Expr _p61;
  Expr _p62;
  itc = ctx.find(_e1739);
  _p1 = (itc==ctx.end() ? _e1739 : itc->second);
  itc = ctx.find(_e1740);
  _p2 = (itc==ctx.end() ? _e1740 : itc->second);
  itc = ctx.find(_e1741);
  _p3 = (itc==ctx.end() ? _e1741 : itc->second);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e138, _p4});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p2});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e1470, _p3});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p2});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p6});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e1493, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _p1});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _e330});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_e1470, _p9});
  _p14 = d_state.mkExprInternal(Kind::APPLY, {_p13, _e330});
  _p15 = d_state.mkExprInternal(Kind::APPLY, {_p14, _p12});
  _p16 = d_state.mkExprInternal(Kind::APPLY, {_e66, _p15});
  _p17 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p16});
  _p18 = d_state.mkExprInternal(Kind::APPLY, {_e132, _p17});
  _p19 = d_state.mkExprInternal(Kind::APPLY, {_p18, _e32});
  _p20 = d_state.mkExprInternal(Kind::APPLY, {_e132, _p2});
  _p21 = d_state.mkExprInternal(Kind::APPLY, {_p20, _p19});
  _p22 = d_state.mkExprInternal(Kind::APPLY, {_e1493, _p3});
  _p23 = d_state.mkExprInternal(Kind::APPLY, {_p22, _p1});
  _p24 = d_state.mkExprInternal(Kind::APPLY, {_p23, _p2});
  _p25 = d_state.mkExprInternal(Kind::APPLY, {_e66, _p24});
  _p26 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p25});
  _p27 = d_state.mkExprInternal(Kind::APPLY, {_p26, _p21});
  _p28 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p27});
  _p29 = d_state.mkExprInternal(Kind::APPLY, {_p28, _e32});
  _p30 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p1});
  _p31 = d_state.mkExprInternal(Kind::APPLY, {_e138, _p30});
  _p32 = d_state.mkExprInternal(Kind::APPLY, {_p31, _e1768});
  _p33 = d_state.mkExprInternal(Kind::APPLY, {_e1470, _p1});
  _p34 = d_state.mkExprInternal(Kind::APPLY, {_p33, _e330});
  _p35 = d_state.mkExprInternal(Kind::APPLY, {_p34, _p32});
  _p36 = d_state.mkExprInternal(Kind::APPLY, {_e1460, _p35});
  _p37 = d_state.mkExprInternal(Kind::APPLY, {_p36, _e32});
  _p38 = d_state.mkExprInternal(Kind::APPLY, {_e1460, _p16});
  _p39 = d_state.mkExprInternal(Kind::APPLY, {_p38, _p37});
  _p40 = d_state.mkExprInternal(Kind::APPLY, {_e1478, _p39});
  _p41 = d_state.mkExprInternal(Kind::APPLY, {_p40, _p1});
  _p42 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p41});
  _p43 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p42});
  _p44 = d_state.mkExprInternal(Kind::APPLY, {_p43, _p29});
  _p45 = d_state.mkExprInternal(Kind::APPLY, {_e132, _p30});
  _p46 = d_state.mkExprInternal(Kind::APPLY, {_p45, _e32});
  _p47 = d_state.mkExprInternal(Kind::APPLY, {_p18, _p46});
  _p48 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p9});
  _p49 = d_state.mkExprInternal(Kind::APPLY, {_e138, _p48});
  _p50 = d_state.mkExprInternal(Kind::APPLY, {_p49, _p47});
  _p51 = d_state.mkExprInternal(Kind::APPLY, {_p13, _p47});
  _p52 = d_state.mkExprInternal(Kind::APPLY, {_p51, _p50});
  _p53 = d_state.mkExprInternal(Kind::APPLY, {_e66, _p52});
  _p54 = d_state.mkExprInternal(Kind::APPLY, {_e1460, _p53});
  _p55 = d_state.mkExprInternal(Kind::APPLY, {_p54, _e32});
  _p56 = d_state.mkExprInternal(Kind::APPLY, {_e1460, _p1});
  _p57 = d_state.mkExprInternal(Kind::APPLY, {_p56, _p55});
  _p58 = d_state.mkExprInternal(Kind::APPLY, {_p38, _p57});
  _p59 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p9});
  _p60 = d_state.mkExprInternal(Kind::APPLY, {_p59, _p58});
  _p61 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p60});
  _p62 = d_state.mkExprInternal(Kind::APPLY, {_p61, _p44});
  return _p62;
  }
  break;
  // evaluation for ((= (skolem (((str.indexof x) y) n))) n)
  case 1802:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  itc = ctx.find(_e1740);
  _p1 = (itc==ctx.end() ? _e1740 : itc->second);
  itc = ctx.find(_e1739);
  _p2 = (itc==ctx.end() ? _e1739 : itc->second);
  itc = ctx.find(_e1741);
  _p3 = (itc==ctx.end() ? _e1741 : itc->second);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e1493, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p1});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e66, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p7});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p1});
  return _p9;
  }
  break;
  // evaluation for (= y)
  case 1803:
  {
  Expr _p1;
  Expr _p2;
  itc = ctx.find(_e1739);
  _p1 = (itc==ctx.end() ? _e1739 : itc->second);
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p1});
  return _p2;
  }
  break;
  // evaluation for (let ((_v0 (str.len x))) ((ite ((or (not ((str.contains (((str.substr x) n) ((- _v0) n))) y))) ((or ((> n) _v0)) ((or ((> 0) n)) alf.nil)))) ((= (skolem (((str.indexof x) y) n))) -1)))
  case 1819:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  Expr _p16;
  Expr _p17;
  Expr _p18;
  Expr _p19;
  Expr _p20;
  Expr _p21;
  Expr _p22;
  Expr _p23;
  Expr _p24;
  Expr _p25;
  Expr _p26;
  Expr _p27;
  Expr _p28;
  Expr _p29;
  itc = ctx.find(_e1740);
  _p1 = (itc==ctx.end() ? _e1740 : itc->second);
  itc = ctx.find(_e1739);
  _p2 = (itc==ctx.end() ? _e1739 : itc->second);
  itc = ctx.find(_e1741);
  _p3 = (itc==ctx.end() ? _e1741 : itc->second);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e1493, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p1});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e66, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p7});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _e332});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e1805, _p1});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _e32});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p3});
  _p14 = d_state.mkExprInternal(Kind::APPLY, {_e171, _p1});
  _p15 = d_state.mkExprInternal(Kind::APPLY, {_p14, _p13});
  _p16 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p15});
  _p17 = d_state.mkExprInternal(Kind::APPLY, {_p16, _p12});
  _p18 = d_state.mkExprInternal(Kind::APPLY, {_e138, _p13});
  _p19 = d_state.mkExprInternal(Kind::APPLY, {_p18, _p1});
  _p20 = d_state.mkExprInternal(Kind::APPLY, {_e1470, _p3});
  _p21 = d_state.mkExprInternal(Kind::APPLY, {_p20, _p1});
  _p22 = d_state.mkExprInternal(Kind::APPLY, {_p21, _p19});
  _p23 = d_state.mkExprInternal(Kind::APPLY, {_e1478, _p22});
  _p24 = d_state.mkExprInternal(Kind::APPLY, {_p23, _p2});
  _p25 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p24});
  _p26 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p25});
  _p27 = d_state.mkExprInternal(Kind::APPLY, {_p26, _p17});
  _p28 = d_state.mkExprInternal(Kind::APPLY, {_e33, _p27});
  _p29 = d_state.mkExprInternal(Kind::APPLY, {_p28, _p9});
  return _p29;
  }
  break;
  // evaluation for (let ((_v1 (str.substr t))) (let ((_v2 (skolem ((_v1 0) (((str.indexof t) r) 0))))) (let ((_v0 ((+ (str.len _v2)) ((+ (str.len r)) alf.nil)))) (let ((_v3 (= t))) (((ite ((str.contains t) r)) (_v3 ((str.++ _v2) ((str.++ r) ((str.++ (skolem ((_v1 _v0) ((- (str.len t)) _v0)))) alf.nil))))) (not (_v3 r)))))))
  case 1873:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  Expr _p16;
  Expr _p17;
  Expr _p18;
  Expr _p19;
  Expr _p20;
  Expr _p21;
  Expr _p22;
  Expr _p23;
  Expr _p24;
  Expr _p25;
  Expr _p26;
  Expr _p27;
  Expr _p28;
  Expr _p29;
  Expr _p30;
  Expr _p31;
  Expr _p32;
  Expr _p33;
  Expr _p34;
  Expr _p35;
  Expr _p36;
  itc = ctx.find(_e1838);
  _p1 = (itc==ctx.end() ? _e1838 : itc->second);
  itc = ctx.find(_e1839);
  _p2 = (itc==ctx.end() ? _e1839 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e38, _p4});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p1});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e132, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _e32});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e1493, _p2});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _p1});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _e330});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_e1470, _p2});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_p12, _e330});
  _p14 = d_state.mkExprInternal(Kind::APPLY, {_p13, _p11});
  _p15 = d_state.mkExprInternal(Kind::APPLY, {_e66, _p14});
  _p16 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p15});
  _p17 = d_state.mkExprInternal(Kind::APPLY, {_e132, _p16});
  _p18 = d_state.mkExprInternal(Kind::APPLY, {_p17, _p8});
  _p19 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p2});
  _p20 = d_state.mkExprInternal(Kind::APPLY, {_e138, _p19});
  _p21 = d_state.mkExprInternal(Kind::APPLY, {_p20, _p18});
  _p22 = d_state.mkExprInternal(Kind::APPLY, {_p12, _p18});
  _p23 = d_state.mkExprInternal(Kind::APPLY, {_p22, _p21});
  _p24 = d_state.mkExprInternal(Kind::APPLY, {_e66, _p23});
  _p25 = d_state.mkExprInternal(Kind::APPLY, {_e1460, _p24});
  _p26 = d_state.mkExprInternal(Kind::APPLY, {_p25, _e32});
  _p27 = d_state.mkExprInternal(Kind::APPLY, {_e1460, _p1});
  _p28 = d_state.mkExprInternal(Kind::APPLY, {_p27, _p26});
  _p29 = d_state.mkExprInternal(Kind::APPLY, {_e1460, _p15});
  _p30 = d_state.mkExprInternal(Kind::APPLY, {_p29, _p28});
  _p31 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p30});
  _p32 = d_state.mkExprInternal(Kind::APPLY, {_e1478, _p2});
  _p33 = d_state.mkExprInternal(Kind::APPLY, {_p32, _p1});
  _p34 = d_state.mkExprInternal(Kind::APPLY, {_e33, _p33});
  _p35 = d_state.mkExprInternal(Kind::APPLY, {_p34, _p31});
  _p36 = d_state.mkExprInternal(Kind::APPLY, {_p35, _p5});
  return _p36;
  }
  break;
  // evaluation for (let ((_v0 (((str.indexof x) y) n))) ((and ((or ((= _v0) -1)) ((or ((>= _v0) n)) alf.nil))) ((and ((<= _v0) (str.len x))) alf.nil)))
  case 1923:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  Expr _p16;
  Expr _p17;
  Expr _p18;
  Expr _p19;
  Expr _p20;
  Expr _p21;
  itc = ctx.find(_e1903);
  _p1 = (itc==ctx.end() ? _e1903 : itc->second);
  itc = ctx.find(_e1905);
  _p2 = (itc==ctx.end() ? _e1905 : itc->second);
  itc = ctx.find(_e1906);
  _p3 = (itc==ctx.end() ? _e1906 : itc->second);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e1493, _p1});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _p3});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p2});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_e161, _p7});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p4});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_p10, _e32});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_e181, _p7});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_p12, _p2});
  _p14 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p13});
  _p15 = d_state.mkExprInternal(Kind::APPLY, {_p14, _e32});
  _p16 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p7});
  _p17 = d_state.mkExprInternal(Kind::APPLY, {_p16, _e332});
  _p18 = d_state.mkExprInternal(Kind::APPLY, {_e39, _p17});
  _p19 = d_state.mkExprInternal(Kind::APPLY, {_p18, _p15});
  _p20 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p19});
  _p21 = d_state.mkExprInternal(Kind::APPLY, {_p20, _p11});
  return _p21;
  }
  break;
  // evaluation for (let ((_v0 (str.to_code x))) (((ite ((= (str.len x)) 1)) ((and ((>= _v0) 0)) ((and ((< _v0) 196608)) alf.nil))) ((= _v0) -1)))
  case 1944:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  Expr _p16;
  Expr _p17;
  Expr _p18;
  itc = ctx.find(_e1927);
  _p1 = (itc==ctx.end() ? _e1927 : itc->second);
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e1516, _p1});
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _e332});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e150, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_p5, _e1878});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p6});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _e32});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_e181, _p2});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_p9, _e330});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _p8});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p1});
  _p14 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p13});
  _p15 = d_state.mkExprInternal(Kind::APPLY, {_p14, _e1768});
  _p16 = d_state.mkExprInternal(Kind::APPLY, {_e33, _p15});
  _p17 = d_state.mkExprInternal(Kind::APPLY, {_p16, _p12});
  _p18 = d_state.mkExprInternal(Kind::APPLY, {_p17, _p4});
  return _p18;
  }
  break;
  // evaluation for ((pair ((str.++ s) c)) M)
  case 1959:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  itc = ctx.find(_e1953);
  _p1 = (itc==ctx.end() ? _e1953 : itc->second);
  itc = ctx.find(_e1954);
  _p2 = (itc==ctx.end() ? _e1954 : itc->second);
  itc = ctx.find(_e1955);
  _p3 = (itc==ctx.end() ? _e1955 : itc->second);
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_e1460, _p3});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_p4, _p2});
  _p6 = d_state.mkExprInternal(Kind::APPLY, {_e5, _p5});
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_p6, _p1});
  return _p7;
  }
  break;
  // evaluation for (let ((_v0 (skolem (((@k.RE_UNFOLD_POS_COMPONENT t) ro) i)))) ((pair ((str.++ _v0) c)) ((and ((str.in_re _v0) r)) M)))
  case 1975:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  Expr _p6;
  Expr _p7;
  Expr _p8;
  Expr _p9;
  Expr _p10;
  Expr _p11;
  Expr _p12;
  Expr _p13;
  Expr _p14;
  Expr _p15;
  Expr _p16;
  Expr _p17;
  Expr _p18;
  itc = ctx.find(_e1953);
  _p1 = (itc==ctx.end() ? _e1953 : itc->second);
  itc = ctx.find(_e1960);
  _p2 = (itc==ctx.end() ? _e1960 : itc->second);
  itc = ctx.find(_e1961);
  _p3 = (itc==ctx.end() ? _e1961 : itc->second);
  itc = ctx.find(_e1962);
  _p4 = (itc==ctx.end() ? _e1962 : itc->second);
  itc = ctx.find(_e1963);
  _p5 = (itc==ctx.end() ? _e1963 : itc->second);
  itc = ctx.find(_e1954);
  _p6 = (itc==ctx.end() ? _e1954 : itc->second);
  _p7 = d_state.mkExprInternal(Kind::APPLY, {_e1587, _p5});
  _p8 = d_state.mkExprInternal(Kind::APPLY, {_p7, _p4});
  _p9 = d_state.mkExprInternal(Kind::APPLY, {_p8, _p3});
  _p10 = d_state.mkExprInternal(Kind::APPLY, {_e66, _p9});
  _p11 = d_state.mkExprInternal(Kind::APPLY, {_e1568, _p10});
  _p12 = d_state.mkExprInternal(Kind::APPLY, {_p11, _p2});
  _p13 = d_state.mkExprInternal(Kind::APPLY, {_e44, _p12});
  _p14 = d_state.mkExprInternal(Kind::APPLY, {_p13, _p1});
  _p15 = d_state.mkExprInternal(Kind::APPLY, {_e1460, _p10});
  _p16 = d_state.mkExprInternal(Kind::APPLY, {_p15, _p6});
  _p17 = d_state.mkExprInternal(Kind::APPLY, {_e5, _p16});
  _p18 = d_state.mkExprInternal(Kind::APPLY, {_p17, _p14});
  return _p18;
  }
  break;
  // evaluation for (alf.add i 1)
  case 1981:
  {
  Expr _p1;
  Expr _p2;
  itc = ctx.find(_e1980);
  _p1 = (itc==ctx.end() ? _e1980 : itc->second);
  _p2 = evaluateLiteralOp(Kind::EVAL_ADD, {_p1, _e1768});
  return _p2;
  }
  break;
  // evaluation for (= t)
  case 1997:
  {
  Expr _p1;
  Expr _p2;
  itc = ctx.find(_e1996);
  _p1 = (itc==ctx.end() ? _e1996 : itc->second);
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e52, _p1});
  return _p2;
  }
  break;
  // evaluation for (seq.unit s)
  case 2022:
  {
  Expr _p1;
  Expr _p2;
  itc = ctx.find(_e2020);
  _p1 = (itc==ctx.end() ? _e2020 : itc->second);
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e1575, _p1});
  return _p2;
  }
  break;
  // evaluation for (alf.is_eq (alf.len t) 1)
  case 2026:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  itc = ctx.find(_e2024);
  _p1 = (itc==ctx.end() ? _e2024 : itc->second);
  _p2 = evaluateLiteralOp(Kind::EVAL_LENGTH, {_p1});
  _p3 = evaluateLiteralOp(Kind::EVAL_IS_EQ, {_p2, _e1768});
  return _p3;
  }
  break;
  // evaluation for (alf.extract 1 (str.len t) t)
  case 2032:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  itc = ctx.find(_e2030);
  _p1 = (itc==ctx.end() ? _e2030 : itc->second);
  _p2 = d_state.mkExprInternal(Kind::APPLY, {_e1454, _p1});
  _p3 = evaluateLiteralOp(Kind::EVAL_EXTRACT, {_e1768, _p2, _p1});
  return _p3;
  }
  break;
  // evaluation for (alf.extract 0 1 t)
  case 2033:
  {
  Expr _p1;
  Expr _p2;
  itc = ctx.find(_e2030);
  _p1 = (itc==ctx.end() ? _e2030 : itc->second);
  _p2 = evaluateLiteralOp(Kind::EVAL_EXTRACT, {_e330, _e1768, _p1});
  return _p2;
  }
  break;
  // evaluation for (alf.is_eq (alf.len t) 1)
  case 2035:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  itc = ctx.find(_e2030);
  _p1 = (itc==ctx.end() ? _e2030 : itc->second);
  _p2 = evaluateLiteralOp(Kind::EVAL_LENGTH, {_p1});
  _p3 = evaluateLiteralOp(Kind::EVAL_IS_EQ, {_p2, _e1768});
  return _p3;
  }
  break;
  // evaluation for ((str.++ t) tail2)
  case 2047:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  itc = ctx.find(_e2044);
  _p1 = (itc==ctx.end() ? _e2044 : itc->second);
  itc = ctx.find(_e2045);
  _p2 = (itc==ctx.end() ? _e2045 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e1460, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  return _p4;
  }
  break;
  // evaluation for (alf.is_neg (alf.add 1 (alf.neg (alf.len t))))
  case 2054:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  itc = ctx.find(_e2045);
  _p1 = (itc==ctx.end() ? _e2045 : itc->second);
  _p2 = evaluateLiteralOp(Kind::EVAL_LENGTH, {_p1});
  _p3 = evaluateLiteralOp(Kind::EVAL_NEG, {_p2});
  _p4 = evaluateLiteralOp(Kind::EVAL_ADD, {_e1768, _p3});
  _p5 = evaluateLiteralOp(Kind::EVAL_IS_NEG, {_p4});
  return _p5;
  }
  break;
  // evaluation for ((pair alf.nil) ((str.++ t) tail))
  case 2069:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  Expr _p5;
  itc = ctx.find(_e2065);
  _p1 = (itc==ctx.end() ? _e2065 : itc->second);
  itc = ctx.find(_e2066);
  _p2 = (itc==ctx.end() ? _e2066 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e1460, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  _p5 = d_state.mkExprInternal(Kind::APPLY, {_e1978, _p4});
  return _p5;
  }
  break;
  // evaluation for (alf.is_eq (alf.len t) 1)
  case 2072:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  itc = ctx.find(_e2066);
  _p1 = (itc==ctx.end() ? _e2066 : itc->second);
  _p2 = evaluateLiteralOp(Kind::EVAL_LENGTH, {_p1});
  _p3 = evaluateLiteralOp(Kind::EVAL_IS_EQ, {_p2, _e1768});
  return _p3;
  }
  break;
  // evaluation for ((pair t) s)
  case 2096:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  itc = ctx.find(_e2093);
  _p1 = (itc==ctx.end() ? _e2093 : itc->second);
  itc = ctx.find(_e2094);
  _p2 = (itc==ctx.end() ? _e2094 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e5, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  return _p4;
  }
  break;
  // evaluation for ((- a) b)
  case 2228:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  itc = ctx.find(_e2220);
  _p1 = (itc==ctx.end() ? _e2220 : itc->second);
  itc = ctx.find(_e2223);
  _p2 = (itc==ctx.end() ? _e2223 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e138, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  return _p4;
  }
  break;
  // evaluation for ((- b) a)
  case 2234:
  {
  Expr _p1;
  Expr _p2;
  Expr _p3;
  Expr _p4;
  itc = ctx.find(_e2223);
  _p1 = (itc==ctx.end() ? _e2223 : itc->second);
  itc = ctx.find(_e2220);
  _p2 = (itc==ctx.end() ? _e2220 : itc->second);
  _p3 = d_state.mkExprInternal(Kind::APPLY, {_e138, _p2});
  _p4 = d_state.mkExprInternal(Kind::APPLY, {_p3, _p1});
  return _p4;
  }
  break;
  default: break;
  }
  return nullptr;
}

Expr TypeChecker::run_evaluateProgram(const std::vector<Expr>& args, Ctx& ctx)
{
  std::map<ExprValue*, size_t>::iterator itr = _runId.find(args[0].get());
  switch(itr->second)
  {
  case 12:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (between_zero_and_one c)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  // construct the context
  ctx[_e17] = a1;
  // return (alf.and (alf.not (alf.is_neg c)) (alf.is_neg (alf.add c -1)))
  return _e22;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 23:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (check_true true)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e25))
  {
     break;
  }
  // return true
  return _e25;
  // construct the context
  // return true
  return _e25;
       }
       break;
       // matching for arguments of (check_true b)
       case 2:
       {
  const Expr& a1 = args[1];
  // check requirements
  // return false
  return _e26;
  // construct the context
  // return false
  return _e26;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 27:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (maybe_nil t t)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a2==a1))
  {
     break;
  }
  // construct the context
  ctx[_e31] = a1;
  // return t
  return _e31;
       }
       break;
       // matching for arguments of (maybe_nil t alf.nil)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a2==_e32))
  {
     break;
  }
  // construct the context
  ctx[_e31] = a1;
  // return t
  return _e31;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 127:
  {
     size_t _i=0;
     while (_i<6)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (arith_typeunion_nary Int Real)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e125 && a2==_e126))
  {
     break;
  }
  // return Real
  return _e126;
  // construct the context
  // return Real
  return _e126;
       }
       break;
       // matching for arguments of (arith_typeunion_nary Int Int)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e125 && a2==_e125))
  {
     break;
  }
  // return Int
  return _e125;
  // construct the context
  // return Int
  return _e125;
       }
       break;
       // matching for arguments of (arith_typeunion_nary Int alf.nil)
       case 3:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e125 && a2==_e32))
  {
     break;
  }
  // return Int
  return _e125;
  // construct the context
  // return Int
  return _e125;
       }
       break;
       // matching for arguments of (arith_typeunion_nary Real Real)
       case 4:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e126 && a2==_e126))
  {
     break;
  }
  // return Real
  return _e126;
  // construct the context
  // return Real
  return _e126;
       }
       break;
       // matching for arguments of (arith_typeunion_nary Real Int)
       case 5:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e126 && a2==_e125))
  {
     break;
  }
  // return Real
  return _e126;
  // construct the context
  // return Real
  return _e126;
       }
       break;
       // matching for arguments of (arith_typeunion_nary Real alf.nil)
       case 6:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e126 && a2==_e32))
  {
     break;
  }
  // return Real
  return _e126;
  // construct the context
  // return Real
  return _e126;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 129:
  {
     size_t _i=0;
     while (_i<4)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (arith_typeunion Int Int)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e125 && a2==_e125))
  {
     break;
  }
  // return Int
  return _e125;
  // construct the context
  // return Int
  return _e125;
       }
       break;
       // matching for arguments of (arith_typeunion Real Real)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e126 && a2==_e126))
  {
     break;
  }
  // return Real
  return _e126;
  // construct the context
  // return Real
  return _e126;
       }
       break;
       // matching for arguments of (arith_typeunion Real Int)
       case 3:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e126 && a2==_e125))
  {
     break;
  }
  // return Real
  return _e126;
  // construct the context
  // return Real
  return _e126;
       }
       break;
       // matching for arguments of (arith_typeunion Int Real)
       case 4:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e125 && a2==_e126))
  {
     break;
  }
  // return Real
  return _e126;
  // construct the context
  // return Real
  return _e126;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 130:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (is_arith_type Int)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e125))
  {
     break;
  }
  // return true
  return _e25;
  // construct the context
  // return true
  return _e25;
       }
       break;
       // matching for arguments of (is_arith_type Real)
       case 2:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e126))
  {
     break;
  }
  // return true
  return _e25;
  // construct the context
  // return true
  return _e25;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 230:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (nary.append cons c xs)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  // construct the context
  ctx[_e237] = a1;
  ctx[_e235] = a3;
  ctx[_e236] = a2;
  // return ((cons c) xs)
  return _e239;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 240:
  {
     size_t _i=0;
     while (_i<3)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (nary.ctn cons c alf.nil)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a3==_e32))
  {
     break;
  }
  // return false
  return _e26;
  // construct the context
  // return false
  return _e26;
       }
       break;
       // matching for arguments of (nary.ctn cons c ((cons c) xs))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a301==a2 && a300==a1))
  {
     break;
  }
  // return true
  return _e25;
  // construct the context
  // return true
  return _e25;
       }
       break;
       // matching for arguments of (nary.ctn cons c ((cons x) xs))
       case 3:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a300==a1))
  {
     break;
  }
  // construct the context
  ctx[_e247] = a1;
  ctx[_e246] = a2;
  ctx[_e245] = a31;
  // return (nary.ctn cons c xs)
  return _e248;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 249:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (nary.is_subset cons alf.nil t)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a2==_e32))
  {
     break;
  }
  // return true
  return _e25;
  // construct the context
  // return true
  return _e25;
       }
       break;
       // matching for arguments of (nary.is_subset cons ((cons c) xs) t)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a200==a1))
  {
     break;
  }
  // construct the context
  ctx[_e258] = a201;
  ctx[_e254] = a3;
  ctx[_e255] = a21;
  ctx[_e256] = a1;
  // return (alf.ite (nary.ctn cons c t) (nary.is_subset cons xs t) false)
  return _e260;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 261:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (nary.concat cons alf.nil ys)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a2==_e32))
  {
     break;
  }
  // construct the context
  ctx[_e266] = a3;
  // return ys
  return _e266;
       }
       break;
       // matching for arguments of (nary.concat cons ((cons x) xs) ys)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a200==a1))
  {
     break;
  }
  // construct the context
  ctx[_e268] = a1;
  ctx[_e270] = a201;
  ctx[_e267] = a21;
  ctx[_e266] = a3;
  // return (nary.append cons x (nary.concat cons xs ys))
  return _e271;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 272:
  {
     size_t _i=0;
     while (_i<3)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (nary.remove cons c alf.nil)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a3==_e32))
  {
     break;
  }
  // return alf.nil
  return _e32;
  // construct the context
  // return alf.nil
  return _e32;
       }
       break;
       // matching for arguments of (nary.remove cons c ((cons c) xs))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a301==a2 && a300==a1))
  {
     break;
  }
  // construct the context
  ctx[_e277] = a31;
  // return xs
  return _e277;
       }
       break;
       // matching for arguments of (nary.remove cons c ((cons y) xs))
       case 3:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a300==a1))
  {
     break;
  }
  // construct the context
  ctx[_e279] = a1;
  ctx[_e278] = a2;
  ctx[_e281] = a301;
  ctx[_e277] = a31;
  // return (nary.append cons y (nary.remove cons c xs))
  return _e282;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 283:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (nary.reverseRec cons alf.nil l)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a2==_e32))
  {
     break;
  }
  // construct the context
  ctx[_e288] = a3;
  // return l
  return _e288;
       }
       break;
       // matching for arguments of (nary.reverseRec cons ((cons x) xs) l)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a200==a1))
  {
     break;
  }
  // construct the context
  ctx[_e290] = a1;
  ctx[_e289] = a201;
  ctx[_e292] = a21;
  ctx[_e288] = a3;
  // return (nary.reverseRec cons xs (nary.append cons x l))
  return _e293;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 294:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (nary.reverse cons nil xs)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  // construct the context
  ctx[_e301] = a1;
  ctx[_e299] = a2;
  ctx[_e300] = a3;
  // return (nary.reverseRec cons xs nil)
  return _e302;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 303:
  {
     size_t _i=0;
     while (_i<4)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (nary.elim cons nil c nil)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  if (!(a4==a2))
  {
     break;
  }
  // construct the context
  ctx[_e308] = a3;
  // return c
  return _e308;
       }
       break;
       // matching for arguments of (nary.elim cons nil c ((cons x) nil))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  if(a4->getNumChildren()!=2)
  {
    break;
  }
  Expr& a41 = a4->getChildren()[1];
  Expr& a40 = a4->getChildren()[0];
  if(a40->getNumChildren()!=2)
  {
    break;
  }
  Expr& a401 = a40->getChildren()[1];
  Expr& a400 = a40->getChildren()[0];
  // check requirements
  if (!(a4->getKind()==Kind::APPLY && a41==a2 && a40->getKind()==Kind::APPLY && a400==a1))
  {
     break;
  }
  // construct the context
  ctx[_e309] = a401;
  // return x
  return _e309;
       }
       break;
       // matching for arguments of (nary.elim cons nil c ((cons x) xs))
       case 3:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  if(a4->getNumChildren()!=2)
  {
    break;
  }
  Expr& a41 = a4->getChildren()[1];
  Expr& a40 = a4->getChildren()[0];
  if(a40->getNumChildren()!=2)
  {
    break;
  }
  Expr& a401 = a40->getChildren()[1];
  Expr& a400 = a40->getChildren()[0];
  // check requirements
  if (!(a4->getKind()==Kind::APPLY && a40->getKind()==Kind::APPLY && a400==a1))
  {
     break;
  }
  // construct the context
  ctx[_e310] = a41;
  ctx[_e309] = a401;
  ctx[_e311] = a1;
  // return (nary.append cons x xs)
  return _e312;
       }
       break;
       // matching for arguments of (nary.elim cons nil c xs)
       case 4:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  // construct the context
  ctx[_e310] = a4;
  // return xs
  return _e310;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 313:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (nary.intro cons nil ((cons x) xs))
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a300==a1))
  {
     break;
  }
  // construct the context
  ctx[_e319] = a301;
  ctx[_e318] = a31;
  ctx[_e320] = a1;
  // return (nary.append cons x xs)
  return _e321;
       }
       break;
       // matching for arguments of (nary.intro cons nil x)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  // construct the context
  ctx[_e322] = a2;
  ctx[_e319] = a3;
  ctx[_e320] = a1;
  // return (nary.append cons x nil)
  return _e323;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 324:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (nary.at cons 0 ((cons x) xs))
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a2==_e330 && a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a300==a1))
  {
     break;
  }
  // construct the context
  ctx[_e331] = a301;
  // return x
  return _e331;
       }
       break;
       // matching for arguments of (nary.at cons i ((cons x) xs))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a300==a1))
  {
     break;
  }
  // construct the context
  ctx[_e336] = a1;
  ctx[_e335] = a31;
  ctx[_e333] = a2;
  // return (nary.at cons (alf.add i -1) xs)
  return _e337;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 338:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (nary.is_prefix cons alf.nil t)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a2==_e32))
  {
     break;
  }
  // return true
  return _e25;
  // construct the context
  // return true
  return _e25;
       }
       break;
       // matching for arguments of (nary.is_prefix cons ((cons c1) xs1) ((cons c2) xs2))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a200==a1 && a3->getKind()==Kind::APPLY && a30->getKind()==Kind::APPLY && a300==a1))
  {
     break;
  }
  // construct the context
  ctx[_e348] = a1;
  ctx[_e347] = a21;
  ctx[_e344] = a201;
  ctx[_e343] = a301;
  ctx[_e346] = a31;
  // return (alf.ite (alf.is_eq c1 c2) (nary.is_prefix cons xs1 xs2) false)
  return _e350;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 360:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (extract_antec C C)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a2==a1))
  {
     break;
  }
  // return alf.nil
  return _e32;
  // construct the context
  // return alf.nil
  return _e32;
       }
       break;
       // matching for arguments of (extract_antec ((=> F1) F2) C)
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e49))
  {
     break;
  }
  // construct the context
  ctx[_e362] = a2;
  ctx[_e363] = a11;
  ctx[_e365] = a101;
  // return (nary.append and F1 (extract_antec F2 C))
  return _e366;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 367:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (run_process_scope F false)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a2==_e26))
  {
     break;
  }
  // construct the context
  ctx[_e368] = a1;
  // return (not (nary.elim and alf.nil true (extract_antec F false)))
  return _e371;
       }
       break;
       // matching for arguments of (run_process_scope F C)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  // construct the context
  ctx[_e368] = a1;
  ctx[_e372] = a2;
  // return ((=> (nary.elim and alf.nil true (extract_antec F C))) C)
  return _e376;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 395:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (removeSelf l l)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a2==a1))
  {
     break;
  }
  // return false
  return _e26;
  // construct the context
  // return false
  return _e26;
       }
       break;
       // matching for arguments of (removeSelf l C)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  // construct the context
  ctx[_e396] = a2;
  ctx[_e397] = a1;
  // return (nary.remove or l C)
  return _e398;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 399:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (resolve C1 C2 true L)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  if (!(a3==_e25))
  {
     break;
  }
  // construct the context
  ctx[_e406] = a1;
  ctx[_e403] = a2;
  ctx[_e401] = a4;
  // return (nary.elim or alf.nil false (nary.concat or (removeSelf L (nary.intro or alf.nil C1)) (removeSelf (not L) (nary.intro or alf.nil C2))))
  return _e410;
       }
       break;
       // matching for arguments of (resolve C1 C2 false L)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  if (!(a3==_e26))
  {
     break;
  }
  // construct the context
  ctx[_e406] = a1;
  ctx[_e403] = a2;
  ctx[_e401] = a4;
  // return (nary.elim or alf.nil false (nary.concat or (removeSelf (not L) (nary.intro or alf.nil C1)) (removeSelf L (nary.intro or alf.nil C2))))
  return _e414;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 427:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (chainResolveRec C1 alf.nil alf.nil)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  if (!(a2==_e32 && a3==_e32))
  {
     break;
  }
  // construct the context
  ctx[_e429] = a1;
  // return C1
  return _e429;
       }
       break;
       // matching for arguments of (chainResolveRec C1 ((and C2) Cs) ((and pol) ((and L) args)))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  const Expr& a3 = args[3];
  if(a3->getNumChildren()!=2)
  {
    break;
  }
  Expr& a31 = a3->getChildren()[1];
  if(a31->getNumChildren()!=2)
  {
    break;
  }
  Expr& a311 = a31->getChildren()[1];
  Expr& a310 = a31->getChildren()[0];
  if(a310->getNumChildren()!=2)
  {
    break;
  }
  Expr& a3101 = a310->getChildren()[1];
  Expr& a3100 = a310->getChildren()[0];
  Expr& a30 = a3->getChildren()[0];
  if(a30->getNumChildren()!=2)
  {
    break;
  }
  Expr& a301 = a30->getChildren()[1];
  Expr& a300 = a30->getChildren()[0];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a200==_e44 && a3->getKind()==Kind::APPLY && a31->getKind()==Kind::APPLY && a310->getKind()==Kind::APPLY && a3100==_e44 && a30->getKind()==Kind::APPLY && a300==_e44))
  {
     break;
  }
  // construct the context
  ctx[_e429] = a1;
  ctx[_e434] = a201;
  ctx[_e431] = a21;
  ctx[_e433] = a301;
  ctx[_e430] = a311;
  ctx[_e432] = a3101;
  // return (chainResolveRec (resolve C1 C2 pol L) Cs args)
  return _e436;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 437:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (chainResolve ((and C1) Cs) args)
       case 1:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e44))
  {
     break;
  }
  // construct the context
  ctx[_e440] = a101;
  ctx[_e439] = a11;
  ctx[_e438] = a2;
  // return (chainResolveRec C1 Cs args)
  return _e441;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 468:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (factorLiterals xs alf.nil)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a2==_e32))
  {
     break;
  }
  // return alf.nil
  return _e32;
  // construct the context
  // return alf.nil
  return _e32;
       }
       break;
       // matching for arguments of (factorLiterals xs ((or l) ls))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a200==_e39))
  {
     break;
  }
  // construct the context
  ctx[_e470] = a1;
  ctx[_e471] = a201;
  ctx[_e469] = a21;
  // return (let ((_v1 (nary.ctn or l xs))) (let ((_v0 (factorLiterals (alf.ite _v1 xs (nary.append or l xs)) ls))) (alf.ite _v1 _v0 (nary.append or l _v0))))
  return _e477;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 751:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (lowerNotAnd alf.nil)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e32))
  {
     break;
  }
  // return alf.nil
  return _e32;
  // construct the context
  // return alf.nil
  return _e32;
       }
       break;
       // matching for arguments of (lowerNotAnd ((and l) ls))
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e44))
  {
     break;
  }
  // construct the context
  ctx[_e752] = a101;
  ctx[_e754] = a11;
  // return (nary.append or (not l) (lowerNotAnd ls))
  return _e756;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1084:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (flipEq ((= t1) t2))
       case 1:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e52))
  {
     break;
  }
  // construct the context
  ctx[_e1085] = a101;
  ctx[_e1087] = a11;
  // return ((= t2) t1)
  return _e1089;
       }
       break;
       // matching for arguments of (flipEq (not ((= t1) t2)))
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  if(a11->getNumChildren()!=2)
  {
    break;
  }
  Expr& a111 = a11->getChildren()[1];
  Expr& a110 = a11->getChildren()[0];
  if(a110->getNumChildren()!=2)
  {
    break;
  }
  Expr& a1101 = a110->getChildren()[1];
  Expr& a1100 = a110->getChildren()[0];
  Expr& a10 = a1->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a11->getKind()==Kind::APPLY && a110->getKind()==Kind::APPLY && a1100==_e52 && a10==_e38))
  {
     break;
  }
  // construct the context
  ctx[_e1085] = a1101;
  ctx[_e1087] = a111;
  // return (not ((= t2) t1))
  return _e1090;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1097:
  {
     size_t _i=0;
     while (_i<3)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (mk_trans alf.nil)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e32))
  {
     break;
  }
  // return alf.nil
  return _e32;
  // construct the context
  // return alf.nil
  return _e32;
       }
       break;
       // matching for arguments of (mk_trans ((= t1) t2))
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e52))
  {
     break;
  }
  // construct the context
  ctx[_e1100] = a101;
  ctx[_e1098] = a11;
  // return ((= t1) t2)
  return _e1102;
       }
       break;
       // matching for arguments of (mk_trans ((and ((= t1) t2)) tail))
       case 3:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  if(a101->getNumChildren()!=2)
  {
    break;
  }
  Expr& a1011 = a101->getChildren()[1];
  Expr& a1010 = a101->getChildren()[0];
  if(a1010->getNumChildren()!=2)
  {
    break;
  }
  Expr& a10101 = a1010->getChildren()[1];
  Expr& a10100 = a1010->getChildren()[0];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a101->getKind()==Kind::APPLY && a1010->getKind()==Kind::APPLY && a10100==_e52 && a100==_e44))
  {
     break;
  }
  // construct the context
  ctx[_e1100] = a10101;
  ctx[_e1098] = a1011;
  ctx[_e1108] = a11;
  // return (_internal_1 (mk_trans tail) t1 t2 tail)
  return _e1110;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1117:
  {
     size_t _i=0;
     while (_i<3)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (mk_cong ((= f1) f2) alf.nil)
       case 1:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e52 && a2==_e32))
  {
     break;
  }
  // construct the context
  ctx[_e1122] = a101;
  ctx[_e1118] = a11;
  // return ((= f1) f2)
  return _e1124;
       }
       break;
       // matching for arguments of (mk_cong ((= f1) f2) ((= t1) t2))
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e52 && a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a200==_e52))
  {
     break;
  }
  // construct the context
  ctx[_e1122] = a101;
  ctx[_e1125] = a21;
  ctx[_e1118] = a11;
  ctx[_e1127] = a201;
  // return ((= (f1 t1)) (f2 t2))
  return _e1130;
       }
       break;
       // matching for arguments of (mk_cong ((= f1) f2) ((and ((= t1) t2)) tail))
       case 3:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  if(a201->getNumChildren()!=2)
  {
    break;
  }
  Expr& a2011 = a201->getChildren()[1];
  Expr& a2010 = a201->getChildren()[0];
  if(a2010->getNumChildren()!=2)
  {
    break;
  }
  Expr& a20101 = a2010->getChildren()[1];
  Expr& a20100 = a2010->getChildren()[0];
  Expr& a200 = a20->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e52 && a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a201->getKind()==Kind::APPLY && a2010->getKind()==Kind::APPLY && a20100==_e52 && a200==_e44))
  {
     break;
  }
  // construct the context
  ctx[_e1122] = a101;
  ctx[_e1125] = a2011;
  ctx[_e1118] = a11;
  ctx[_e1127] = a20101;
  ctx[_e1131] = a21;
  // return (mk_cong ((= (f1 t1)) (f2 t2)) tail)
  return _e1132;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1146:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (add_nary_arg f s1 s2 ((= t1) t2))
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  if(a4->getNumChildren()!=2)
  {
    break;
  }
  Expr& a41 = a4->getChildren()[1];
  Expr& a40 = a4->getChildren()[0];
  if(a40->getNumChildren()!=2)
  {
    break;
  }
  Expr& a401 = a40->getChildren()[1];
  Expr& a400 = a40->getChildren()[0];
  // check requirements
  if (!(a4->getKind()==Kind::APPLY && a40->getKind()==Kind::APPLY && a400==_e52))
  {
     break;
  }
  // construct the context
  ctx[_e1156] = a2;
  ctx[_e1150] = a41;
  ctx[_e1151] = a3;
  ctx[_e1155] = a401;
  ctx[_e1152] = a1;
  // return ((= ((f s1) t1)) ((f s2) t2))
  return _e1160;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1161:
  {
     size_t _i=0;
     while (_i<3)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (mk_nary_cong_eq f alf.nil)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a2==_e32))
  {
     break;
  }
  // return ((= alf.nil) alf.nil)
  return _e1166;
  // construct the context
  // return ((= alf.nil) alf.nil)
  return _e1166;
       }
       break;
       // matching for arguments of (mk_nary_cong_eq f ((= s1) s2))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a200==_e52))
  {
     break;
  }
  // construct the context
  ctx[_e1167] = a21;
  ctx[_e1168] = a201;
  // return ((= s1) s2)
  return _e1170;
       }
       break;
       // matching for arguments of (mk_nary_cong_eq f ((and ((= s1) s2)) tail))
       case 3:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  if(a201->getNumChildren()!=2)
  {
    break;
  }
  Expr& a2011 = a201->getChildren()[1];
  Expr& a2010 = a201->getChildren()[0];
  if(a2010->getNumChildren()!=2)
  {
    break;
  }
  Expr& a20101 = a2010->getChildren()[1];
  Expr& a20100 = a2010->getChildren()[0];
  Expr& a200 = a20->getChildren()[0];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a201->getKind()==Kind::APPLY && a2010->getKind()==Kind::APPLY && a20100==_e52 && a200==_e44))
  {
     break;
  }
  // construct the context
  ctx[_e1172] = a1;
  ctx[_e1167] = a2011;
  ctx[_e1168] = a20101;
  ctx[_e1171] = a21;
  // return (add_nary_arg f s1 s2 (mk_nary_cong_eq f tail))
  return _e1174;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1245:
  {
     size_t _i=0;
     while (_i<9)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (arith_rel_sum < <)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e150 && a2==_e150))
  {
     break;
  }
  // return <
  return _e150;
  // construct the context
  // return <
  return _e150;
       }
       break;
       // matching for arguments of (arith_rel_sum < =)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e150 && a2==_e52))
  {
     break;
  }
  // return <
  return _e150;
  // construct the context
  // return <
  return _e150;
       }
       break;
       // matching for arguments of (arith_rel_sum < <=)
       case 3:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e150 && a2==_e161))
  {
     break;
  }
  // return <
  return _e150;
  // construct the context
  // return <
  return _e150;
       }
       break;
       // matching for arguments of (arith_rel_sum <= <)
       case 4:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e161 && a2==_e150))
  {
     break;
  }
  // return <
  return _e150;
  // construct the context
  // return <
  return _e150;
       }
       break;
       // matching for arguments of (arith_rel_sum <= =)
       case 5:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e161 && a2==_e52))
  {
     break;
  }
  // return <=
  return _e161;
  // construct the context
  // return <=
  return _e161;
       }
       break;
       // matching for arguments of (arith_rel_sum <= <=)
       case 6:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e161 && a2==_e161))
  {
     break;
  }
  // return <=
  return _e161;
  // construct the context
  // return <=
  return _e161;
       }
       break;
       // matching for arguments of (arith_rel_sum = <)
       case 7:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e52 && a2==_e150))
  {
     break;
  }
  // return <
  return _e150;
  // construct the context
  // return <
  return _e150;
       }
       break;
       // matching for arguments of (arith_rel_sum = =)
       case 8:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e52 && a2==_e52))
  {
     break;
  }
  // return =
  return _e52;
  // construct the context
  // return =
  return _e52;
       }
       break;
       // matching for arguments of (arith_rel_sum = <=)
       case 9:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e52 && a2==_e161))
  {
     break;
  }
  // return <=
  return _e161;
  // construct the context
  // return <=
  return _e161;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1250:
  {
     size_t _i=0;
     while (_i<5)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (arith_rel_inv =)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e52))
  {
     break;
  }
  // return =
  return _e52;
  // construct the context
  // return =
  return _e52;
       }
       break;
       // matching for arguments of (arith_rel_inv <)
       case 2:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e150))
  {
     break;
  }
  // return >
  return _e171;
  // construct the context
  // return >
  return _e171;
       }
       break;
       // matching for arguments of (arith_rel_inv <=)
       case 3:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e161))
  {
     break;
  }
  // return >=
  return _e181;
  // construct the context
  // return >=
  return _e181;
       }
       break;
       // matching for arguments of (arith_rel_inv >)
       case 4:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e171))
  {
     break;
  }
  // return <
  return _e150;
  // construct the context
  // return <
  return _e150;
       }
       break;
       // matching for arguments of (arith_rel_inv >=)
       case 5:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e181))
  {
     break;
  }
  // return <=
  return _e161;
  // construct the context
  // return <=
  return _e161;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1254:
  {
     size_t _i=0;
     while (_i<4)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (arith_rel_neg <)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e150))
  {
     break;
  }
  // return >=
  return _e181;
  // construct the context
  // return >=
  return _e181;
       }
       break;
       // matching for arguments of (arith_rel_neg <=)
       case 2:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e161))
  {
     break;
  }
  // return >
  return _e171;
  // construct the context
  // return >
  return _e171;
       }
       break;
       // matching for arguments of (arith_rel_neg >)
       case 3:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e171))
  {
     break;
  }
  // return <=
  return _e161;
  // construct the context
  // return <=
  return _e161;
       }
       break;
       // matching for arguments of (arith_rel_neg >=)
       case 4:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e181))
  {
     break;
  }
  // return <
  return _e150;
  // construct the context
  // return <
  return _e150;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1258:
  {
     size_t _i=0;
     while (_i<6)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (arith_rel_trichotomy = <)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e52 && a2==_e150))
  {
     break;
  }
  // return >
  return _e171;
  // construct the context
  // return >
  return _e171;
       }
       break;
       // matching for arguments of (arith_rel_trichotomy = >)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e52 && a2==_e171))
  {
     break;
  }
  // return <
  return _e150;
  // construct the context
  // return <
  return _e150;
       }
       break;
       // matching for arguments of (arith_rel_trichotomy > =)
       case 3:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e171 && a2==_e52))
  {
     break;
  }
  // return <
  return _e150;
  // construct the context
  // return <
  return _e150;
       }
       break;
       // matching for arguments of (arith_rel_trichotomy < =)
       case 4:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e150 && a2==_e52))
  {
     break;
  }
  // return >
  return _e171;
  // construct the context
  // return >
  return _e171;
       }
       break;
       // matching for arguments of (arith_rel_trichotomy > <)
       case 5:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e171 && a2==_e150))
  {
     break;
  }
  // return =
  return _e52;
  // construct the context
  // return =
  return _e52;
       }
       break;
       // matching for arguments of (arith_rel_trichotomy < >)
       case 6:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e150 && a2==_e171))
  {
     break;
  }
  // return =
  return _e52;
  // construct the context
  // return =
  return _e52;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1263:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (arith_normalize_lit (not ((r a) b)))
       case 1:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  if(a11->getNumChildren()!=2)
  {
    break;
  }
  Expr& a111 = a11->getChildren()[1];
  Expr& a110 = a11->getChildren()[0];
  if(a110->getNumChildren()!=2)
  {
    break;
  }
  Expr& a1101 = a110->getChildren()[1];
  Expr& a1100 = a110->getChildren()[0];
  Expr& a10 = a1->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a11->getKind()==Kind::APPLY && a110->getKind()==Kind::APPLY && a10==_e38))
  {
     break;
  }
  // construct the context
  ctx[_e1268] = a1100;
  ctx[_e1266] = a1101;
  ctx[_e1264] = a111;
  // return (((arith_rel_neg r) a) b)
  return _e1273;
       }
       break;
       // matching for arguments of (arith_normalize_lit ((r a) b))
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY))
  {
     break;
  }
  // construct the context
  ctx[_e1268] = a100;
  ctx[_e1266] = a101;
  ctx[_e1264] = a11;
  // return ((r a) b)
  return _e1275;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1276:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (mk_arith_sum_ub_step ((r1 a1) b1) ((r2 a2) b2))
       case 1:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY))
  {
     break;
  }
  // construct the context
  ctx[_e1279] = a11;
  ctx[_e1283] = a201;
  ctx[_e1292] = a100;
  ctx[_e1289] = a200;
  ctx[_e1277] = a21;
  ctx[_e1285] = a101;
  // return (((arith_rel_sum r1 r2) ((+ a1) a2)) ((+ b1) b2))
  return _e1297;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1298:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (mk_arith_sum_ub alf.nil)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e32))
  {
     break;
  }
  // return ((= alf.nil) alf.nil)
  return _e1166;
  // construct the context
  // return ((= alf.nil) alf.nil)
  return _e1166;
       }
       break;
       // matching for arguments of (mk_arith_sum_ub ((and ((r a) b)) tail))
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  if(a101->getNumChildren()!=2)
  {
    break;
  }
  Expr& a1011 = a101->getChildren()[1];
  Expr& a1010 = a101->getChildren()[0];
  if(a1010->getNumChildren()!=2)
  {
    break;
  }
  Expr& a10101 = a1010->getChildren()[1];
  Expr& a10100 = a1010->getChildren()[0];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a101->getKind()==Kind::APPLY && a1010->getKind()==Kind::APPLY && a100==_e44))
  {
     break;
  }
  // construct the context
  ctx[_e1303] = a10100;
  ctx[_e1301] = a10101;
  ctx[_e1299] = a1011;
  ctx[_e1308] = a11;
  // return (mk_arith_sum_ub_step ((r a) b) (mk_arith_sum_ub tail))
  return _e1310;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1317:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (mk_arith_mult_pos m ((r a) b))
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY))
  {
     break;
  }
  // construct the context
  ctx[_e1320] = a21;
  ctx[_e1332] = a200;
  ctx[_e1327] = a201;
  ctx[_e1324] = a1;
  // return (let ((_v0 (* m))) ((r (_v0 ((* a) alf.nil))) (_v0 ((* b) alf.nil))))
  return _e1336;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1354:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (mk_arith_mult_neg m ((r a) b))
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY))
  {
     break;
  }
  // construct the context
  ctx[_e1357] = a21;
  ctx[_e1369] = a200;
  ctx[_e1364] = a201;
  ctx[_e1361] = a1;
  // return (let ((_v0 (* m))) (((arith_rel_inv r) (_v0 ((* a) alf.nil))) (_v0 ((* b) alf.nil))))
  return _e1374;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1392:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (mk_arith_trichotomy ((r1 a) b) ((r2 a) b))
       case 1:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a2->getKind()==Kind::APPLY && a21==a11 && a20->getKind()==Kind::APPLY && a201==a101))
  {
     break;
  }
  // construct the context
  ctx[_e1397] = a101;
  ctx[_e1402] = a100;
  ctx[_e1399] = a200;
  ctx[_e1395] = a11;
  // return (((arith_rel_trichotomy r1 r2) a) b)
  return _e1405;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1453:
  {
     size_t _i=0;
     while (_i<3)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (is_string_type String)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e1450))
  {
     break;
  }
  // return true
  return _e25;
  // construct the context
  // return true
  return _e25;
       }
       break;
       // matching for arguments of (is_string_type (Seq U))
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10==_e1452))
  {
     break;
  }
  // return true
  return _e25;
  // construct the context
  // return true
  return _e25;
       }
       break;
       // matching for arguments of (is_string_type U)
       case 3:
       {
  const Expr& a1 = args[1];
  // check requirements
  // return false
  return _e26;
  // construct the context
  // return false
  return _e26;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1590:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (mk_emptystr (Seq U))
       case 1:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10==_e1452))
  {
     break;
  }
  // construct the context
  ctx[_e1591] = a11;
  // return (seq.empty (Seq U))
  return _e1594;
       }
       break;
       // matching for arguments of (mk_emptystr String)
       case 2:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e1450))
  {
     break;
  }
  // return ""
  return _e1595;
  // construct the context
  // return ""
  return _e1595;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1596:
  {
     size_t _i=0;
     while (_i<3)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (string_is_empty (seq.empty U))
       case 1:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10==_e1571))
  {
     break;
  }
  // return true
  return _e25;
  // construct the context
  // return true
  return _e25;
       }
       break;
       // matching for arguments of (string_is_empty "")
       case 2:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e1595))
  {
     break;
  }
  // return true
  return _e25;
  // construct the context
  // return true
  return _e25;
       }
       break;
       // matching for arguments of (string_is_empty x)
       case 3:
       {
  const Expr& a1 = args[1];
  // check requirements
  // return false
  return _e26;
  // construct the context
  // return false
  return _e26;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1652:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (string_concat t1 t2)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  // construct the context
  ctx[_e1656] = a1;
  ctx[_e1655] = a2;
  // return (nary.concat str.++ t1 t2)
  return _e1657;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1665:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (string_reduction_substr x n m U)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  // construct the context
  ctx[_e1666] = a4;
  ctx[_e1670] = a1;
  ctx[_e1669] = a2;
  ctx[_e1668] = a3;
  // return (let ((_v6 (skolem ((_v2 0) n)))) (let ((_v7 (str.len x))) (let ((_v1 ((+ n) ((+ m) alf.nil)))) (let ((_v3 ((- _v7) _v1))) (let ((_v5 (skolem ((_v2 _v1) _v3)))) (let ((_v4 (= (str.len _v5)))) (let ((_v2 (str.substr x))) (let ((_v0 (skolem ((_v2 n) m)))) (((ite ((and ((>= n) 0)) ((and ((> _v7) n)) ((and ((> m) 0)) alf.nil)))) ((and ((= x) ((str.++ _v6) ((str.++ _v0) ((str.++ _v5) alf.nil))))) ((and ((= (str.len _v6)) n)) ((and ((or (_v4 _v3)) ((or (_v4 0)) alf.nil))) ((and ((<= (str.len _v0)) m)) alf.nil))))) ((= _v0) (mk_emptystr U)))))))))))
  return _e1735;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1736:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (string_reduction_indexof x y n U)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  // construct the context
  ctx[_e1737] = a4;
  ctx[_e1741] = a1;
  ctx[_e1739] = a2;
  ctx[_e1740] = a3;
  // return (let ((_v4 (_v3 ((+ _v2) alf.nil)))) (let ((_v6 (str.++ _v1))) (let ((_v2 (str.len y))) (let ((_v7 (= (skolem (((str.indexof x) y) n))))) (let ((_v5 (str.substr _v0))) (let ((_v8 (str.len x))) (let ((_v0 (((str.substr x) n) ((- _v8) n)))) (let ((_v1 (skolem ((_v5 0) (((str.indexof _v0) y) 0))))) (let ((_v3 (+ (str.len _v1)))) (((ite ((or (not ((str.contains _v0) y))) ((or ((> n) _v8)) ((or ((> 0) n)) alf.nil)))) (_v7 -1)) (((ite ((= y) (mk_emptystr U))) (_v7 n)) ((and ((= _v0) (_v6 ((str.++ y) ((str.++ (skolem ((_v5 _v4) ((- (str.len _v0)) _v4)))) alf.nil))))) ((and (not ((str.contains (_v6 ((str.++ (((str.substr y) 0) ((- _v2) 1))) alf.nil))) y))) ((and (_v7 ((+ n) (_v3 alf.nil)))) alf.nil))))))))))))))
  return _e1825;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1826:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (string_reduction_pred (((str.substr x) n) m) U)
       case 1:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  if(a100->getNumChildren()!=2)
  {
    break;
  }
  Expr& a1001 = a100->getChildren()[1];
  Expr& a1000 = a100->getChildren()[0];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100->getKind()==Kind::APPLY && a1000==_e1470))
  {
     break;
  }
  // construct the context
  ctx[_e1830] = a101;
  ctx[_e1829] = a11;
  ctx[_e1831] = a1001;
  ctx[_e1827] = a2;
  // return (string_reduction_substr x n m U)
  return _e1832;
       }
       break;
       // matching for arguments of (string_reduction_pred (((str.indexof x) y) n) U)
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  if(a100->getNumChildren()!=2)
  {
    break;
  }
  Expr& a1001 = a100->getChildren()[1];
  Expr& a1000 = a100->getChildren()[0];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100->getKind()==Kind::APPLY && a1000==_e1493))
  {
     break;
  }
  // construct the context
  ctx[_e1830] = a11;
  ctx[_e1831] = a1001;
  ctx[_e1827] = a2;
  ctx[_e1833] = a101;
  // return (string_reduction_indexof x y n U)
  return _e1834;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1835:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (string_eager_reduction_contains t r U)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  // construct the context
  ctx[_e1839] = a1;
  ctx[_e1838] = a2;
  // return (let ((_v1 (str.substr t))) (let ((_v2 (skolem ((_v1 0) (((str.indexof t) r) 0))))) (let ((_v0 ((+ (str.len _v2)) ((+ (str.len r)) alf.nil)))) (let ((_v3 (= t))) (((ite ((str.contains t) r)) (_v3 ((str.++ _v2) ((str.++ r) ((str.++ (skolem ((_v1 _v0) ((- (str.len t)) _v0)))) alf.nil))))) (not (_v3 r)))))))
  return _e1873;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1900:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (string_eager_reduction_indexof x y n)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  // check requirements
  // construct the context
  ctx[_e1903] = a1;
  ctx[_e1906] = a2;
  ctx[_e1905] = a3;
  // return (let ((_v0 (((str.indexof x) y) n))) ((and ((or ((= _v0) -1)) ((or ((>= _v0) n)) alf.nil))) ((and ((<= _v0) (str.len x))) alf.nil)))
  return _e1923;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1924:
  {
     size_t _i=0;
     while (_i<3)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (mk_string_eager_reduction (str.to_code x) U)
       case 1:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10==_e1516))
  {
     break;
  }
  // construct the context
  ctx[_e1927] = a11;
  // return (let ((_v0 (str.to_code x))) (((ite ((= (str.len x)) 1)) ((and ((>= _v0) 0)) ((and ((< _v0) 196608)) alf.nil))) ((= _v0) -1)))
  return _e1944;
       }
       break;
       // matching for arguments of (mk_string_eager_reduction ((str.contains x) y) U)
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e1478))
  {
     break;
  }
  // construct the context
  ctx[_e1925] = a2;
  ctx[_e1927] = a101;
  ctx[_e1945] = a11;
  // return (string_eager_reduction_contains x y U)
  return _e1946;
       }
       break;
       // matching for arguments of (mk_string_eager_reduction (((str.indexof x) y) n) U)
       case 3:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  if(a100->getNumChildren()!=2)
  {
    break;
  }
  Expr& a1001 = a100->getChildren()[1];
  Expr& a1000 = a100->getChildren()[0];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100->getKind()==Kind::APPLY && a1000==_e1493))
  {
     break;
  }
  // construct the context
  ctx[_e1927] = a1001;
  ctx[_e1947] = a11;
  ctx[_e1945] = a101;
  // return (string_reduction_indexof x y n)
  return _e1948;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1949:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (re_unfold_pos_concat_step t (str.to_re s) ro i ((pair c) M))
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  const Expr& a5 = args[5];
  if(a5->getNumChildren()!=2)
  {
    break;
  }
  Expr& a51 = a5->getChildren()[1];
  Expr& a50 = a5->getChildren()[0];
  if(a50->getNumChildren()!=2)
  {
    break;
  }
  Expr& a501 = a50->getChildren()[1];
  Expr& a500 = a50->getChildren()[0];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20==_e1533 && a5->getKind()==Kind::APPLY && a50->getKind()==Kind::APPLY && a500==_e5))
  {
     break;
  }
  // construct the context
  ctx[_e1955] = a21;
  ctx[_e1954] = a501;
  ctx[_e1953] = a51;
  // return ((pair ((str.++ s) c)) M)
  return _e1959;
       }
       break;
       // matching for arguments of (re_unfold_pos_concat_step t r ro i ((pair ((= t) c)) M))
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  const Expr& a5 = args[5];
  if(a5->getNumChildren()!=2)
  {
    break;
  }
  Expr& a51 = a5->getChildren()[1];
  Expr& a50 = a5->getChildren()[0];
  if(a50->getNumChildren()!=2)
  {
    break;
  }
  Expr& a501 = a50->getChildren()[1];
  if(a501->getNumChildren()!=2)
  {
    break;
  }
  Expr& a5011 = a501->getChildren()[1];
  Expr& a5010 = a501->getChildren()[0];
  if(a5010->getNumChildren()!=2)
  {
    break;
  }
  Expr& a50101 = a5010->getChildren()[1];
  Expr& a50100 = a5010->getChildren()[0];
  Expr& a500 = a50->getChildren()[0];
  // check requirements
  if (!(a5->getKind()==Kind::APPLY && a50->getKind()==Kind::APPLY && a501->getKind()==Kind::APPLY && a5010->getKind()==Kind::APPLY && a50101==a1 && a50100==_e52 && a500==_e5))
  {
     break;
  }
  // construct the context
  ctx[_e1954] = a5011;
  ctx[_e1960] = a2;
  ctx[_e1961] = a4;
  ctx[_e1962] = a3;
  ctx[_e1953] = a51;
  ctx[_e1963] = a1;
  // return (let ((_v0 (skolem (((@k.RE_UNFOLD_POS_COMPONENT t) ro) i)))) ((pair ((str.++ _v0) c)) ((and ((str.in_re _v0) r)) M)))
  return _e1975;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1976:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (re_unfold_pos_concat_rec t alf.nil ro i)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  if (!(a2==_e32))
  {
     break;
  }
  // return ((pair alf.nil) alf.nil)
  return _e1979;
  // construct the context
  // return ((pair alf.nil) alf.nil)
  return _e1979;
       }
       break;
       // matching for arguments of (re_unfold_pos_concat_rec t ((re.++ r1) r2) ro i)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  const Expr& a3 = args[3];
  const Expr& a4 = args[4];
  // check requirements
  if (!(a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a200==_e1542))
  {
     break;
  }
  // construct the context
  ctx[_e1984] = a1;
  ctx[_e1986] = a201;
  ctx[_e1983] = a21;
  ctx[_e1982] = a3;
  ctx[_e1980] = a4;
  // return (re_unfold_pos_concat_step t r1 ro i (re_unfold_pos_concat_rec t r2 ro (alf.add i 1)))
  return _e1987;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 1993:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (non_empty_concats alf.nil U)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e32))
  {
     break;
  }
  // return alf.nil
  return _e32;
  // construct the context
  // return alf.nil
  return _e32;
       }
       break;
       // matching for arguments of (non_empty_concats ((str.++ t) s) U)
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e1460))
  {
     break;
  }
  // construct the context
  ctx[_e1994] = a2;
  ctx[_e1996] = a101;
  ctx[_e1998] = a11;
  // return (nary.append and ((= t) (mk_emptystr U)) (non_empty_concats s U))
  return _e2002;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 2017:
  {
     size_t _i=0;
     while (_i<3)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (string_first_char_or_empty alf.nil)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e32))
  {
     break;
  }
  // return alf.nil
  return _e32;
  // construct the context
  // return alf.nil
  return _e32;
       }
       break;
       // matching for arguments of (string_first_char_or_empty ((str.++ (seq.unit s)) tail))
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  if(a101->getNumChildren()!=2)
  {
    break;
  }
  Expr& a1011 = a101->getChildren()[1];
  Expr& a1010 = a101->getChildren()[0];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a101->getKind()==Kind::APPLY && a1010==_e1575 && a100==_e1460))
  {
     break;
  }
  // construct the context
  ctx[_e2020] = a1011;
  // return (seq.unit s)
  return _e2022;
       }
       break;
       // matching for arguments of (string_first_char_or_empty ((str.++ t) tail))
       case 3:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e1460))
  {
     break;
  }
  // construct the context
  ctx[_e2024] = a101;
  // return (alf.ite (check_true (alf.is_eq (alf.len t) 1)) t alf.fail)
  return _e2028;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 2029:
  {
     size_t _i=0;
     while (_i<1)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (string_flatten_word t)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  // construct the context
  ctx[_e2030] = a1;
  // return (alf.ite (check_true (alf.is_eq (alf.len t) 1)) (nary.append str.++ t alf.nil) (nary.append str.++ (alf.extract 0 1 t) (string_flatten_word (alf.extract 1 (str.len t) t))))
  return _e2040;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 2041:
  {
     size_t _i=0;
     while (_i<3)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (string_flatten alf.nil)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e32))
  {
     break;
  }
  // return alf.nil
  return _e32;
  // construct the context
  // return alf.nil
  return _e32;
       }
       break;
       // matching for arguments of (string_flatten ((str.++ ((str.++ t) tail2)) tail))
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  if(a101->getNumChildren()!=2)
  {
    break;
  }
  Expr& a1011 = a101->getChildren()[1];
  Expr& a1010 = a101->getChildren()[0];
  if(a1010->getNumChildren()!=2)
  {
    break;
  }
  Expr& a10101 = a1010->getChildren()[1];
  Expr& a10100 = a1010->getChildren()[0];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a101->getKind()==Kind::APPLY && a1010->getKind()==Kind::APPLY && a10100==_e1460 && a100==_e1460))
  {
     break;
  }
  // construct the context
  ctx[_e2045] = a10101;
  ctx[_e2048] = a11;
  ctx[_e2044] = a1011;
  // return (nary.concat str.++ ((str.++ t) tail2) (string_flatten tail))
  return _e2050;
       }
       break;
       // matching for arguments of (string_flatten ((str.++ t) tail))
       case 3:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e1460))
  {
     break;
  }
  // construct the context
  ctx[_e2045] = a101;
  ctx[_e2048] = a11;
  // return (let ((_v0 (string_flatten tail))) (alf.ite (check_true (alf.is_neg (alf.add 1 (alf.neg (alf.len t))))) (nary.concat str.++ (string_flatten_word t) _v0) (nary.append str.++ t _v0)))
  return _e2059;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 2060:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (string_collect_acc alf.nil)
       case 1:
       {
  const Expr& a1 = args[1];
  // check requirements
  if (!(a1==_e32))
  {
     break;
  }
  // return ((pair alf.nil) alf.nil)
  return _e1979;
  // construct the context
  // return ((pair alf.nil) alf.nil)
  return _e1979;
       }
       break;
       // matching for arguments of (string_collect_acc ((str.++ t) tail))
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e1460))
  {
     break;
  }
  // construct the context
  ctx[_e2066] = a101;
  ctx[_e2065] = a11;
  // return (alf.ite (check_true (alf.is_eq (alf.len t) 1)) (_internal_2 (string_collect_acc tail) t tail) ((pair alf.nil) ((str.++ t) tail)))
  return _e2076;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 2077:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (string_collect alf.nil U)
       case 1:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1==_e32))
  {
     break;
  }
  // return alf.nil
  return _e32;
  // construct the context
  // return alf.nil
  return _e32;
       }
       break;
       // matching for arguments of (string_collect ((str.++ t) s) U)
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  const Expr& a2 = args[2];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e1460))
  {
     break;
  }
  // construct the context
  ctx[_e2078] = a2;
  ctx[_e2081] = a101;
  ctx[_e2082] = a11;
  // return (_internal_3 (string_collect_acc t U) U s t)
  return _e2084;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 2085:
  {
     size_t _i=0;
     while (_i<2)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (let ((_v0 (str.++ t))) (strip_prefix (_v0 t2) (_v0 s2)))
       case 1:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  const Expr& a2 = args[2];
  if(a2->getNumChildren()!=2)
  {
    break;
  }
  Expr& a21 = a2->getChildren()[1];
  Expr& a20 = a2->getChildren()[0];
  if(a20->getNumChildren()!=2)
  {
    break;
  }
  Expr& a201 = a20->getChildren()[1];
  Expr& a200 = a20->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e1460 && a2->getKind()==Kind::APPLY && a20->getKind()==Kind::APPLY && a201==a101 && a200==_e1460))
  {
     break;
  }
  // construct the context
  ctx[_e2091] = a11;
  ctx[_e2090] = a21;
  // return (strip_prefix t2 s2)
  return _e2092;
       }
       break;
       // matching for arguments of (strip_prefix t s)
       case 2:
       {
  const Expr& a1 = args[1];
  const Expr& a2 = args[2];
  // check requirements
  // construct the context
  ctx[_e2094] = a1;
  ctx[_e2093] = a2;
  // return ((pair t) s)
  return _e2096;
       }
       break;
       default: break;
       }
     }
  }
  break;
  case 2217:
  {
     size_t _i=0;
     while (_i<9)
     {
       _i++;
       switch(_i)
       {
       // matching for arguments of (run_evaluate ((= a) b))
       case 1:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e52))
  {
     break;
  }
  // construct the context
  ctx[_e2223] = a101;
  ctx[_e2220] = a11;
  // return (alf.is_eq (run_evaluate a) (run_evaluate b))
  return _e2226;
       }
       break;
       // matching for arguments of (run_evaluate ((< a) b))
       case 2:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e150))
  {
     break;
  }
  // construct the context
  ctx[_e2223] = a101;
  ctx[_e2220] = a11;
  // return (alf.is_neg (run_evaluate ((- a) b)))
  return _e2230;
       }
       break;
       // matching for arguments of (run_evaluate ((<= a) b))
       case 3:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e161))
  {
     break;
  }
  // construct the context
  ctx[_e2223] = a101;
  ctx[_e2220] = a11;
  // return (let ((_v0 (run_evaluate ((- a) b)))) (alf.or (alf.is_neg _v0) (alf.is_zero _v0)))
  return _e2232;
       }
       break;
       // matching for arguments of (run_evaluate ((> a) b))
       case 4:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e171))
  {
     break;
  }
  // construct the context
  ctx[_e2223] = a101;
  ctx[_e2220] = a11;
  // return (alf.is_neg (run_evaluate ((- b) a)))
  return _e2236;
       }
       break;
       // matching for arguments of (run_evaluate ((>= a) b))
       case 5:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e181))
  {
     break;
  }
  // construct the context
  ctx[_e2223] = a101;
  ctx[_e2220] = a11;
  // return (let ((_v0 (run_evaluate ((- b) a)))) (alf.or (alf.is_neg _v0) (alf.is_zero _v0)))
  return _e2238;
       }
       break;
       // matching for arguments of (run_evaluate ((+ a) ((+ b) alf.nil)))
       case 6:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  if(a11->getNumChildren()!=2)
  {
    break;
  }
  Expr& a111 = a11->getChildren()[1];
  Expr& a110 = a11->getChildren()[0];
  if(a110->getNumChildren()!=2)
  {
    break;
  }
  Expr& a1101 = a110->getChildren()[1];
  Expr& a1100 = a110->getChildren()[0];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a11->getKind()==Kind::APPLY && a111==_e32 && a110->getKind()==Kind::APPLY && a1100==_e132 && a10->getKind()==Kind::APPLY && a100==_e132))
  {
     break;
  }
  // construct the context
  ctx[_e2223] = a101;
  ctx[_e2220] = a1101;
  // return (alf.add (run_evaluate a) (run_evaluate b))
  return _e2239;
       }
       break;
       // matching for arguments of (run_evaluate ((- a) b))
       case 7:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a10->getKind()==Kind::APPLY && a100==_e138))
  {
     break;
  }
  // construct the context
  ctx[_e2223] = a101;
  ctx[_e2220] = a11;
  // return (alf.add (run_evaluate a) (alf.neg (run_evaluate b)))
  return _e2241;
       }
       break;
       // matching for arguments of (run_evaluate ((* a) ((* b) alf.nil)))
       case 8:
       {
  const Expr& a1 = args[1];
  if(a1->getNumChildren()!=2)
  {
    break;
  }
  Expr& a11 = a1->getChildren()[1];
  if(a11->getNumChildren()!=2)
  {
    break;
  }
  Expr& a111 = a11->getChildren()[1];
  Expr& a110 = a11->getChildren()[0];
  if(a110->getNumChildren()!=2)
  {
    break;
  }
  Expr& a1101 = a110->getChildren()[1];
  Expr& a1100 = a110->getChildren()[0];
  Expr& a10 = a1->getChildren()[0];
  if(a10->getNumChildren()!=2)
  {
    break;
  }
  Expr& a101 = a10->getChildren()[1];
  Expr& a100 = a10->getChildren()[0];
  // check requirements
  if (!(a1->getKind()==Kind::APPLY && a11->getKind()==Kind::APPLY && a111==_e32 && a110->getKind()==Kind::APPLY && a1100==_e144 && a10->getKind()==Kind::APPLY && a100==_e144))
  {
     break;
  }
  // construct the context
  ctx[_e2223] = a101;
  ctx[_e2220] = a1101;
  // return (alf.mul (run_evaluate a) (run_evaluate b))
  return _e2242;
       }
       break;
       // matching for arguments of (run_evaluate z)
       case 9:
       {
  const Expr& a1 = args[1];
  // check requirements
  // construct the context
  ctx[_e2243] = a1;
  // return z
  return _e2243;
       }
       break;
       default: break;
       }
     }
  }
  break;
  default: break;
  }
  return d_state.mkExprInternal(Kind::APPLY, args);
}

}

