(include "../theories/Builtin.smt2")
(include "../theories/Arith.smt2")

(declare-sort Bag 1)

;(declare-const bag.empty (-> (! Type :var T) T))

(declare bag.empty (! s sort term))
(declare f_bag.union_max term)
(define bag.union_max (# x term (# y term (apply (apply f_bag.union_max x) y))))
(declare f_bag.union_disjoint term)
(define bag.union_disjoint (# x term (# y term (apply (apply f_bag.union_disjoint x) y))))
(declare f_bag.inter_min term)
(define bag.inter_min (# x term (# y term (apply (apply f_bag.inter_min x) y))))
(declare f_bag.difference_subtract term)
(define bag.difference_subtract (# x term (# y term (apply (apply f_bag.difference_subtract x) y))))
(declare f_bag.difference_remove term)
(define bag.difference_remove (# x term (# y term (apply (apply f_bag.difference_remove x) y))))
(declare f_bag.subbag term)
(define bag.subbag (# x term (# y term (apply (apply f_bag.subbag x) y))))
(declare f_bag.count term)
(define bag.count (# x term (# y term (apply (apply f_bag.count x) y))))
(declare f_bag term)
(define bag (# x term (# y term (apply (apply f_bag x) y))))
(declare f_bag.duplicate_removal term)
(define bag.duplicate_removal (# x term (apply f_bag.duplicate_removal x)))
(declare f_bag.card term)
(define bag.card (# x term (apply f_bag.card x)))
(declare f_bag.choose term)
(define bag.choose (# x term (apply f_bag.choose x)))
(declare f_bag.is_singleton term)
(define bag.is_singleton (# x term (apply f_bag.is_singleton x)))
(declare f_bag.from_set term)
(define bag.from_set (# x term (apply f_bag.from_set x)))
(declare f_bag.to_set term)
(define bag.to_set (# x term (apply f_bag.to_set x)))
(declare f_bag.member term)
(define bag.member (# x term (# y term (apply (apply f_bag.member x) y))))
(declare f_bag.map term)
(define bag.map (# x term (# y term (apply (apply f_bag.map x) y))))
(declare f_bag.filter term)
(define bag.filter (# x term (# y term (apply (apply f_bag.filter x) y))))
(declare f_bag.fold term)
(define bag.fold (# x term (# y term (# z term (apply (apply (apply f_bag.fold x) y) z)))))
(declare f_table.product term)
(define table.product (# x term (# y term (apply (apply f_table.product x) y))))
