(include "../proofs/rules/Cvc5.smt2")
(declare-sort U 0)
(declare-fun f (U U) U)
(declare-fun p2 () Bool)
(declare-fun p3 () Bool)
(declare-fun p1 () Bool)
(declare-fun c () U)
(declare-fun d () U)
(declare-fun a () U)
(declare-fun b () U)
(assume @p1 (= a b))
(assume @p2 (= c d))
(assume @p3 (and p1 true))
(assume @p4 (or (not p1) (and p2 p3)))
(assume @p5 (or (not p3) (not (= (f a c) (f b d)))))
(step @p6 (and (= c d) (= a b)) :rule and_intro :premises (@p2 @p1))
; trust THEORY_REWRITE
(step @p7 (= (and p1 true) p1) :rule trust :args ((= (and p1 true) p1)))
(step @p8 p1 :rule eq_resolve :premises (@p3 @p7))
(step @p9 (and (or (not p1) (and p2 p3)) p1) :rule and_intro :premises (@p4 @p8))
(step @p10 (and p2 p3) :rule chain_resolution :premises (@p9) :args ((and false p1)))
; trust CNF_AND_POS
(step @p11 (or (not (and p2 p3)) p3) :rule trust :args ((or (not (and p2 p3)) p3)))
(step @p12 (or p3 (not (and p2 p3))) :rule reordering :premises (@p11) :args ((or p3 (not (and p2 p3)))))
(step @p13 (let ((_let_1 (and p2 p3))) (and (or p3 (not _let_1)) _let_1)) :rule and_intro :premises (@p12 @p10))
(step @p14 p3 :rule chain_resolution :premises (@p13) :args ((and false (and p2 p3))))
(step @p15 (and (or (not p3) (not (= (f a c) (f b d)))) p3) :rule and_intro :premises (@p5 @p14))
(step @p16 (not (= (f a c) (f b d))) :rule chain_resolution :premises (@p15) :args ((and false p3)))
(step @p17 (and (not (= (f a c) (f b d))) (= c d) (= a b)) :rule and_intro_nary :premises (@p16 @p6))
(push @p32 (= a b))
(push @p33 (= c d))
(step @p20 (= f f) :rule refl :args (f))
(step @p21 (= (@ f a) (@ f b)) :rule ho_cong :premises (@p20 @p1))
(step @p22 (= (f a c) (f b d)) :rule ho_cong :premises (@p21 @p2))
(pop @p23 (=> (= c d) (= (f a c) (f b d))) :rule scope :premises (@p22))
(pop @p24 (=> (= a b) (=> (= c d) (= (f a c) (f b d)))) :rule scope :premises (@p23))
(step @p25 (=> (and (= a b) (= c d)) (= (f a c) (f b d))) :rule process_scope :premises (@p24) :args ((= (f a c) (f b d))))
(step @p26 (or (not (and (= a b) (= c d))) (= (f a c) (f b d))) :rule implies_elim :premises (@p25))
(step @p27 (let ((_let_1 (= c d))) (let ((_let_2 (= a b))) (or (and _let_2 _let_1) (not _let_2) (not _let_1)))) :rule cnf_and_neg :args ((and (= a b) (= c d))))
(step @p28 (or (not (= a b)) (not (= c d)) (= (f a c) (f b d))) :rule resolution :premises (@p27 @p26) :args (true (and (= a b) (= c d))))
(step @p29 (or (= (f a c) (f b d)) (not (= a b)) (not (= c d))) :rule reordering :premises (@p28) :args ((or (= (f a c) (f b d)) (not (= a b)) (not (= c d)))))
(step @p30 (let ((_let_1 (= a b))) (let ((_let_2 (= c d))) (let ((_let_3 (= (f a c) (f b d)))) (and (or _let_3 (not _let_1) (not _let_2)) (not _let_3) _let_2 _let_1)))) :rule and_intro_nary :premises (@p29 @p17))
(step @p31 false :rule chain_resolution :premises (@p30) :args ((and true (= (f a c) (f b d)) false (= c d) false (= a b))))

