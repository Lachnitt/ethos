(declare-sort @List 0)
(declare-const @list.nil @List)
(declare-const @list.cons (-> (! Type :var T :implicit) T @List @List) :right-assoc-nil @list.nil)

(declare-sort Int 0)

(declare-const P (-> Int Bool))
(declare-const forall (-> Bool Bool) :binder @list.cons)

(declare-rule id ((y Bool)) :premises (y) :conclusion y)

(assume @p0 (forall ((x Int)) (P x)))
(assume @p2 (forall ((x Int)) false))


; should match
(step @p1 (forall ((x Int)) (P x)) :rule id :premises (@p0))

; wrong
; (step @p1 (forall ((z Int)) (P z)) :rule id :premises (@p0))


(declare-rule q-rule ((xs @List))
  :premises ((forall xs false))
  :conclusion false)

(step @p3 false :rule q-rule :premises (@p2))
