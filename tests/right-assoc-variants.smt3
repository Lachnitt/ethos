
(declare-sort Int 0)
(declare-sort Real 0)
(declare-const BitVec (-> Int Type))
(declare-sort String 0)
(declare-type Seq (Type))

(program maybe_nil ((T Type) (t T) (U Type))
    (T U) T
    (
      ((maybe_nil t t)       t)
      ((maybe_nil t alf.null) t)
    )
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(declare-const and
(->
    Bool
    Bool
    Bool
) :right-assoc-nil true)

;;;;;; (-> Bool (-> U (maybe_nil Bool U)))
;;;;;; (-> Bool (-> U (Requires (alf.ite (alf.is_eq U alf.null) Bool U) Bool Bool)))
;;;;;; (-> Bool (-> U (alf.ite (alf.is_eq U alf.null) Bool (Requires U Bool Bool))))


(declare-const and2
(->
    Bool
    Bool
    Bool
) :right-assoc-nil true)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(declare-parameterized-const bvand ((m Int))
(-> (BitVec m)
    (BitVec m)
    (BitVec m))
:right-assoc-nil (alf.not (alf.to_bin m 0)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program arith_typeunion_nary ()
    (Type Type) Type
    (
      ((arith_typeunion_nary Int Real) Real)
      ((arith_typeunion_nary Int Int) Int)
      ((arith_typeunion_nary Int alf.null) Int)
      ((arith_typeunion_nary Real Real) Real)
      ((arith_typeunion_nary Real Int) Real)
      ((arith_typeunion_nary Real alf.null) Real)
    )
)

(declare-const +
(->
    (! Type :var T :implicit)
    (! Type :var U :implicit)
    T
    U
    (arith_typeunion_nary T U)
) :right-assoc-nil 0)

;;;;;; (-> T (-> U (arith_typeunion_nary T U)))
;;;;;; (-> T (-> U (alf.ite (alf.is_eq U alf.null) (arith_typeunion_nary T U) (Requires U U (arith_typeunion_nary T U)))))
;;;;;; which simplifies to (-> T (-> U (arith_typeunion_nary T U)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program is_string_type ((U Type))
    (Type) Bool
    (
      ((is_string_type String) true)
      ((is_string_type (Seq U)) true)
      ((is_string_type U) false)
    )
)
(declare-const seq.empty (-> (! Type :var T) T))
(program mk_emptystr ((U Type))
  (Type) U
  (
    ((mk_emptystr String)  "")
    ((mk_emptystr (Seq U)) (seq.empty (Seq U)))
  )
)
(declare-parameterized-const str.++ ((T Type))
  (-> (Seq T) (Seq T) (Seq T)) :right-assoc-nil (mk_emptystr T))


;;;;;; (-> T (-> U (Requires (is_string_type T) true (Requires (maybe_nil T U) T T))))
;;;;;; (-> T (Requires (is_string_type T) true (-> U (alf.ite (alf.is_eq U alf.null) T T))))



; (-> t1 (-> t2 t3)) :right-assoc-nil
;   is
; (-> t1 (-> U (alf.ite (alf.is_eq U alf.null) t3 (Requires U t2 t3))))

; (-> t1 (-> t2 t3)) :left-assoc-nil
;   is
; (-> U (alf.ite (alf.is_eq U alf.null) (-> t2 t3) (Requires U t1 (-> t2 t3))))
; ????


;(declare-const = (-> (! Type :var A :implicit) A A Bool) :chainable and)
;(declare-rule refl ((T Type) (x T))
;    :args (x)
;    :conclusion (= x x))
;(step @p0 (= t t) :rule refl :args (t))
