# Introduction

This is the user manual for the AletheLF checker (alfc). It is a high performance proof checking tool for the AletheLF language.

## The AletheLF (ALF) language

The AletheLF (ALF) language is an extension of SMT-LIB version 3.0 for defining proof rules and writing proofs from SMT solvers. The core features of this language include:
- Support for SMT-LIB version 3.0 syntax for defining theory signatures. This includes support for associating literals (as specified by SMT-LIB categories e.g. `<numeral>`) with types.
- A set of commands for specifying proofs (`step`, `assume`, and so on), whose syntax closely follows the Alethe proof format.
- A command for defining proof rules (`declare-rule`).


## The ALF checker (alfc)

The AletheLF checker (alfc) supports the core language of ALF and extends this language with several features:
- A library of operations (`alf.add`, `alf.mul`, `alf.concat`, `alf.extract`) for performing computations over literals.
- A command for defining side conditions (`program`) as a list of rewrite rules.
- Support for user-provided oracles via the command `declare-oracle-fun`, which can be used e.g. for modular proof checking.
- Support for file inclusion (`include`) and referencing (`reference`). The latter command can be used to specify the name of a *.smt2 that the proof is associated with.

In the following sections, we review these features in more detail. A full syntax for the commands is given at the end of this document.


# Declaring theory signatures

The ALF language is built on SMT-LIB version 3.0 and can be used a framework for defining theories. Note that the core language of ALF does not assume any definitions of SMT-LIB theories. Instead SMT-LIB theories may defined as ALF signatures. Specifically, the ALF language has the following builtin expressions:
- `Type`, denoting the kind of all types,
- `->`, denoting the function type,
- `_`, denoting (higher-order) function application,
- `Bool`, denoting the Boolean type,
- `true` and `false`, denoting constants of type `Bool`.

In ALF, a common BNF is used to specify terms, types and kinds. In the following, we informally write BNF categories `<symbol>` to denote an SMT-LIB version 3.0 symbol, `<term>` to denote an arbitrary SMT-LIB term and `<type>` to denote an SMT-LIB term whose type is `Type`, `<sorted-var-list>`

The following commands are supported for declaring and defining types and terms, most of which are taken from SMT-LIB version 3.0:
- `(declare-const <symbol> <type>)` declares a new term named `<symbol>` whose type is `<type>`.
- `(declare-fun <symbol> (<type>*) <type>)` declares a new term named `<symbol>` whose type is specified by the given argument types and return type.
- `(declare-sort <symbol> <numeral>)` declares a new type named `<symbol>` whose kind is `(-> Type^n Type)` if `n>0` or `Type` for the provided numeral `n`.
- `(declare-type <symbol> (<type>*))` declares a new type named `<symbol>` whose kind is specified by the given argument types and return type `Type`.
- `(define-const <symbol> <term>)` defines `<symbol>` to be the given term.
- `(define-fun <symbol> (<sorted-var>*) <type> <term>)` defines `<symbol>` to be a lambda term whose arguments, return type and body and given by the three arguments, or the body if the argument list is empty.
- `(define-sort <symbol> (<symbol>*) <type>)` defines `<symbol>` to be a lambda term whose arguments are given by variables of kind `Type` and whose body is given by the return type, or the return type if the argument is empty.
- `(define-type <symbol> (<type>*) <type>)` defines `<symbol>` to be a lambda term whose kind is given
- `(declare-datatype <datatype-def>)`
- `(declare-datatypes <datatypes-def>)`
- `(declare-consts <literal-category> <type>)` declares the class of symbols denoted by the literal category to have the given type.

### Basic Declarations

```
(declare-sort Int 0)
(declare-const c Int)
(declare-const f (-> Int Int Int))
(declare-fun g (Int Int) Int)
(declare-fun P (Int) Bool)
```

Since alfc does not assume any builtin definitions of SMT-LIB theories, definitions of standard symbols (such as `Int`) may be provided in ALF signatures. In the above example, `c` is declared to be a constant (0-ary) symbol of type `Int`. The symbol `f` is a function taking two integers and returning an integer.

Note that despite using different syntax in their declarations, the types of `f` and `g` in the above example are identical.

> In alfc, all functions are unary. In the above example, `(-> Int Int Int)` is internally treated as `(-> Int (-> Int Int))`.

### Definitions

```
(declare-const not (-> Bool Bool))
(define-fun id ((x Bool)) Bool x)
(define-fun notId ((x Int)) Bool (not (id x)))
```

In the example above, `not` is declared to be a unary function over Booleans. Two defined functions are given, the first being an identity function over Booleans, and the second returning the negation of the first.

> Internally, `id` is mapped to the lambda term whose SMT-LIB version 3 syntax is `(lambda ((x Bool)) x)`.

By default, defined functions are treated as macros and are eagerly beta-reduced. Thus, `notId` is mapped to the lambda term `(lambda ((x Bool)) (not x))`. Furthermore, the following file is equivalent to the one above:
```
(declare-const not (-> Bool Bool))
(define-fun id ((x Bool)) Bool x)
(define-fun notId ((x Int)) Bool (not x))
```

## Polymorphic types

```
(declare-sort Int 0)
(declare-sort Array 2)
(declare-const a (Array Int Bool))

(define-sort IntArray (T) (Array Int T))
(declare-const b (IntArray Bool))
```

In the above example, we define the integer sort and the array sort, whose kind is `(-> Type Type Type)`.

Note the following declarations all generate types of the same kind:

```
(declare-sort Array_v1 2)
(declare-type Array_v2 (Type Type))
(declare-const Array_v3 (-> Type Type Type))
```

## Variable and implicit annotations

The ALF language uses the standard term annotations `:var` and `:implicit` for naming arguments of functions and specifying they are implicit.

```
(declare-sort Int 0)
(declare-const eq (-> (! Type :var T) T T Bool))
(define-fun P ((x Int) (y Int)) Bool (eq Int x y))
```

The above example declares a predicate `eq` whose first argument is a type, that is given a name `T`. It then expects two terms of type `T` and returns a `Bool`. In the definition of `P`, this predicate is applied to two variables, where the type `Int` must be explicitly provided.

```
(declare-sort Int 0)
(declare-const = (-> (! Type :var T :implicit) T T Bool))
(define-fun P ((x Int) (y Int)) Bool (= x y))
```

In contrast, the above example declares a predicate `=` where the type of the arguments is implicit (this corresponds to the SMT-LIB standard definition of equality). In the definition of `P`, the type of the arguments `Int` does not need to be provided.

We call `T` in the above definitions a *parameter*. The free parameters of the return type of an expression should be contained in at least one non-implicit argument. In particular, the following declaration is malformed, since the return type of `f` cannot be inferred from its arguments:


```
(declare-sort Int 0)
(declare-const f (-> (! Type :var T :implicit) Int T))
```

## Declarations with attributes

The ALF language supports term annotations on declared functions, which can allow the user to treat a declared function as being variadic, i.e. taking an arbitrary number of arguments. These annotations are:
- `:right-assoc` (resp. `:left-assoc`) denoting that the term is right (resp. left) associative,
- `:right-assoc-nil <term>` (resp. `:left-assoc-nil <term>`) denoting that the term is right (resp. left) associative with the given nil terminator,
- `:list`, denoting that the term should be treated as a list when appearing as a child of an application of a right (left) associative operator,
- `:chainable <term>` denoting that the arguments of the term are chainable using the given (binary) operator,
- `:pairwise <term>` denoting that the arguments of term are treated pairwise using the given (binary) operator.

### Right/Left associative

```
(declare-const or (-> Bool Bool Bool) :right-assoc)
(define-fun P ((x Bool) (y Bool) (z Bool)) Bool (or x y z))
(define-fun Q ((x Bool) (y Bool)) Bool (or x y))
(define-fun R ((x Bool)) (-> Bool Bool) (or x))
```

In the above example, `(or x y z)` is syntax sugar for `(or x (or y z))`.
The term `(or x y)` is not impacted by the annotation `:right-assoc` since it has fewer than 3 children.
The term `(or x)` is also not impacted by the annotation, and denotes the partial application of `or` to `x`, whose type is `(-> Bool Bool)`.

```
(declare-const and (-> Bool Bool Bool) :left-assoc)
(define-fun P ((x Bool) (y Bool) (z Bool)) Bool (and x y z))
```

Similarly, in the above example, `(and x y z)` is syntax sugar for `(and (and x y) z)`.

Note that the type for right and left associative operators is typically `(-> T T T)` for some `T`.

### Right/Left associative with nil terminator

ALF supports a variant of the aforementioned functionality where a nil terminator is provided.

```
(declare-const or (-> Bool Bool Bool) :right-assoc-nil false)
(define-fun P ((x Bool) (y Bool) (z Bool)) Bool (or x y z))
(define-fun Q ((x Bool) (y Bool)) Bool (or x y))
(define-fun R ((x Bool) (y Bool)) Bool (or x))
```

In the above example, `(or x y z)` is syntax sugar for `(or x (or y (or z false)))`,
`(or x y)` is syntax sugar for `(or x (or y false))`,
and `(or x)` is syntax sugar for `(or x false)`.

The advantage of right (resp. left) associative operators nil terminators is that the terms they specify are unambiguous, in constrast to operators without nil terminators.
In particular, note the following example:

```
(declare-const or (-> Bool Bool Bool) :right-assoc-nil false)
(define-fun P ((x Bool) (y Bool) (z Bool)) Bool (or x (or y z)))
(define-fun Q ((x Bool) (y Bool) (z Bool)) Bool (or x y z))
```

If `or` would have been marked `:right-assoc`, then the definition of both `P` and `Q` would be `(or x (or y z))` after desugaring.
In contrast, marking `or` with `:right-assoc-nil false` leads to the distinct terms `(or x (or (or y z) false))` and `(or x (or y (or z false)))` after desugaring.

Right and left associative operators with nil terminators also have a relationship with list variables (as we will see in the following section), and in computational operators.

Note that the type for right and left associative operators with nil terminators is typically `(-> T T T)` for some `T`, where their nil terminator has type `T`.

### List variables

Symbols can be marked with the annotation `:list`. Conceptually, this annotation marks that the term should be treated as a list of arguments when it occurs as an argument of a right (left) associative operator with a nil element. Note the following example:

```
(declare-const or (-> Bool Bool Bool) :right-assoc-nil false)
(define-fun P ((x Bool) (y Bool)) Bool (or x y))
(define-fun Q ((x Bool) (y Bool :list)) Bool (or x y))
(declare-const a Bool)
(declare-const b Bool)
(define-const Paab Bool (P a (or a b)))
(define-const Qaab Bool (Q a (or a b)))
```

In the above example, note that `or` has been marked `:right-assoc-nil false`.
As before, the definition of `P` is syntax sugar for `(or x (or y false))`.
In contrast, the definition of `Q` is simply `(or x y)`, since `y` has been marked with `:list`.
Conceptually, our definition of `Q` denotes that we expect to `y` to be treated as the tail of `or` in the body of `Q`.

Then, `P` and `Q` are both applied to the pair of arguments `a` and `(or a b)`.
In the former (i.e. `Paab`), the definition is equivalent after desugaring to `(or a (or (or a (or b false)) false))`, whereas in the latter (i.e. `Qaab`) the definition is equivalent after desugaring to `(or a (or a (or b false)))`.
In other words, the definitions of `Paab` and `Qaab` are equivalent to the terms `(or a (or a b))` and `(or a a b)` respectively prior to desugaring.

More generally, for an right-associative operator `f` with nil terminator `nil`,
the term `(f t1 ... tn)` is de-sugared based on whether each `t1 ... tn` is marked with `:list`.
- The nil terminator is inserted at the end unless `tn` is marked as `:list`,
- When `ti` is marked as `:list` where `i<n`, then the term denotes the result of a concatentation operation. We will describe this in more detail later.


### Chainable

```
(declare-sort Int 0)
(declare-const and (-> Bool Bool Bool) :right-assoc)
(declare-const >= (-> Int Int Bool) :chainable)
(define-fun P ((x Int) (y Int) (z Int)) Bool (>= x y z))
(define-fun Q ((x Int) (y Int)) Bool (>= x y))
```

In the above example, `(>= x y z w)` is syntax sugar for `(and (>= x y) (>= y z))`,
whereas the term `(>= x y)` is not impacted by the annotation `:chainable` since it has fewer than 3 children.

Note that the type for chainable operators is typically `(-> T T S)` for some types `T` and `S`,
where the type of its chaining operator is `(-> S S S)`.

### Pairwise

```
(declare-sort Int 0)
(declare-const and (-> Bool Bool Bool) :right-assoc)
(declare-const distinct (-> (! Type :var T :implicit) T T Bool) :pairwise and)
(define-fun P ((x Int) (y Int) (z Int)) Bool (distinct x y z))
```
In the above example, `(distinct x y z)` is syntax sugar for `(and (distinct x y) (distinct x z) (distinct y z))`.

Note that the type for chainable operators is typically `(-> T T S)` for some types `T` and `S,
where the type of its chaining operator is `(-> S S S)`.

## Literal types

The ALF language supports associating SMT-LIB version 3.0 syntactic categories with types. In detail, a syntax category is one of the following:
- `<numeral>` denoting the category of numerals `<digit>+`,
- `<decimal>` denoting the category of decimals `<digit>+.<digit>+`,
- `<rational>` denoting the category of rationals `<digit>+/<digit>+`,
- `<binary>` denoting the category of binary constants `#b<0|1>+`,
- `<hexadecimal>` denoting the category of hexadecimal constants `#x<hex-digit>+`,
- `<string>` denoting the category of string literals `"<char>*"`.
Apart from `<rational>`, these literals have the same syntax as in SMT-LIB version 3.0.

### Declare constants

```
(declare-sort Int 0)
(declare-consts <numeral> Int)
(declare-fun P ((x Int)) Bool (> x 7))
```

In the above example, the `declare-consts` command specifies that numerals (`1`, `2`, `3`, and so on) have type `Int`.
The signature can now refer to arbitrary numerals in definitions, e.g. `7` in the definition of `P`.


# Declaring Proof Rules

The ALF language supports a command `declare-rule` for defining proof rules. Its syntax is given by:
```
(declare-rule <symbol> (<sorted-var>*) <assumption>? <premises>? <arguments>? <requirements>? :conclusion <term>)
where
<assumption>    ::= :assumption <term>
<premises>      ::= :premises (<term>*) | :premise-list <term> <term>
<arguments>     ::= :args (<term>*)
<requirements>  ::= :requires ((<term> <term>)*)
```

A proof rule begins by defining a list of free parameters, followed by 4 optional fields and a conclusion term.
These fields include:
- `<premises>`, denoting the premise patterns of the proof rule. This is either a list of formulas (via `:premises`) or the specification of list of premises via (via `:premise-list`), which will be described in detail later.
- `<arguments>`, denoting argument patterns of provide to a proof rule.
- `<requirements>`, denoting a list of pairs of terms.
Proof rules with assumptions `<assumption>` are used in proof with local scopes and will be discussed in detail later.

At a high level, an application of a proof rule is given a concrete list of (premise) proofs, and a concrete list of (argument) terms.
A proof rule checks if a substitution `S` can be found such that:
- The formulas proven by the premise proofs match provided premise patterns under substitution `S`,
- The argument terms match the provided argument patterns under substitution `S`,
- The requirements are *satisfied* under substitution `S`, namely, each pair of terms in the requirements list evaluates pairwise to the same term.
If these criteria are met, then the proof rule proves the result of applying `S` to the conclusion term.

A proof rule is only well defined if the free parameters of the requirements and conclusion term are also contained in the arguments and premises.

### Example rule: Reflexivity of equality

```
(declare-const = (-> (! Type :var T :implicit) T T Bool))
(declare-rule refl ((T Type) (t T))
    :premises ()
    :args (t)
    :conclusion (= t t)
)
```

The above example defines the rule for reflexivity of equality.
First a parameter list is provided that introduces a type `T` and a term `t` of that type.
The rule takes no premises, a term `t` and proves `(= t t)`.
Notice that the type `T` is a part of the parameter list and not explicitly provided as an argument to this rule.

### Example rule: Symmetry of Equality

```
(declare-const = (-> (! Type :var T :implicit) T T Bool))
(declare-rule symm ((T Type) (t T) (s T))
    :premises ((= t s))
    :conclusion (= s t)
)
```

This rule specifies symmetry of equality.
Given a proof of some equality `(= a b)` for terms `a`, `b`, this rule will prove `(= b a)`.
In detail, an application of this proof rule will compute the substitution `{ t -> a, s -> b }` and apply it to the conclusion term to obtain `(= b a)`.

## Requirements

A list of requirements can be given to a proof rule.

## Premise lists

A rule can take an arbitrary number of premises via the syntax `:premise-list <term> <term>`.

### Example rule:


## Axioms

The ALF language supports a command `declare-axiom`, which is a simplified version of `declare-rule`:
```
(declare-axiom <symbol> (<sorted-var>*) <requirements>? <term>)
<requirements>  ::= :requires ((<term> <term>)*)
```

The command
```
(declare-axiom S ((t1 T1) ... (tn Tn)) R? t)
```
is syntax sugar for
```
(declare-rule S ((t1 T1) ... (tn Tn)) :args (t1 ... tn) R? :conclusion t)
```
where `R` is an (optional) requirements annotation.
More generally, any argument `t1 ... tn` that is marked with `:implicit` from the argument list of the declared rule.

### Example: reflexive equality as axiom

Note the following definition is equivalent to the previously declared version of `refl`:
```
(declare-const = (-> (! Type :var T :implicit) T T Bool))
(declare-axiom refl ((T Type :implicit) (t T))
    (= t t))
)
```
The argument `T` to `refl` has been marked as `:implicit`, and thus it does not appear in the
argument


# Defining Proofs

The ALF language provies the commands `assume` and `step` for defining proofs. Their syntax is given by:
```
(assume <symbol> <term>)
(step <symbol> <term>? :rule <symbol> <premises>? <arguments>?)
where
<premises>      ::= :premises (<term>*)
<arguments>     ::= :args (<term>*)
```


## Proofs with scopes


# Computations in alfc


## Type rules for BitVectors


## Type rule for BitVector constants


## Term evaluator


# Side Conditions


## Example:

## Transitivity rule with arbitrary arguments

## A computational type rule

## Match

## Term evaluator

# Oracles


## Example:

# Full syntax for commands
